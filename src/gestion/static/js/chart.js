/**
 * Minification ignorée car les fichiers originaux semblent déjà être minifiés.
 * Fichier d'origine : /npm/chart.js@4.4.5/dist/chart.umd.js
 *
 * N'utilisez PAS SRI avec des fichiers générés dynamiquement ! Plus d'informations : https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/*!
 * Chart.js v4.4.5
 * https://www.chartjs.org
 * (c) 2024 Contributeurs de Chart.js
 * Publié sous la licence MIT
 */
!function (t, e) { "object" == typeof exportations && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).Chart = e() }(this, (function () { "use strict"; var t = Object.freeze({ __proto__: null, obtenir Couleurs() {retour Go }, obtenir Décimation() {retour Qo }, obtenir Remplissage() {retour ma }, obtenir Légende() {retour ya }, obtenir Sous- titre(){ retour ka }, obtenir Titre(){ retour Ma }, obtenir Info - bulle(){ retour Ba }}); function e() { } const i = (() => { let t = 0; return () => t++ })(); function s(t) {retour null == t } function n(t) { si(Array.isArray && Array.isArray(t))retour!0; const e = Object.prototype.toString.call(t);retour"[object" === e.slice(0, 7) && "Array]" === e.slice(-6) }fonction o(t){retour null !== t && "[object Object]" === Object.prototype.toString.call(t) }fonction a(t){ retour("number" == typeof t || t instanceof Number) && isFinite(+t) }fonction r(t, e){retour a(t) ? t : e }fonction l(t, e){retour void 0 === t ? e : t } const h = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 : +t / e, c = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 * e : +t; function d(t, e, i) { if (t && "function" == typeof t.call) return t.apply(i, e) } function u(t, e, i, s) { let a, r, l; if (n(t)) if (r = t.length, s) for (a = r - 1; a >= 0; a--)e.call(i, t[a], a); else for (a = 0; a < r; a++)e.call(i, t[a], a); else si(o(t))pour(l = Object.keys(t), r = l.length, a = 0; a < r; a++) e.call(i, t[l[a]], l[a]) }fonction f(t, e){ let i, s, n, o; si(!t || !e || t.length !== e.length)retour!1; pour(i = 0, s = t.length; i < s; ++i) si(n = t[i], o = e[i], n.datasetIndex !== o.datasetIndex || n.index !== o.index)retour!1; retour!0 }fonction g(t){ si(n(t))retour t.map(g); si(o(t)){ const e = Object.create(null), i = Object.keys(t), s = i.length; let n = 0; for (; n < s; ++n)e[i[n]] = g(t[i[n]]);retour e }retour t }fonction p(t){ retour - 1 === ["__proto__", "prototype", "constructeur"].indexOf(t) }fonction m(t, e, i, s){ si(!p(t))retour; const n = e[t], a = i[t]; o(n) && o(a) ? b(n, a, s) : e[t] = g(a) }fonction b(t, e, i){ const s = n(e) ? e : [e], a = s.length; si(!o(t))retour t; const r = (i = i || {}).merger || m; let l; for (let e = 0; e < a; ++e) { si(l = s[e], !o(l))continue; const n = Object.keys(l); for (soit e = 0, s = n.length; e < s; ++e) r(n[e], t, l, i) }retour t }fonction x(t, e){retour b(t, e, { fusion: _ }) }fonction _(t, e, i){ si(!p(t))retour; const s = e[t], n = i[t]; o(s) && o(n) ? x(s, n) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = g(n)) } const y = { "": t => t, x: t => tx, y: t => ty };fonction v(t){ const e = t.split("."), i = [];soit s = ""; pour(const t de e) s+=t, s.endsWith("\\") ? s = s.slice(0, -1) + "." : (i.push(s), s = "");retour i }fonction M(t, e){ const i = y[e] || (y[e] = fonction(t){ const e = v(t);retour t => { pour(const i de e) { si("" === i)break; t = t && t[i] }retour t }}(e));retour i(t)}fonction w(t){retour t.charAt(0).toUpperCase() + t.slice(1) } const k = t => void 0 !== t, S = t => "function" == typeof t, P = (t, e) => { if (t.size !== e.size) return !1; for (const i of t) if (!e.has(i)) return !1; return !0 }; function D(t) { return "mouseup" === t.type || "click" === t.type || "contextmenu" === t.type } const C = Math.PI, O = 2 * C, A = O + C, T = Number.POSITIVE_INFINITY, L = C / 180, E = C / 2, R = C / 4, I = 2 * C / 3, z = Math.log10, F = Math.sign; function V(t, e, i) { return Math.abs(te) < i } function B(t) { const e = Math.round(t); t = V(t, e, t / 1e3) ? e : t; const i = Math.pow(10, Math.floor(z(t))), s = t / i; retour(s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * i }fonction W(t){ const e = [], i = Math.sqrt(t); let s; for (s = 1; s < i; s++)t % s == 0 && (e.push(s), e.push(t / s));retour i === (0 | i) && e.push(i), e.sort(((t, e) => te)).pop(), e }fonction N(t){ retour!isNaN(parseFloat(t)) && isFinite(t) }fonction H(t, e){ const i = Math.round(t);retourne ie <= t && i + e >= t }fonction j(t, e, i){soit s, n, o; pour(s = 0, n = t.length; s < n; s++) o = t[s][i], isNaN(o) || (e.min = Math.min(e.min, o), e.max = Math.max(e.max, o)) }fonction $(t){retourne t * (C / 180) }fonction Y(t){retourne t * (180 / C) }fonction U(t){ si(!a(t))retourne;soit e = 1, i = 0; pour(; Math.round(t * e) / e !== t;) e *= 10, i++;retourne i }fonction X(t, e){ const i = ex - tx, s = ey - ty, n = Math.sqrt(i * i + s * s);soit o = Math.atan2(s, i);retour o < -.5 * C && (o += O), { angle: o, distance: n } }fonction q(t, e){retour Math.sqrt(Math.pow(ex - tx, 2) + Math.pow(ey - ty, 2)) }fonction K(t, e){ retour(t - e + A) % OC }fonction G(t){ retour(t % O + O) % O }fonction Z(t, e, i, s){ const n = G(t), o = G(e), a = G(i), r = G(on), l = G(an), h = G(no), c = G(na);retour n === o || n === a || s && o === a || r > l && h < c }fonction J(t, e, i){retour Math.max(e, Math.min(i, t)) }fonction Q(t){retour J(t, -32768, 32767) }fonction tt(t, e, i, s = 1e-6){retour t >= Math.min(e, i) - s && t <= Math.max(e, i) + s }fonction et(t, e, i){ i = i || (i => t[i] < e); let s, n = t.length - 1, o = 0; for (; no > 1;)s = o + n >> 1, i(s) ? o = s : n = s;retour{ lo: o, hi: n } } const it = (t, e, i, s) => et(t, i, s ? s => { const n = t[s][e];retour n < i || n === i && t[s + 1][e] === i } : s => t[s][e] < i), st = (t, e, i) => et(t, i, (s => t[s][e] >= i));fonction nt(t, e, i){ let s = 0, n = t.length; for (; s < n && t[s] < e;)s++; for (; n > s && t[n - 1] > i;)n--; return s > 0 || n < t.length ? t.slice(s, n) : t } const ot = ["push", "pop", "shift", "splice", "unshift"];fonction at(t, e){ t._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, "_chartjs", { configurable: !0, enumerable: !1, value: { auditeurs: [e] } }), ot.forEach((e => { const i = "_onData" + w(e), s = t[e]; Object.defineProperty(t, e, { configurable: !0, enumerable: !1, value(...e) { const n = s.apply(this, e); return t._chartjs.listeners.forEach((t => { "function" == typeof t[i] && t[i](...e) })), n } }) }))) } function rt(t, e) { const i = t._chartjs; if (!i) return; const s = i.listeners, n = s.indexOf(e); -1 !== n && s.splice(n, 1), s.length > 0 || (ot.forEach((e => {supprimer t[e] })), supprimer t._chartjs) }fonction lt(t){ const e = new Set(t);retour e.size === t.length ? t : Array.from(e) } const ht = "undefined" == typeof window ? function (t) { return t() } : window.requestAnimationFrame; function ct(t, e) { let i = [], s = !1; return function (...n) { i = n, s || (s = !0, ht.call(window, (() => { s = !1, t.apply(e, i) }))) } } function dt(t, e) { let i; return function (...s) { return e ? (clearTimeout(i), i = setTimeout(t, e, s)) : t.apply(this, s), e } } const ut = t => "début" === t ? "gauche" : "fin" === t ? "droite" : "centre", ft = (t, e, i) => "début" === t ? e : "fin" === t ? i : (e + i) / 2, gt = (t, e, i, s) => t === (s ? "gauche" : "droite") ? i : "centre" === t ? (e + i) / 2 : e;fonction pt(t, e, i){ const s = e.length; let n = 0, o = s; si(t._sorted){ const { iScale: a, _parsed: r } = t, l = a.axis, { min: h, max: c, minDefined: d, maxDefined: u } = a.getUserBounds(); d && (n = J(Math.min(it(r, l, h).lo, i ? s : it(e, l, a.getPixelForValue(h)).lo), 0, s - 1)), o = u ? J(Math.max(it(r, a.axis, c, !0).hi + 1, i ? 0 : it(e, l, a.getPixelForValue(c), !0).hi + 1), n, s) - n : sn }retour{ début: n, compte: o } }fonction mt(t){ const { xScale: e, yScale: i, _scaleRanges: s } = t, n = { xmin: e.min, xmax: e.max, ymin: i.min, ymax: i.max }; si(!s)retour t._scaleRanges = n, !0; const o = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;retour Objet.assign(s, n), o }classe bt{ constructeur(){ this._request = null, this._charts = nouvelle carte, this._running = !1, this._lastDate = void 0 } _notify(t, e, i, s){ const n = e.auditeurs[s], o = e.duration; n.forEach((s => s({ chart: t, initial: e.initial, numSteps: o, currentStep: Math.min(ie.start, o) }))) } _refresh(){ this._request || (this._running = !0, this._request = ht.call(window, (() => { this._update(), this._request = null, this._running && this._refresh() }))) } _update(t = Date.now()){ let e = 0; this._charts.forEach(((i, s) => { if (!i.running || !i.items.length) return; const n = i.items; let o, a = n.length - 1, r = !1; for (; a >= 0; --a)o = n[a], o._active ? (o._total > i.duration && (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop()); r && (s.draw(), this._notify(s, i, t, "progress"), n.length || (i.running = !1, this._notify(s, i, t, "complete"), i.initial = !1), e += n.length})), this._lastDate = t, 0 === e && (this._running = !1) } _getAnims(t){ const e = this._charts; let i = e.get(t); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, e.set(t, i)), i } listen(t, e, i){ this._getAnims(t).listeners[e].push(i) } add(t, e){ e && e.length && this._getAnims(t).items.push(...e) } has(t){ return this._getAnims(t).items.length > 0 } start(t){ const e = this._charts.get(t); e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(((t, e) => Math.max(t, e._duration)), 0), this._refresh()) } running(t){ si(!this._running)retour!1; const e = this._charts.get(t); retour!!(e && e.running && e.items.length) } stop(t){ const e = this._charts.get(t); si(!e || !e.items.length)retour; const i = e.items; let s = i.length - 1; for (; s >= 0; --s)i[s].cancel(); e.items = [], this._notify(t, e, Date.now(), "complete") } remove(t){ return this._charts.delete(t) } } var xt = nouveau bt; requestAnimationFrame; fonction ct(t, e){ let i = [], s = !1; renvoie function(...n) { i = n, s || (s = !0, ht.call(window, (() => { s = !1, t.apply(e, i) }))) } } fonction dt(t, e){ let i; renvoie function(...s) { renvoie e ? (clearTimeout(i), i = setTimeout(t, e, s)) : t.apply(this, s), e } } const ut = t => "start" === t ? "left" : "end" === t ? "right" : "center", ft = (t, e, i) => "start" === t ? e : "end" === t ? i : (e + i) / 2, gt = (t, e, i, s) => t === (s ? "left" : "right") ? i : "center" === t ? (e + i) / 2 : e; fonction pt(t, e, i){ const s = e.length; let n = 0, o = s; if (t._sorted) { const { iScale: a, _parsed: r } = t, l = a.axis, { min: h, max: c, minDefined: d, maxDefined: u } = a.getUserBounds(); d && (n = J(Math.min(it(r, l, h).lo, i ? s : it(e, l, a.getPixelForValue(h)).lo), 0, s - 1)), o = u ? J(Math.max(it(r, a.axis, c, !0).hi + 1, i ? 0 : it(e, l, a.getPixelForValue(c), !0).hi + 1), n, s) - n : sn }retour{ début: n, compte: o } }fonction mt(t){ const { xScale: e, yScale: i, _scaleRanges: s } = t, n = { xmin: e.min, xmax: e.max, ymin: i.min, ymax: i.max }; si(!s)retour t._scaleRanges = n, !0; const o = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;retour Objet.assign(s, n), o }classe bt{ constructeur(){ this._request = null, this._charts = nouvelle carte, this._running = !1, this._lastDate = void 0 } _notify(t, e, i, s){ const n = e.auditeurs[s], o = e.duration; n.forEach((s => s({ chart: t, initial: e.initial, numSteps: o, currentStep: Math.min(ie.start, o) }))) } _refresh(){ this._request || (this._running = !0, this._request = ht.call(window, (() => { this._update(), this._request = null, this._running && this._refresh() }))) } _update(t = Date.now()){ let e = 0; this._charts.forEach(((i, s) => { if (!i.running || !i.items.length) return; const n = i.items; let o, a = n.length - 1, r = !1; for (; a >= 0; --a)o = n[a], o._active ? (o._total > i.duration && (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop()); r && (s.draw(), this._notify(s, i, t, "progress"), n.length || (i.running = !1, this._notify(s, i, t, "complete"), i.initial = !1), e += n.length})), this._lastDate = t, 0 === e && (this._running = !1) } _getAnims(t){ const e = this._charts; let i = e.get(t); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, e.set(t, i)), i } listen(t, e, i){ this._getAnims(t).listeners[e].push(i) } add(t, e){ e && e.length && this._getAnims(t).items.push(...e) } has(t){ return this._getAnims(t).items.length > 0 } start(t){ const e = this._charts.get(t); e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(((t, e) => Math.max(t, e._duration)), 0), this._refresh()) } running(t){ si(!this._running)retour!1; const e = this._charts.get(t); retour!!(e && e.running && e.items.length) } stop(t){ const e = this._charts.get(t); si(!e || !e.items.length)retour; const i = e.items; let s = i.length - 1; for (; s >= 0; --s)i[s].cancel(); e.items = [], this._notify(t, e, Date.now(), "complete") } remove(t){ return this._charts.delete(t) } } var xt = nouveau bt; requestAnimationFrame; fonction ct(t, e){ let i = [], s = !1; renvoie function(...n) { i = n, s || (s = !0, ht.call(window, (() => { s = !1, t.apply(e, i) }))) } } fonction dt(t, e){ let i; renvoie function(...s) { renvoie e ? (clearTimeout(i), i = setTimeout(t, e, s)) : t.apply(this, s), e } } const ut = t => "start" === t ? "left" : "end" === t ? "right" : "center", ft = (t, e, i) => "start" === t ? e : "end" === t ? i : (e + i) / 2, gt = (t, e, i, s) => t === (s ? "left" : "right") ? i : "center" === t ? (e + i) / 2 : e; fonction pt(t, e, i){ const s = e.length; let n = 0, o = s; if (t._sorted) { const { iScale: a, _parsed: r } = t, l = a.axis, { min: h, max: c, minDefined: d, maxDefined: u } = a.getUserBounds(); d && (n = J(Math.min(it(r, l, h).lo, i ? s : it(e, l, a.getPixelForValue(h)).lo), 0, s - 1)), o = u ? J(Math.max(it(r, a.axis, c, !0).hi + 1, i ? 0 : it(e, l, a.getPixelForValue(c), !0).hi + 1), n, s) - n : sn }retour{ début: n, compte: o } }fonction mt(t){ const { xScale: e, yScale: i, _scaleRanges: s } = t, n = { xmin: e.min, xmax: e.max, ymin: i.min, ymax: i.max }; si(!s)retour t._scaleRanges = n, !0; const o = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;retour Objet.assign(s, n), o }classe bt{ constructeur(){ this._request = null, this._charts = nouvelle carte, this._running = !1, this._lastDate = void 0 } _notify(t, e, i, s){ const n = e.auditeurs[s], o = e.duration; n.forEach((s => s({ chart: t, initial: e.initial, numSteps: o, currentStep: Math.min(ie.start, o) }))) } _refresh(){ this._request || (this._running = !0, this._request = ht.call(window, (() => { this._update(), this._request = null, this._running && this._refresh() }))) } _update(t = Date.now()){ let e = 0; this._charts.forEach(((i, s) => { if (!i.running || !i.items.length) return; const n = i.items; let o, a = n.length - 1, r = !1; for (; a >= 0; --a)o = n[a], o._active ? (o._total > i.duration && (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop()); r && (s.draw(), this._notify(s, i, t, "progress"), n.length || (i.running = !1, this._notify(s, i, t, "complete"), i.initial = !1), e += n.length})), this._lastDate = t, 0 === e && (this._running = !1) } _getAnims(t){ const e = this._charts; let i = e.get(t); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, e.set(t, i)), i } listen(t, e, i){ this._getAnims(t).listeners[e].push(i) } add(t, e){ e && e.length && this._getAnims(t).items.push(...e) } has(t){ return this._getAnims(t).items.length > 0 } start(t){ const e = this._charts.get(t); e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(((t, e) => Math.max(t, e._duration)), 0), this._refresh()) } running(t){ si(!this._running)retour!1; const e = this._charts.get(t); retour!!(e && e.running && e.items.length) } stop(t){ const e = this._charts.get(t); si(!e || !e.items.length)retour; const i = e.items; let s = i.length - 1; for (; s >= 0; --s)i[s].cancel(); e.items = [], this._notify(t, e, Date.now(), "complete") } remove(t){ return this._charts.delete(t) } } var xt = nouveau bt;e) { let i; return function (...s) { return e ? (clearTimeout(i), i = setTimeout(t, e, s)) : t.apply(this, s), e } } const ut = t => "start" === t ? "left" : "end" === t ? "right" : "center", ft = (t, e, i) => "start" === t ? e : "end" === t ? i : (e + i) / 2, gt = (t, e, i, s) => t === (s ? "left" : "right") ? i : "center" === t ? (e + i) / 2 : e; function pt(t, e, i) { const s = e.length; let n = 0, o = s; si(t._sorted){ const { iScale: a, _parsed: r } = t, l = a.axis, { min: h, max: c, minDefined: d, maxDefined: u } = a.getUserBounds(); d && (n = J(Math.min(it(r, l, h).lo, i ? s : it(e, l, a.getPixelForValue(h)).lo), 0, s - 1)), o = u ? J(Math.max(it(r, a.axis, c, !0).hi + 1, i ? 0 : it(e, l, a.getPixelForValue(c), !0).hi + 1), n, s) - n : sn }retour{ début: n, compte: o } }fonction mt(t){ const { xScale: e, yScale: i, _scaleRanges: s } = t, n = { xmin: e.min, xmax: e.max, ymin: i.min, ymax: i.max }; si(!s)retour t._scaleRanges = n, !0; const o = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;retour Objet.assign(s, n), o }classe bt{ constructeur(){ this._request = null, this._charts = nouvelle carte, this._running = !1, this._lastDate = void 0 } _notify(t, e, i, s){ const n = e.auditeurs[s], o = e.duration; n.forEach((s => s({ chart: t, initial: e.initial, numSteps: o, currentStep: Math.min(ie.start, o) }))) } _refresh(){ this._request || (this._running = !0, this._request = ht.call(window, (() => { this._update(), this._request = null, this._running && this._refresh() }))) } _update(t = Date.now()){ let e = 0; this._charts.forEach(((i, s) => { if (!i.running || !i.items.length) return; const n = i.items; let o, a = n.length - 1, r = !1; for (; a >= 0; --a)o = n[a], o._active ? (o._total > i.duration && (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop()); r && (s.draw(), this._notify(s, i, t, "progress"), n.length || (i.running = !1, this._notify(s, i, t, "complete"), i.initial = !1), e += n.length})), this._lastDate = t, 0 === e && (this._running = !1) } _getAnims(t){ const e = this._charts; let i = e.get(t); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, e.set(t, i)), i } listen(t, e, i){ this._getAnims(t).listeners[e].push(i) } add(t, e){ e && e.length && this._getAnims(t).items.push(...e) } has(t){ return this._getAnims(t).items.length > 0 } start(t){ const e = this._charts.get(t); e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(((t, e) => Math.max(t, e._duration)), 0), this._refresh()) } running(t){ si(!this._running)retour!1; const e = this._charts.get(t); retour!!(e && e.running && e.items.length) } stop(t){ const e = this._charts.get(t); si(!e || !e.items.length)retour; const i = e.items; let s = i.length - 1; for (; s >= 0; --s)i[s].cancel(); e.items = [], this._notify(t, e, Date.now(), "complete") } remove(t){ return this._charts.delete(t) } } var xt = nouveau bt;e) { let i; return function (...s) { return e ? (clearTimeout(i), i = setTimeout(t, e, s)) : t.apply(this, s), e } } const ut = t => "start" === t ? "left" : "end" === t ? "right" : "center", ft = (t, e, i) => "start" === t ? e : "end" === t ? i : (e + i) / 2, gt = (t, e, i, s) => t === (s ? "left" : "right") ? i : "center" === t ? (e + i) / 2 : e; function pt(t, e, i) { const s = e.length; let n = 0, o = s; si(t._sorted){ const { iScale: a, _parsed: r } = t, l = a.axis, { min: h, max: c, minDefined: d, maxDefined: u } = a.getUserBounds(); d && (n = J(Math.min(it(r, l, h).lo, i ? s : it(e, l, a.getPixelForValue(h)).lo), 0, s - 1)), o = u ? J(Math.max(it(r, a.axis, c, !0).hi + 1, i ? 0 : it(e, l, a.getPixelForValue(c), !0).hi + 1), n, s) - n : sn }retour{ début: n, compte: o } }fonction mt(t){ const { xScale: e, yScale: i, _scaleRanges: s } = t, n = { xmin: e.min, xmax: e.max, ymin: i.min, ymax: i.max }; si(!s)retour t._scaleRanges = n, !0; const o = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;retour Objet.assign(s, n), o }classe bt{ constructeur(){ this._request = null, this._charts = nouvelle carte, this._running = !1, this._lastDate = void 0 } _notify(t, e, i, s){ const n = e.auditeurs[s], o = e.duration; n.forEach((s => s({ chart: t, initial: e.initial, numSteps: o, currentStep: Math.min(ie.start, o) }))) } _refresh(){ this._request || (this._running = !0, this._request = ht.call(window, (() => { this._update(), this._request = null, this._running && this._refresh() }))) } _update(t = Date.now()){ let e = 0; this._charts.forEach(((i, s) => { if (!i.running || !i.items.length) return; const n = i.items; let o, a = n.length - 1, r = !1; for (; a >= 0; --a)o = n[a], o._active ? (o._total > i.duration && (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop()); r && (s.draw(), this._notify(s, i, t, "progress"), n.length || (i.running = !1, this._notify(s, i, t, "complete"), i.initial = !1), e += n.length})), this._lastDate = t, 0 === e && (this._running = !1) } _getAnims(t){ const e = this._charts; let i = e.get(t); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, e.set(t, i)), i } listen(t, e, i){ this._getAnims(t).listeners[e].push(i) } add(t, e){ e && e.length && this._getAnims(t).items.push(...e) } has(t){ return this._getAnims(t).items.length > 0 } start(t){ const e = this._charts.get(t); e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(((t, e) => Math.max(t, e._duration)), 0), this._refresh()) } running(t){ si(!this._running)retour!1; const e = this._charts.get(t); retour!!(e && e.running && e.items.length) } stop(t){ const e = this._charts.get(t); si(!e || !e.items.length)retour; const i = e.items; let s = i.length - 1; for (; s >= 0; --s)i[s].cancel(); e.items = [], this._notify(t, e, Date.now(), "complete") } remove(t){ return this._charts.delete(t) } } var xt = nouveau bt;s)=> t === (s ? "gauche" : "droite") ? i : "centre" === t ? (e + i) / 2 : e;fonction pt(t, e, i){ const s = e.length; let n = 0, o = s; si(t._sorted){ const { iScale: a, _parsed: r } = t, l = a.axis, { min: h, max: c, minDefined: d, maxDefined: u } = a.getUserBounds(); d && (n = J(Math.min(it(r, l, h).lo, i ? s : it(e, l, a.getPixelForValue(h)).lo), 0, s - 1)), o = u ? J(Math.max(it(r, a.axis, c, !0).hi + 1, i ? 0 : it(e, l, a.getPixelForValue(c), !0).hi + 1), n, s) - n : sn }retour{ début: n, compte: o } }fonction mt(t){ const { xScale: e, yScale: i, _scaleRanges: s } = t, n = { xmin: e.min, xmax: e.max, ymin: i.min, ymax: i.max }; si(!s)retour t._scaleRanges = n, !0; const o = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;retour Objet.assign(s, n), o }classe bt{ constructeur(){ this._request = null, this._charts = nouvelle carte, this._running = !1, this._lastDate = void 0 } _notify(t, e, i, s){ const n = e.auditeurs[s], o = e.duration; n.forEach((s => s({ chart: t, initial: e.initial, numSteps: o, currentStep: Math.min(ie.start, o) }))) } _refresh(){ this._request || (this._running = !0, this._request = ht.call(window, (() => { this._update(), this._request = null, this._running && this._refresh() }))) } _update(t = Date.now()){ let e = 0; this._charts.forEach(((i, s) => { if (!i.running || !i.items.length) return; const n = i.items; let o, a = n.length - 1, r = !1; for (; a >= 0; --a)o = n[a], o._active ? (o._total > i.duration && (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop()); r && (s.draw(), this._notify(s, i, t, "progress"), n.length || (i.running = !1, this._notify(s, i, t, "complete"), i.initial = !1), e += n.length})), this._lastDate = t, 0 === e && (this._running = !1) } _getAnims(t){ const e = this._charts; let i = e.get(t); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, e.set(t, i)), i } listen(t, e, i){ this._getAnims(t).listeners[e].push(i) } add(t, e){ e && e.length && this._getAnims(t).items.push(...e) } has(t){ return this._getAnims(t).items.length > 0 } start(t){ const e = this._charts.get(t); e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(((t, e) => Math.max(t, e._duration)), 0), this._refresh()) } running(t){ si(!this._running)retour!1; const e = this._charts.get(t); retour!!(e && e.running && e.items.length) } stop(t){ const e = this._charts.get(t); si(!e || !e.items.length)retour; const i = e.items; let s = i.length - 1; for (; s >= 0; --s)i[s].cancel(); e.items = [], this._notify(t, e, Date.now(), "complete") } remove(t){ return this._charts.delete(t) } } var xt = nouveau bt;s)=> t === (s ? "gauche" : "droite") ? i : "centre" === t ? (e + i) / 2 : e;fonction pt(t, e, i){ const s = e.length; let n = 0, o = s; si(t._sorted){ const { iScale: a, _parsed: r } = t, l = a.axis, { min: h, max: c, minDefined: d, maxDefined: u } = a.getUserBounds(); d && (n = J(Math.min(it(r, l, h).lo, i ? s : it(e, l, a.getPixelForValue(h)).lo), 0, s - 1)), o = u ? J(Math.max(it(r, a.axis, c, !0).hi + 1, i ? 0 : it(e, l, a.getPixelForValue(c), !0).hi + 1), n, s) - n : sn }retour{ début: n, compte: o } }fonction mt(t){ const { xScale: e, yScale: i, _scaleRanges: s } = t, n = { xmin: e.min, xmax: e.max, ymin: i.min, ymax: i.max }; si(!s)retour t._scaleRanges = n, !0; const o = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;retour Objet.assign(s, n), o }classe bt{ constructeur(){ this._request = null, this._charts = nouvelle carte, this._running = !1, this._lastDate = void 0 } _notify(t, e, i, s){ const n = e.auditeurs[s], o = e.duration; n.forEach((s => s({ chart: t, initial: e.initial, numSteps: o, currentStep: Math.min(ie.start, o) }))) } _refresh(){ this._request || (this._running = !0, this._request = ht.call(window, (() => { this._update(), this._request = null, this._running && this._refresh() }))) } _update(t = Date.now()){ let e = 0; this._charts.forEach(((i, s) => { if (!i.running || !i.items.length) return; const n = i.items; let o, a = n.length - 1, r = !1; for (; a >= 0; --a)o = n[a], o._active ? (o._total > i.duration && (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop()); r && (s.draw(), this._notify(s, i, t, "progress"), n.length || (i.running = !1, this._notify(s, i, t, "complete"), i.initial = !1), e += n.length})), this._lastDate = t, 0 === e && (this._running = !1) } _getAnims(t){ const e = this._charts; let i = e.get(t); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, e.set(t, i)), i } listen(t, e, i){ this._getAnims(t).listeners[e].push(i) } add(t, e){ e && e.length && this._getAnims(t).items.push(...e) } has(t){ return this._getAnims(t).items.length > 0 } start(t){ const e = this._charts.get(t); e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(((t, e) => Math.max(t, e._duration)), 0), this._refresh()) } running(t){ si(!this._running)retour!1; const e = this._charts.get(t); retour!!(e && e.running && e.items.length) } stop(t){ const e = this._charts.get(t); si(!e || !e.items.length)retour; const i = e.items; let s = i.length - 1; for (; s >= 0; --s)i[s].cancel(); e.items = [], this._notify(t, e, Date.now(), "complete") } remove(t){ return this._charts.delete(t) } } var xt = nouveau bt; min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;retour Objet.assign(s, n), o}classe bt{ constructeur(){ this._request = null, this._charts = nouvelle carte, this._running = !1, this._lastDate = void 0 } _notify(t, e, i, s){ const n = e.auditeurs[s], o = e.duration; n.forEach((s => s({ chart: t, initial: e.initial, numSteps: o, currentStep: Math.min(ie.start, o) }))) } _refresh(){ this._request || (this._running = !0, this._request = ht.call(window, (() => { this._update(), this._request = null, this._running && this._refresh() }))) } _update(t = Date.now()){ let e = 0; this._charts.forEach(((i, s) => { if (!i.running || !i.items.length) return; const n = i.items; let o, a = n.length - 1, r = !1; for (; a >= 0; --a)o = n[a], o._active ? (o._total > i.duration && (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop()); r && (s.draw(), this._notify(s, i, t, "progress"), n.length || (i.running = !1, this._notify(s, i, t, "complete"), i.initial = !1), e += n.length})), this._lastDate = t, 0 === e && (this._running = !1) } _getAnims(t){ const e = this._charts; let i = e.get(t); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, e.set(t, i)), i } listen(t, e, i){ this._getAnims(t).listeners[e].push(i) } add(t, e){ e && e.length && this._getAnims(t).items.push(...e) } has(t){ return this._getAnims(t).items.length > 0 } start(t){ const e = this._charts.get(t); e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(((t, e) => Math.max(t, e._duration)), 0), this._refresh()) } running(t){ si(!this._running)retour!1; const e = this._charts.get(t); retour!!(e && e.running && e.items.length) } stop(t){ const e = this._charts.get(t); si(!e || !e.items.length)retour; const i = e.items; let s = i.length - 1; for (; s >= 0; --s)i[s].cancel(); e.items = [], this._notify(t, e, Date.now(), "complete") } remove(t){ return this._charts.delete(t) } } var xt = nouveau bt; min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;retour Objet.assign(s, n), o}classe bt{ constructeur(){ this._request = null, this._charts = nouvelle carte, this._running = !1, this._lastDate = void 0 } _notify(t, e, i, s){ const n = e.auditeurs[s], o = e.duration; n.forEach((s => s({ chart: t, initial: e.initial, numSteps: o, currentStep: Math.min(ie.start, o) }))) } _refresh(){ this._request || (this._running = !0, this._request = ht.call(window, (() => { this._update(), this._request = null, this._running && this._refresh() }))) } _update(t = Date.now()){ let e = 0; this._charts.forEach(((i, s) => { if (!i.running || !i.items.length) return; const n = i.items; let o, a = n.length - 1, r = !1; for (; a >= 0; --a)o = n[a], o._active ? (o._total > i.duration && (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop()); r && (s.draw(), this._notify(s, i, t, "progress"), n.length || (i.running = !1, this._notify(s, i, t, "complete"), i.initial = !1), e += n.length})), this._lastDate = t, 0 === e && (this._running = !1) } _getAnims(t){ const e = this._charts; let i = e.get(t); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, e.set(t, i)), i } listen(t, e, i){ this._getAnims(t).listeners[e].push(i) } add(t, e){ e && e.length && this._getAnims(t).items.push(...e) } has(t){ return this._getAnims(t).items.length > 0 } start(t){ const e = this._charts.get(t); e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(((t, e) => Math.max(t, e._duration)), 0), this._refresh()) } running(t){ si(!this._running)retour!1; const e = this._charts.get(t); retour!!(e && e.running && e.items.length) } stop(t){ const e = this._charts.get(t); si(!e || !e.items.length)retour; const i = e.items; let s = i.length - 1; for (; s >= 0; --s)i[s].cancel(); e.items = [], this._notify(t, e, Date.now(), "complete") } remove(t){ return this._charts.delete(t) } } var xt = nouveau bt;e) { e && e.length && this._getAnims(t).items.push(...e) } has(t){retourne this._getAnims(t).items.length > 0 } début(t){ const e = this._charts.get(t); e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(((t, e) => Math.max(t, e._duration)), 0), this._refresh()) } running(t){ si(!this._running)retourne!1; const e = this._charts.get(t); retourne!!(e && e.running && e.items.length) } arrêt(t){ const e = this._charts.get(t); si(!e || !e.items.length)retour; const i = e.items;soit s = i.length - 1; pour(; s >= 0; --s) i[s].cancel(); e.items = [], this._notify(t, e, Date.now(), "complete") } supprimer(t){retourner this._charts.delete(t) }}var xt = nouveau bt;e) { e && e.length && this._getAnims(t).items.push(...e) } has(t){retourne this._getAnims(t).items.length > 0 } début(t){ const e = this._charts.get(t); e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(((t, e) => Math.max(t, e._duration)), 0), this._refresh()) } running(t){ si(!this._running)retourne!1; const e = this._charts.get(t); retourne!!(e && e.running && e.items.length) } arrêt(t){ const e = this._charts.get(t); si(!e || !e.items.length)retour; const i = e.items;soit s = i.length - 1; pour(; s >= 0; --s) i[s].cancel(); e.items = [], this._notify(t, e, Date.now(), "complete") } supprimer(t){retourner this._charts.delete(t) }}var xt = nouveau bt;
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Publié sous la licence MIT
 */fonction _t(t){retour t + .5 | 0 } const yt = (t, e, i) => Math.max(Math.min(t, i), e);fonction vt(t){retour yt(_t(2.55 * t), 0, 255) }fonction Mt(t){retour yt(_t(255 * t), 0, 255) }fonction wt(t){retour yt(_t(t / 2.55) / 100, 0, 1) }fonction kt(t){retour yt(_t(100 * t), 0, 100) } const St = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Pt = [..."0123456789ABCDEF"], Dt = t => Pt[15 & t], Ct = t => Pt[(240 & t) >> 4] + Pt[15 & t], Ot = t => (240 & t) >> 4 == (15 & t);fonction At(t){ var e = (t => Ot(tr) && Ot(tg) && Ot(tb) && Ot(ta))(t) ? Dt : Ct; return t ? "#" + e(tr) + e(tg) + e(tb) + ((t, e) => t < 255 ? e(t) : "")(ta, e) : void 0 } const * ([-+.e\d] +)(?: deg) ? [\s,] + ([-+.e\d] +) % [\s,] + ([-+.e\d] +) % (?: [\s,] + ([-+.e\d] +)(%) ?) ?\s *\) $ /;fonction Lt(t, e, i){ const s = e * Math.min(i, 1 - i), n = (e, n = (e + t / 30) % 12) => is * Math.max(Math.min(n - 3, 9 - n, 1), -1); retour[n(0), n(8), n(4)] }fonction Et(t, e, i){ const s = (s, n = (s + t / 60) % 6) => ii * e * Math.max(Math.min(n, 4 - n, 1), 0); retour[s(5), s(3), s(1)] }fonction Rt(t, e, i){ const s = Lt(t, 1, .5);soit n; pour(e + i > 1 && (n = 1 / (e + i), e *= n, i *= n), n = 0; n < 3; n++) s[n] *= 1 - ei, s[n] += e;retour s }fonction It(t){ const e = tr / 255, i = tg / 255, s = tb / 255, n = Math.max(e, i, s), o = Math.min(e, i, s), a = (n + o) / 2;soit r, l, h;retourne n !== o && (h = no, l = a > .5 ? h / (2 - no) : h / (n + o), r = function (t, e, i, s, n) {retourne t === n ? (ei) / s + (e < i ? 6 : 0) : e === n ? (it) / s + 2 : (te) / s + 4 }(e, i, s, h, n), r = 60 * r + .5), [0 | r, l || 0, a] }fonction zt(t, e, i, s){ retour(Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, s)).map(Mt) }fonction Ft(t, e, i){retour zt(Lt, t, e, i) }fonction Vt(t){ retour(t % 360 + 360) % 360 }fonction Bt(t){ const e = Tt.exec(t); let i, s = 255; if (!e) retour; e[5] !== i && (s = e[6] ? vt(+e[5]) : Mt(+e[5])); const n = Vt(+e[2]), o = +e[3] / 100, a = +e[4] / 100;retour i = "hwb" === e[1] ? function (t, e, i) {retour zt(Rt, t, e, i) }(n, o, a) : "hsv" === e[1] ? function (t, e, i) {retour zt(Et, t, e, i) }(n, o, a) : Ft(n, o, a), { r: i[0], g: i[1], b: i[2], a: s } } const Wt = { x: "dark", Z: "light", Y: "re", X: "blu", W: "gr", V: "medium", U: "slate", A: "ee", T: "ol", S: "or", B: "ra", C: "lateg", D: "ights", R: "in", Q: "turquois", E: "hi", P: "ro", O: "al", N: "le", M: "de", L: "yello", F: "en", K: "ch", G: "arks", H: "ea", I: "ightg", J: "wh" }, Nt = { OiceXe: "f0f8ff", antiquewEte: "faebd7", aqua: "ffff", aquamarRe: "7fffd4", azuY: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", noir: "0", blanKedOmond: "ffebcd", Xe: "ff", XeviTet: "8a2be2", bPwn: "a52a2a", burlywood: "deb887", caMtXe: "5f9ea0", KartYuse: "7fff00", KocTate: "d2691e", cSO: "ff7f50", cSnflowerXe: "6495ed", cSnsilk: "fff8dc", cramoisi: "dc143c", cyan: "ffff", xXe: "8b", xcyan: "8b8b", xgTMnPd: "b8860b", xWay: "a9a9a9", xgYF: "6400", xgYy: "a9a9a9", xkhaki: "bdb76b", xmagFta: "8b008b ", xTivegYF: "556b2f", xSange: "ff8c00", xScEd: "9932cc", xYd: "8b0000", xsOmon: "e9967a", xsHgYF: "8fbc8f", xUXe: "483d8b", xUWay: "2f4f4f", xUgYy: "2f4f4f", xQe: "ced1", xviTet: "9400d3", dAppRk: "ff1493", dApskyXe: "bfff", dimWay: "696969", dimgYy: "696969", dodgerXe: "1e90ff", fiYbrick: "b22222", flSOwEte: "ffffaf0", foYstWAn: "228b22", fuKsia: "ff00ff", gaRsbSo: "dcdcdc", g hôte: "f8f8ff", gTd: "ffd700", gTMnPd: "daa520", Way: "808080", gYF: "8000", gYFLw: "adff2f", gYy: "808080", honeyMw: "f0fff0", hotpRk: "ff69b4", RdianYd: "cd5c5c", Rdigo: "4b0082", ivSy: "fffff0", kaki: "f0e68c", lavFMr: "e6e6fa", lavFMrXsh: "fff0f5", lawngYF: "7cfc00", NmoncEffon: "fffacd", ZXe: "add8e6", ZcSO: "f08080", Zcyan: "e0ffff", ZgTMnPdLw: "fafad2", ZWay: "d3d3d3", ZgYF: "90ee90", ZgYy: "d3d3d3", ZpRk: "ffb6c1", ZsOmon: "ffa07a", ZsHgYF: "20b2aa", ZskyXe: "87cefa", ZUWay: "778899", ZUgYy: "77 8899", ZstAlXe: "b0c4de", ZLw: "ffffe0", lime: "ff00", limegYF: "32cd32", lRF: "faf0e6", magFta: "ff00ff", maPon: "800000", VaquamarRe: "66cdaa", VXe: "cd", VScEd: "ba55d3", VpurpN: "9370db", VsHgYF: "3cb371", VUXe: "7b68ee", VsprRggYF: "fa9a", VQe: "48d1cc ", VviTetYd: "c71585", midnightXe: "191970", mRtcYam: "f5fffa", mistyPse: "ffe4e1", moccasR: "ffe4b5", navajowEte: "ffdead", navy: "80", Tdlace: "fdf5e6", Tive: « 808000 », TivedBb: « 6b8e23 », Sange: « ffa500 », SangeYd: « ff4500 », ScEd: « da70d6 », pOegTMnPd: « e ee8aa", pOegYF:"98fb98", pOeQe:"afeeee", pOeviTetYd:"db7093", papayawEp:"ffefd5", pHKpuff:"ffdab9", pérou:"cd853f", pRk:"ffc0cb", prune:"dda0dd" ,powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"41 69e1", saddNbPwn: "8b4513", sOmon: "fa8072", sandybPwn: "f4a460", sHgYF: "2e8b57", sHshell: "fff5ee", siFna: "a0522d", argent: "c0c0c0", skyXe: "87ceeb" ,UXe:"6a5acd",UWay:"708090",UgYy:"708090",neige:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan :"d2b48c",teO:"8080",tEstN:"d8bfd8",tomate:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};let Ht;fonction jt(t){Ht||(Ht=function(){const t={},e=Objet.keys(Nt),i=Objet.keys(Wt);let s,n,o,a,r;pour(s=0;s<e.length;s++){pour(a=r=e[s],n=0;n<i.length;n++)o=i[n],r=r.replace(o,Wt[o]);o=parseInt(Nt[a],16),t[r]=[o>>16&255,o>>8&255,255&o]}retour t}(),Ht.transparent=[0,0,0,0]);const e=Ht[t.toLowerCase()];retour e&&{r:e[0],g:e[1],b:e[2],a:4===e.length?e[3]:255}}const $t=/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;const Yt=t=>t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055,Ut=t=>t<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4);fonction Xt(t,e,i){si(t){let s=It(t);s[e]=Math.max(0,Math.min(s[e]+s[e]*i,0===e?360:1)),s=Ft(s),tr=s[0],tg=s[1],tb=s[2]}}fonction qt(t,e){retour t?Object.assign(e||{},t):t}fonction Kt(t){var e={r:0,g:0,b:0,a:255};retour Array.isArray(t)?t.length>=3&&(e={r:t[0],g:t[1],b:t[2],a:255},t.length>3&&(ea=Mt(t[3]))):(e=qt(t,{r:0,g:0,b:0,a:1})).a=Mt(ea),e}fonction Gt(t){retour"r"===t.charAt(0)?function(t){const e=$t.exec(t);let i,s,n,o=255;si(e){si(e[7]!==i){const t=+e[7];o=e[8]?vt(t):yt(255*t,0,255)}retour i=+e[1],s=+e[3],n=+e[5],i=255&(e[2]?vt(i):yt(i,0,255)),s=255&(e[4]?vt(s):yt(s,0,255)),n=255&(e[6]?vt(n):yt(n,0,255)),{r:i,g:s,b:n,a:o}}}(t):Bt(t)}classe Zt{constructeur(t){si(t instanceof Zt)retour t;const e=typeof t;let i;var s,n,o;"objet"===e?i=Kt(t):"chaîne"===e&&(o=(s=t).length,"#"===s[0]&&(4===o||5===o?n={r:255&17*St[s[1]],g:255&17*St[s[2]],b:255&17*St[s[3]],a:5===o?17*St[s[4]]:255}:7!== o&&9!==o||(n={r:St[s[1]]<<4|St[s[2]],g:St[s[3]]<<4|St[s[4]],b:St[s[5]]<<4|St[s[6]],a:9===o?St[s[7]]<<4|St[s[8]]:255})),i=n||jt(t)||Gt(t)),this._rgb=i,this._valid=!!i}obtenir valid(){retourne this._valid}get rgb(){var t=qt(this._rgb);retourne t&&(ta=wt(ta)),t}set rgb(t){this._rgb=Kt(t)}rgbString(){retourne this._valid?(t=this._rgb)&&(ta<255?`rgba(${tr}, ${tg}, ${tb}, ${wt(ta)})`:`rgb(${tr}, ${tg}, ${tb})`):void 0;var t}hexString(){retourne this._valid?At(this._rgb):void 0}hslString(){retourne this._valid?function(t){if(!t)return;const e=It(t),i=e[0],s=kt(e[1]),n=kt(e[2]);retour ta<255?`hsla(${i}, ${s}%, ${n}%, ${wt(ta)})`:`hsl(${i}, ${s}%, ${n}%)`}(this._rgb):void 0}mix(t,e){if(t){const i=this.rgb,s=t.rgb;let n;const o=e===n?.5:e,a=2*o-1,r=ia-sa,l=((a*r==-1?a:(a+r)/(1+a*r))+1)/2;n=1-l,ir=255&l*i.r+n*s.r+.5,ig=255&l*i.g+n*s.g+.5,ib=255&l*i.b+n*s.b+.5,ia=o*i.a+(1-o)*sa,this.rgb=i}retourner ceci}interpoler(t,e){retourner t&&(this._rgb=function(t,e,i){const s=Ut(wt(tr)),n=Ut(wt(tg)),o=Ut(wt(tb));retourner{r:Mt(Yt(s+i*(Ut(wt(er))-s))),g:Mt(Yt(n+i*(Ut(wt(eg))-n))),b:Mt(Yt(o+i*(Ut(wt(eb))-o))),a:t.a+i*(ea-ta)}}(this._rgb,t._rgb,e)),this}clone(){retour nouveau Zt(this.rgb)}alpha(t){retour this._rgb.a=Mt(t),this}clearer(t){retour this._rgb.a*=1-t,this}greyscale(){const t=this._rgb,e=_t(.3*t.r+.59*t.g+.11*tb);retour tr=tg=tb=e,this}opaquer(t){retour this._rgb.a*=1+t,this}negate(){const t=this._rgb;return tr=255-tr,tg=255-tg,tb=255-tb,this}éclaircir(t){return Xt(this._rgb,2,t),this}assombrir(t){return Xt(this._rgb,2,-t),this}saturer(t){return Xt(this._rgb,1,t),this}désaturer(t){return Xt(this._rgb,1,-t),this}roter(t){return function(t,e){var i=It(t);i[0]=Vt(i[0]+e),i=Ft(i),tr=i[0],tg=i[1],tb=i[2]}(this._rgb,t),this}}fonction Jt(t){if(t&&"object"==typeof t){const e=t.toString();return"[object CanvasPattern]"===e||"[object CanvasGradient]"===e}return!1}function Qt(t){return Jt(t)?t:new Zt(t)}function te(t){return Jt(t)?t:new Zt(t).saturate(.5).darken(.1).hexString()}const ee=["x","y","borderWidth","radius","tension"],ie=["color","borderColor","backgroundColor"];const se=new Carte;function ne(t,e,i){return function(t,e){e=e||{};const i=t+JSON.stringify(e);let s=se.get(i);return s||(s=new Intl.NumberFormat(t,e),se.set(i,s)),s}(e,i).format(t)}const oe={values:t=>n(t)?t:""+t,numeric(t,e,i){if(0===t)return"0";const s=this.chart.options.locale;let n,o=t;si(i.length>1){const e=Math.max(Math.abs(i[0].value),Math.abs(i[i.length-1].value));(e<1e-4||e>1e15)&&(n="scientific"),o=function(t,e){let i=e.length>3?e[2].value-e[1].value:e[1].value-e[0].value;Math.abs(i)>=1&&t!==Math.floor(t)&&(i=t-Math.floor(t));retour i}(t,i)}const a=z(Math.abs(o)),r=isNaN(a)?1:Math.max(Math.min(-1*Math.floor(a),20),0),l={notation:n,minimumFractionDigits:r,maximumFractionDigits:r};retour Object.assign(l,this.options.ticks.format),ne(t,s,l)},logarithmic(t,e,i){if(0===t)retour"0";const s=i[e].significand||t/Math.pow(10,Math.floor(z(t)));return[1,2,3,5,10,15].includes(s)||e>.8*i.length?oe.numeric.call(this,t,e,i):""}};var ae={formatters:oe};const re=Object.create(null),le=Object.create(null);function he(t,e){if(!e)return t;const i=e.split(".");for(let e=0,s=i.length;e<s;++e){const s=i[e];t=t[s]||(t[s]=Object.create(null))}return t}function ce(t,e,i){return"string"==typeof e?b(he(t,e),i):b(he(t,""),e)}classe de{constructeur(t,e){this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0, 0, 0, 0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=t=>t.chart.platform.getDevicePixelRatio(),this.elements={},this.events=["mousemove","mouseout","clic","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans- serif", taille:12, style:"normal", hauteur de ligne:1,2, poids:null}, this.hover={}, this.hoverBackgroundColor=(t,e)=>te(e.backgroundColor), this.hoverBorderColor=(t,e)=>te(e.borderColor), this.hoverColor=(t,e)=>te(e.color), this.indexAxis="x", this.interaction={mode:"nearest", intersect:!0,includeInvisible:!1}, this.maintainAspectRatio=!0, this.onHover=null, this.onClick=null, this.parsing=!0, this.plugins={}, this.responsive=!0, this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(t),this.apply(e)}set(t,e){retourne ce(this,t,e)}get(t){retourne he(this,t)}describe(t,e){retourne ce(le,t,e)}override(t,e){retourne ce(re,t,e)}route(t,e,i,s){const n=he(this,t),a=he(this,i),r="_"+e;Object.defineProperties(n,{[r]:{valeur:n[e],writable:!0},[e]:{énumérable:!0,get(){const t=this[r],e=a[s];retour o(t)?Object.assign({},e,t):l(t,e)},set(t){this[r]=t}}})}apply(t){t.forEach((t=>t(this)))}}var ue=new de({_scriptable:t=>!t.startsWith("on"),_indexable:t=>"events"!==t,hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}},[function(t){t.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),t.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:t=>"onProgress"!==t&&"onComplete"!==t&&"fn"!==t}),t.set("animations",{couleurs:{type:"couleur",propriétés:ie},nombres:{type:"nombre",propriétés:ee}}),t.describe("animations",{_fallback:"animation"}),t.set("transitions",{active:{animation:{durée n:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:t=>0|t}}}})},function(t){t.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})}, function(t){t.set("scale",{affichage : !0,décalage : !1,inverse : !1,beginAtZero : !1,limites : "ticks",clip : !0,grace : 0,grille : {affichage : !0,lineWidth : 1,drawOnChartArea : !0,drawTicks : !0,tickLength : 8,tickWidth : (t,e)=>e.lineWidth,tickColor : (t,e)=>e.color,décalage : !1},bordure : {affichage : !0,tiret : [],tiretOffset : 0,largeur : 1},titre : {affichage : !0,tiret : [] 1,texte : " ", rembourrage : {haut : 4, bas : 4}}, graduations : {minRotation : 0, maxRotation : 50, miroir : !1, largeur du trait de texte : 0, couleur du trait de texte : " ", rembourrage : 3, affichage : !0, saut automatique : !0, remplissage automatique du trait de texte : 3, décalage de l'étiquette : 0, rappel : ae.formatters.values, mineur : {}, majeur : {}, alignement : " centre", alignement croisé : " près", showLabelBackdrop : !1, couleur de fond : " rgba(255, 255, 255, 0, 75)", remplissage de fond : 2}}), t.route("scale.ticks","couleur","","couleur"), t.route("scale.grid","couleur","","borderColor"), t.route("échelle.border","couleur","","borderColor"), t.route("échelle.title","couleur","","couleur"), t.describe("échelle", {_fallback:!1,_scriptable:t=>!t.startsWith("avant")&&!t.startsWith("après")&&"callback"!==t&&"parser"!==t,_indexable:t=>"borderDash"!==t&&"tickBorderDash"!==t&&"dash"!==t}), t.describe("échelles", {_fallback:"échelle"}), t.describe("échelle.ticks", {_scriptable:t=>"backdropPadding"!==t&&"callback"!==t,_indexable:t=>"backdropPadding"!==t})}]);fonction fe(){return"undefined"!=typeof window&&"undefined"!=typeof document}function ge(t){let e=t.parentNode;return e&&"[object ShadowRoot]"===e.toString()&&(e=e.host),e}function pe(t,e,i){let s;return"string"==typeof t?(s=parseInt(t,10),-1!==t.indexOf(" % ")&&(s=s/100*e.parentNode[i])):s=t,s}const me=t=>t.ownerDocument.defaultView.getComputedStyle(t,null);function be(t,e){return me(t).getPropertyValue(e)}const xe=["haut","droite","bas","gauche"];function _e(t,e,i){const s={};i=i?" - "+i:"";for(let n=0;n<4;n++){const o=xe[n];s[o]=parseFloat(t[e+" - "+o+i])||0}retour s.width=s.left+s.right,s.height=s.top+s.bottom,s}const ye=(t,e,i)=>(t>0||e>0)&&(!i||!i.shadowRoot);fonction ve(t,e){si("native"in t)retour t;const{canvas:i,currentDevicePixelRatio:s}=e,n=me(i),o="border - box"===n.boxSizing,a=_e(n,"padding"),r=_e(n,"border","width"),{x:l,y:h,box:c}=function(t,e){const i=t.touches,s=i&&i.length?i[0]:t,{offsetX:n,offsetY:o}=s;let a,r,l=!1;if(ye(n,o,t.target))a=n,r=o;else{const t=e.getBoundingClientRect();a=s.clientX-t.left,r=s.clientY-t.top,l=!0}retour{x:a,y:r,box:l}}(t,i),d=a.left+(c&&r.left),u=a.top+(c&&r.top);let{width:f,height:g}=e;retour o&&(f-=a.width+r.width,g-=a.height+r.height),{x:Math.round((ld)/f*i.width/s),y:Math.round((hu)/g*i.height/s)}}const Me=t=>Math.round(10*t)/10;fonction we(t,e,i,s){const n=me(t),o=_e(n,"marge"),a=pe(n.maxWidth,t,"largeurclient")||T,r=pe(n.maxHeight,t,"hauteurclient")||T,l=function(t,e,i){let s,n;si(void 0===e||void 0===i){const o=t&&ge(t);si(o){const t=o.getBoundingClientRect(),a=me(o),r=_e(a,"bordure","largeur"),l=_e(a,"rembourrage");e=t.largeur-l.largeur-r.largeur,i=t.hauteur-l.hauteur-r.hauteur,s=pe(a.maxWidth,o,"largeurclient"),n=pe(a.maxHeight,o,"hauteurclient")}sinon e=t.clientWidth,i=t.clientHeight}retour{largeur:e,hauteur:i,largeurmax:s||T,hauteurmax:n||T}}(t,e,i);soit{largeur:h,hauteur:c}=l;si("content - box"===n.boxSizing){const t=_e(n,"border","width"),e=_e(n,"padding");h-=e.width+t.width,c-=e.height+t.height}h=Math.max(0,ho.width),c=Math.max(0,s?h/s:co.height),h=Me(Math.min(h,a,l.maxWidth)),c=Me(Math.min(c,r,l.maxHeight)),h&&!c&&(c=Me(h/2));return(void 0!==e||void 0!==i)&&s&&l.height&&c>l.height&&(c=l.height,h=Me(Math.floor(c*s))),{width:h,height:c}}fonction ke(t,e,i){const s=e||1,n=Math.floor(t.height*s),o=Math.floor(t.width*s);t.height=Math.floor(t.height),t.width=Math.floor(t.width);const a=t.canvas;retour a.style&&(i||!a.style.height&&!a.style.width)&&(a.style.height=`${t.height}px`,a.style.width=`${t.width}px`),(t.currentDevicePixelRatio!==s||a.height!==n||a.width!==o)&&(t.currentDevicePixelRatio=s,a.height=n,a.width=o,t.ctx.setTransform(s,0,0,s,0,0),!0)}const Se=function(){let t=!1;try{const e={get passive(){return t=!0,!1}};fe()&&(window.addEventListener("test",null,e),window.removeEventListener("test",null,e))}catch(t){}retour t}();fonction Pe(t,e){const i=be(t,e),s=i&&i.match(/^(\d+)(\.\d+)?px$/);retour s?+s[1]:void 0}fonction De(t){retour!t||s(t.size)||s(t.family)?null:(t.style?t.style+" ":"")+(t.weight?t.weight+" ":"")+t.size+"px "+t.family}fonction Ce(t,e,i,s,n){let o=e[n];retour o||(o=e[n]=t.measureText(n).width,i.push(n)),o>s&&(s=o),s}fonction Oe(t,e,i,s){let o=(s=s||{}).data=s.data||{},a=s.garbageCollect=s.garbageCollect||[];s.font!==e&&(o=s.data={},a=s.garbageCollect=[],s.font=e),t.save(),t.font=e;let r=0;const l=i.length;let h, c, d, u, f; pour (h = 0; h < l; h ++) si (u = i [h], null == u | | n (u)) {si (n (u)) pour (c = 0, d = u. length; c < d; c ++) f = u [c], null == f | | n (f) | | (r = Ce (t, o, a, r, f))} sinon r = Ce (t, o, a, r, u); t. restaure (); const g = a. length / 2; si (g > i. length) {pour (h = 0; h < g; h ++) supprimer o [a [h]]; a. épissure (0, g)} retour r} fonction Ae (t, e, i) {const s = t. currentDevicePixelRatio, n = 0! == i? Math. max (i / 2,. 5): 0; retour Math.round((en)*s)/s+n}fonction Te(t,e){(e||t)&&((e=e||t.getContext("2d")).save(),e.resetTransform(),e.clearRect(0,0,t.width,t.height),e.restore())}fonction Le(t,e,i,s){Ee(t,e,i,s,null)}fonction Ee(t,e,i,s,n){let o,a,r,l,h,c,d,u;const f=e.pointStyle,g=e.rotation,p=e.radius;let m=(g||0)*L;si(f&&"objet"==typeof f&&(o=f.toString(),"[objet HTMLImageElement]"===o||"[objet HTMLCanvasElement]"===o))retour t.save(), t.translate(i,s), t.rotate(m), t.drawImage(f,-f.width/2,-f.height/2,f.width,f.height),void t.restore();si(!(isNaN(p)||p<=0)){switch(t.beginPath(),f){par défaut:n?t.ellipse(i,s,n/2,p,0,0,O):t.arc(i,s,p,0,O),t.closePath();break;case"triangle":c=n?n/2:p, t.moveTo(i+Math.sin(m)*c,s-M ath.cos(m)*p),m+=I,t.lineTo(i+Math.sin(m)*c,s-Math.cos(m)*p),m+=I,t.lineTo(i+Math.sin(m)*c,s-Math.cos(m)*p),t.closePath();break;case"rectRounded":h=.516*p,l=ph,a=Math.cos(m+R)*l,d=Math.cos(m+R)*(n?n/2-h:l),r=Math.sin(m+R)*l,u=Math.sin(m+R)*(n?n/2-h:l),t.arc(id,sr,h,mC,mE),t.arc(i+u,sa,h,mE,m),t.arc(i+d,s+r,h,m,m+E),t.arc(iu,s+a,h,m+E,m+C),t.closePath();break;case"rect":if(!g){l=Math.SQRT1_2*p,c=n?n/2:l,t.rect(ic,sl,2*c,2*l);break}m+=R;case"rectRot":d=Math.cos(m)*(n?n/2:p),a= Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(id,sr),t.lineTo(i+u,sa),t.lineTo(i+d,s+r),t.lineTo(iu,s+a),t.closePath();break;case"crossRot":m+=R;case"cross":d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(id,sr),t.lineTo(i+d,s+r),t.move À(i+u,sa),t.ligneÀ(iu,s+a);pause;case"étoile":d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.déplacerVers(id,sr),t.ligneÀ(i+d,s+r),t.déplacerVers(i+u,sa),t.ligneÀ(iu,s+a),m+=R,d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.déplacerVers(id,sr), t.lineTo(i+d,s+r),t.moveTo(i+u,sa),t.lineTo(iu,s+a);pause;case"ligne":a=n?n/2:Math.cos(m)*p,r=Math.sin(m)*p,t.moveTo(ia,sr),t.lineTo(i+a,s+r);pause;case"tiret":t.moveTo(i,s),t.lineTo(i+Math.cos(m)*(n?n/2:p),s+Math.sin(m)*p);pause;case!1:t.closePath()}t.fill(),e.borderWidth>0&&t.stroke()}}fonction Re(t,e,i){retour i=i||.5,!e||t&&t.x>e.gauche-i&&t.x<e.droite+i&&t.y>e.haut-i&&t.y<e.bas+i}fonction Ie(t,e){t.save(),t.beginPath(),t.rect(e.gauche,e.haut,e.droite-e.gauche,e.bas-e.haut),t.clip()}fonction ze(t){t.restore()}fonction Fe(t,e,i,s,n){si(!e)retour t.lineTo(ix,iy);si("milieu"===n){const s=(e.x+ix)/2;t.lineTo(s,ey),t.lineTo(s,iy)}else"after"===n!=!!s?t.lineTo(ex,iy):t.lineTo(ix,ey);t.lineTo(ix,iy)}fonction Ve(t,e,i,s){si(!e)retour t.lineTo(ix,iy);t.bezierCurveTo(s?e.cp1x:e.cp2x,s?e.cp1y:e.cp2y,s?i.cp2x:i.cp1x,s?i.cp2y:i.cp1y,ix,iy)}fonction Be(t,e,i,s,n){si(n.barré||n.souligné){const o=t.measureText(s),a=eo.actualBoundingBoxLeft,r=e+o.actualBoundingBoxRight,l=io.actualBoundingBoxAscent,h=i+o.actualBoundingBoxDescent,c=n.strikethrough?(l+h)/2:h;t.strokeStyle=t.fillStyle,t.beginPath(),t.lineWidth=n.decorationWidth||2,t.moveTo(a,c),t.lineTo(r,c),t.stroke()}}fonction We(t,e){const i=t.fillStyle;t.fillStyle=e.color,t.fillRect(e.left,e.top,e.width,e.height),t.fillStyle=i}fonction Ne(t,e,i,o,a,r={}){const l=n(e)?e:[e],h=r.strokeWidth>0&&""!==r.strokeColor;let c,d;for(t.save(),t.font=a.string,function(t,e){e.translation&&t.translate(e.translation[0],e.translation[1]),s(e.rotation)||t.rotate(e.rotation),e.color&&(t.fillStyle=e.color),e.textAlign&&(t.textAlign=e.textAlign),e.textBaseline&&(t.t extBaseline=e.textBaseline)}(t,r),c=0;c<l.length;++c)d=l[c],r.backdrop&&We(t,r.backdrop),h&&(r.strokeColor&&(t.strokeStyle=r.strokeColor),s(r.strokeWidth)||(t.lineWidth=r.strokeWidth),t.strokeText(d,i,o,r.maxWidth)),t.fillText(d,i,o,r.maxWidth),Be(t,i,o,d,r),o+=Number(a.lineHeight);t.restore()}function He(t,e){const{x:i,y:s,w:n,h:o,radius:a}=e;t.arc(i+a.topLeft,s+a.topLeft,a.topLeft,1.5*C,C,!0),t.lineTo(i,s+oa.bottomLeft),t.arc(i+a.bottomLeft,s+oa.bottomLeft,a.bottomLeft,C,E,!0),t.lineTo(i+n a.basDroite,s+o),t.arc(i+na.basDroite,s+oa.basDroite,a.basDroite,E,0,!0),t.ligneVers(i+n,s+a.hautDroite),t.arc(i+na.hautDroite,s+a.hautDroite,a.hautDroite,0,-E,!0),t.ligneVers(i+a.hautGauche,s)}fonction je(t,e=[""],i,s,n=(()=>t[0])){const o=i||t;void 0===s&&(s=ti("_fallback",t));const a={[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:t,_rootScopes:o,_fallback:s,_getTarget:n,override:i=>je([i,...t],e,o,s)};return new Proxy(a,{deleteProperty:(e,i)=>(supprimer e[i],supprimer e._keys,supprimer t[0][i],!0),get:(i,s)=>qe(i,s,(()=>function(t,e,i,s){let n;for(const o de e)si(n=ti(Ue(o,t),i),void 0!==n)retourner Xe(t,n)?Je(i,s,t,n):n}(s,e,t,i))),getOwnPropertyDescriptor:(t,e)=>Reflect.getOwnPropertyDescriptor(t._scopes[0],e),getPrototypeOf:()=>Reflect.getPrototypeOf(t[0]),has:(t,e)=>ei(t).includes(e),ownKeys:t=>ei(t),set(t,e,i){const s=t._storage||(t._storage=n());retourner t[e]=s[e]=i,supprimer t._keys,!0}})}fonction $e(t,e,i,s){const a={_cacheable:!1,_proxy:t,_context:e,_subProxy:i,_stack:new Set,_descriptors:Ye(t,s),setContext:e=>$e(t,e,i,s),override:n=>$e(t.override(n),e,i,s)};return new Proxy(a,{deleteProperty:(e,i)=>(supprimer e[i],supprimer t[i],!0),get:(t,e,i)=>qe(t,e,(()=>function(t,e,i){const{_proxy:s,_context:a,_subProxy:r,_descriptors:l}=t;let h=s[e];S(h)&&l.isScriptable(e)&&(h=function(t,e,i,s){const{_proxy:n,_context:o,_subProxy:a,_stack:r}=i;if(r.has(t))throw new Error("Récursivité détectée: "+Array.from(r).join(" -> ")+" -> "+t);r.add(t);let l=e(o,a||s);r.delete(t),Xe(t,l)&&(l=Je(n._scopes,n,t,l));return l}(e,h,t,i));n(h)&&h.length&&(h=function(t,e,i,s){const{_proxy:n,_context:a,_subProxy:r,_descriptors:l}=i;if(void 0!==a.index&&s(t))retour e[a.index%e.length];si(o(e[0])){const i=e,s=n._scopes.filter((t=>t!==i));e=[];pour(const o de i){const i=Je(s,n,t,o);e.push($e(i,a,r&&r[t],l))}}retour e}(e,h,t,l.isIndexable));Xe(e,h)&&(h=$e(h,a,r&&r[e],l));retour h}(t,e,i))),getOwnPropertyDescriptor:(e,i)=>e._descriptors.allKeys?Reflect.has(t,i)?{énumérable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(t,i),getPrototypeOf:()=>Reflect.getPrototypeOf(t),has:(e,i)=>Reflect.has(t,i),ownKeys:()=>Reflect.ownKeys(t),set:(e,i,s)=>(t[i]=s,delete e[i],!0)})}function Ye(t,e={scriptable:!0,indexable:!0}){const{_scriptable:i=e.scriptable,_indexable:s=e.indexable,_allKeys:n=e.allKeys}=t;return{allKeys:n,scriptable:i,indexable:s,isScriptable:S(i)?i:()=>i,isIndexable:S(s)?s:()=>s}}const Ue=(t,e)=>t?t+w(e):e,Xe=(t,e)=>o(e)&&"adaptateurs"!==t&&(null===Object.getPrototypeOf(e)||e.constructeur===Objet);fonction qe(t,e,i){si(Object.prototype.hasOwnProperty.call(t,e)||"constructeur"===e)retour t[e];const s=i();retour t[e]=s,s}fonction Ke(t,e,i){retour S(t)?t(e,i):t}const Ge=(t,e)=>!0===t?e:"string"==typeof t?M(e,t):void 0;fonction Ze(t,e,i,s,n){pour(const o de e){const e=Ge(i,o);si(e){t.add(e);const o=Ke(e._fallback,i,n);si(void 0!==o&&o!==i&&o!==s)retour o}sinon si(!1===e&&void 0!==s&&i!==s)retourner null}retourner!1}fonction Je(t,e,i,s){const a=e._rootScopes,r=Ke(e._fallback,i,s),l=[...t,...a],h=nouvel ensemble;h.add(s);let c=Qe(h,l,i,r||i,s);retourner null!==c&&((void 0===r||r===i||(c=Qe(h,l,r,c,s),null!==c))&&je(Array.from(h),[""],a,r,(()=>function(t,e,i){const s=t._getTarget();e in s||(s[e]={});const a=s[e];si(n(a)&&o(i))retourner i;retourne une||{}}(e,i,s))))}fonction Qe(t,e,i,s,n){pour(;i;)i=Ze(t,e,i,s,n);retourne i}fonction ti(t,e){pour(const i de e){si(!i)continue;const e=i[t];si(void 0!==e)retourne e}}fonction ei(t){let e=t._keys;retourne e||(e=t._keys=fonction(t){const e=nouvel ensemble;pour(const i de t)pour(const t de Object.keys(i).filter((t=>!t.startsWith("_"))))e.add(t);retourne Array.from(e)}(t._scopes)),e}fonction ii(t,e,i,s){const{iScale:n}=t,{key:o="r"}=this._parsing,a=new Array(s);soit r,l,h,c;for(r=0,l=s;r<l;++r)h=r+i,c=e[h],a[r]={r:n.parse(M(c,o),h)};return a}const si=Number.EPSILON||1e-14,ni=(t,e)=>e<t.length&&!t[e].skip&&t[e],oi=t=>"x"===t?"y":"x";function ai(t,e,i,s){const n=t.skip?e:t,o=e,a=i.skip?e:i,r=q(o,n),l=q(a,o);soit h=r/(r+l),c=l/(r+l);h=isNaN(h)?0:h,c=isNaN(c)?0:c;const d=s*h,u=s*c;retour{précédent:{x:ox-d*(ax-nx),y:oy-d*(ay-ny)},suivant:{x:o.x+u*(ax-nx),y:o.y+u*(ay-ny)}}}fonction ri(t,e="x"){const i=oi(e),s=t.length,n=Tableau(s).fill(0),o=Tableau(s);soit a,r,l,h=ni(t,0);pour(a=0;a<s;++a)si(r=l,l=h,h=ni(t,a+1),l){si(h){const t=h[e]-l[e];n[a]=0!==t?(h[i]-l[i])/t:0}o[a]=r?h?F(n[a-1])!==F(n[a])?0:(n[a-1]+n[a])/2:n[a-1]:n[a]}!function(t,e,i){const s=t.length;soit n,o,a,r,l,h=ni(t,0);pour(soit c=0;c<s-1;++c)l=h,h=ni(t,c+1),l&&h&&(V(e[c],0,si)?i[c]=i[c+1]=0:(n=i[c]/e[c],o=i[c+1]/e[c],r=Math.pow(n,2)+Math.pow(o,2),r<=9||(a=3/Math.sqrt(r),i[c]=n*a*e[c],i[c+1]=o*a*e[c])))}(t,n,o),function(t,e,i="x"){const s=oi(i),n=t.length;let o,a,r,l=ni(t,0);for(let h=0;h<n;++h){si(a=r,r=l,l=ni(t,h+1),!r)continue;const n=r[i],c=r[s];a&&(o=(na[i])/3,r[`cp1${i}`]=no,r[`cp1${s}`]=co*e[h]),l&&(o=(l[i]-n)/3,r[`cp2${i}`]=n+o,r[`cp2${s}`]=c+o*e[h])}}(t,o,e)}fonction li(t,e,i){retour Math.max(Math.min(t,i),e)}fonction hi(t,e,i,s,n){let o,a,r,l;si(e.spanGaps&&(t=t.filter((t=>!t.skip))),"monotone"===e.cubicInterpolationMode)ri(t,n);sinon{soit i=s?t[t.length-1]:t[0];pour(o=0,a=t.length;o<a;++o)r=t[o],l=ai(i,r,t[Math.min(o+1,a-(s?0:1))%a],e.tension),r.cp1x=l.précédent.x,r.cp1y=l.précédent.y,r.cp2x=l.suivant.x,r.cp2y=l.suivant.y,i=r}e.capBezierPoints&&function(t,e){let i,s,n,o,a,r=Re(t[0],e);for(i=0,s=t.length;i<s;++i)a=o,o=r,r=i<s-1&&Re(t[i+1],e),o&&(n=t[i],a&&(n.cp1x=li(n.cp1x,e.gauche,e.droite),n.cp1y=li(n.cp1y,e.haut,e.bas)),r&&(n.cp2x=li(n.cp2x,e.gauche,e.droite),n.cp2y=li(n.cp2y,e.haut,e.bas)))}(t,i)}const ci=t=>0===t||1===t,di=(t,e,i)=>-Math.pow(2,10*(t-=1))*Math.sin((te)*O/i),ui=(t,e,i)=>Math.pow(2,-10*t)*Math.sin((te)*O/i)+1,fi={linéaire:t=>t,easeInQuad:t=>t*t,easeOutQuad:t=>-t*(t-2),easeInOutQuad:t=>(t/=.5)<1?.5*t*t:-.5*(--t*(t-2)-1),easeInCubic:t=>t*t*t,easeOutCubic:t=>(t-=1)* t*t+1,easeInOutCubic:t=>(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2),easeInQuart:t=>t*t*t*t,easeOutQuart:t=>-((t-=1)*t*t*t-1),easeInOutQuart:t=>(t/=.5)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2),easeInQuint:t=>t*t*t*t*t,easeOutQuint:t=>(t-=1)*t*t*t*t+1,easeInOutQuint:t=>(t/=.5)<1?.5*t*t*t*t*t:. 5*((t-=2)*t*t*t*t+2),easeInSine:t=>1-Math.cos(t*E),easeOutSine:t=>Math.sin(t*E),easeInOutSine:t=>-.5*(Math.cos(C*t)-1),easeInExpo:t=>0===t?0:Math.pow(2,10*(t-1)),easeOutExpo:t=>1===t?1:1-Math.pow(2,-10*t),easeInOutExpo:t=>ci(t)?t:t<.5?.5*Math.pow(2,10*(2*t-1)):.5*(2-Math.pow(2, -10*(2*t-1))),easeInCirc:t=>t>=1?t:-(Math.sqrt(1-t*t)-1),easeOutCirc:t=>Math.sqrt(1-(t-=1)*t),easeInOutCirc:t=>(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1),easeInElastic:t=>ci(t)?t:di(t,.075,.3),easeOutElastic:t=>ci(t)?t:ui(t,.075,.3),easeInOutElastic(t){const e=.1125;retour ci(t)?t:t<.5?.5*di(2*t,e,.45):.5+.5*ui(2*t-1,e,.45)},easeInBack(t){const e=1.70158;retour t*t*((e+1)*te)},easeOutBack(t){const e=1.70158;retour(t-=1)*t*((e+1)*t+e)+1},easeInOutBack(t){let e=1.70158;retour(t/=.5)<1?t*t*((1+(e*=1.525))*te)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)},easeInBounce:t=>1-fi.easeOutBounce(1-t),easeOutBounce(t){const e=7.5625,i=2.75;retour t<1/i?e*t*t:t<2/i?e*(t-=1,5/i)*t+,75:t<2,5/i?e*(t-=2,25/i)*t+,9375:e*(t-=2,625/i)*t+,984375},easeInOutBounce:t=>t<,5?,5*fi.easeInBounce(2*t):,5*fi.easeOutBounce(2*t-1)+,5};fonction gi(t,e,i,s){retour{x:t.x+i*(ex-tx),y:t.y+i*(ey-ty)}}fonction pi(t,e,i,s){retour{x:t.x+i*(ex-tx),y:"milieu"===s?i<.5?ty:ey:"après"===s?i<1?ty:ey:i>0?ey:ty}}fonction mi(t,e,i,s){const n={x:t.cp2x,y:t.cp2y},o={x:e.cp1x,y:e.cp1y},a=gi(t,n,i),r=gi(n,o,i),l=gi(o,e,i),h=gi(a,r,i),c=gi(r,l,i);retour gi(h,c,i)}const bi=/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,xi=/^(normal|italique|initial|hériter|non défini|(oblique( -?[0-9]?[0-9]deg)?))$/;function _i(t,e){const i=(""+t).match(bi);if(!i||"normal"===i[1])return 1.2*e;switch(t=+i[2],i[3]){case"px":return t;case" % ":t/=100}return e*t}const yi=t=>+t||0;function vi(t,e){const i={},s=o(e),n=s?Object.keys(e):e,a=o(t)?s?i=>l(t[i],t[e[i]]):e=>t[e]:()=>t;for(const t de n)i[t]=yi(a(t));return i}function Mi(t){return vi(t,{haut:"y",droite : "x",bas : "y",gauche : "x"})}fonction wi(t){retour vi(t,["topLeft","topRight","bottomLeft","bottomRight"])}fonction ki(t){const e=Mi(t);retour e.width=e.left+e.right,e.height=e.top+e.bottom,e}fonction Si(t,e){t=t||{},e=e||ue.font;let i=l(t.size,e.size);"string"==typeof i&&(i=parseInt(i,10));let s=l(t.style,e.style);s&&!(""+s).match(xi)&&(console.warn('Style de police non valide spécifié : "'+s+'"'),s=void 0);const n={famille:l(t.family,e.family),lineHeight:_i(l(t.lineHeight,e.lineHeight),i),size:i,style:s,weight:l(t.weight,e.weight),string:""};retour n.string=De(n),n}fonction Pi(t,e,i,s){let o,a,r,l=!0;for(o=0,a=t.length;o<a;++o)if(r=t[o],void 0!==r&&(void 0!==e&&"function"==typeof r&&(r=r(e),l=!1),void 0!==i&&n(r)&&(r=r[i%r.length],l=!1),void 0!==r))retour s&&!l&&(s.cacheable=!1),r}fonction Di(t,e,i){const{min:s,max:n}=t,o=c(e,(ns)/2),a=(t,e)=>i&&0===t?0:t+e;retour{min:a(s,-Math.abs(o)),max:a(n,o)}}fonction Ci(t,e){retour Objet.assign(Object.create(t),e)}fonction Oi(t,e,i){retour t?function(t,e){return{x:i=>t+t+ei,setWidth(t){e=t},textAlign:t=>"center"===t?t:"right"===t?"left":"droite",xPlus:(t,e)=>te,leftForLtr:(t,e)=>te}}(e,i):{x:t=>t,setWidth(t){},textAlign:t=>t,xPlus:(t,e)=>t+e,leftForLtr:(t,e)=>t}}function Ai(t,e){let i,s;"ltr"!==e&&"rtl"!==e||(i=t.canvas.style,s=[i.getPropertyValue("direction"),i.getPropertyPriority("direction")],i.setProperty("direction",e,"important"),t.prevTextDirection=s)}fonction Ti(t,e){void 0!==e&&(delete t.prevTextDirection,t.canvas.style.setProperty("direction",e[0],e[1]))}fonction Li(t){return"angle"===t?{entre:Z,comparer:K,normaliser:G}:{entre:tt,comparer:(t,e)=>te,normaliser:t=>t}}fonction Ei({début:t,fin:e,compte:i,boucle:s,style:n}){retour{début:t%i,fin:e%i,boucle:s&&(e-t+1)%i==0,style:n}}fonction Ri(t,e,i){si(!i)retour[t];const{propriété:s,début:n,fin:o}=i,a=e.length,{comparer:r,entre:l,normaliser:h}=Li(s),{début:c,fin:d,boucle:u,style:f}=fonction(t,e,i){const{propriété:s,début:n,fin:o}=i,{entre:a,normaliser:r}=Li(s),l=e.length;soit h, c, {début : d, fin : u, boucle : f} = t ; si (f) {pour (d + = l, u + = l, h = 0, c = l ; h < c & & a (r (e [d % l] [ s ] ) , n, o } ++ h) d--, u-- ; d % = l, u % = l ; retour u < d & & ( u + = l ) , {début : d, fin : u, boucle : f, style : t. style}} (t, e, i ) , g = [] ; soit p, m, b, x = ! 1, _ = null ; const y = () = > x | | l (n, b, p) & & 0 ! = = r (n, b) , v = () = > ! x | | 0 === r (o, p) | | l (o, b, p) ; pour (soit t=c,i=c;t<=d;++t)m=e[t%a],m.skip||(p=h(m[s]),p!==b&&(x=l(p,n,o),null===_&&y()&&(_=0===r(p,n)?t:i),null!==_&&v()&&(g.push(Ei({début:_,fin:t,boucle:u,compte:a,style:f})),_=null),i=t,b=p));retour null!==_&&g.push(Ei({début:_,fin:d,boucle:u,compte:a,style:f})),g}fonction Ii(t,e){const i=[],s=t.segments;for(let n=0;n<s.length;n++){const o=Ri(s[n],t.points,e);o.length&&i.push(...o)}retour i}fonction zi(t,e){const i=t.points,s=t.options.spanGaps,n=i.length;if(!n)retour[];const o=!!t._loop,{début:a,fin:r}=fonction(t,e,i,s){let n=0,o=e-1;si(i&&!s)pour(;n<e&&!t[n].skip;)n++;pour(;n<e&&t[n].skip;)n++;pour(n%=e,i&&(o+=n);o>n&&t[o%e].skip;)o--;retour o%=e,{début:n,fin:o}}(i,n,o,s);si(!0===s)retour Fi(t,[{début:a,fin:r,boucle:o}],i,e);retour Fi(t,fonction(t,e,i,s){const n=t.length,o=[];soit a,r=e,l=t[e];pour(a=e+1;a<=i;++a){const i=t[a%n];i.skip||i.stop?l.skip||(s=!1,o.push({start:e%n,end:(a-1)%n,loop:s}),e=r=i.stop?a:null):(r=a,l.skip&&(e=a)),l=i}retour null!==r&&o.push({start:e%n,end:r%n,loop:s}),o}(i,a,r<a?r+n:r,!!t._fullLoop&&0===a&&r===n-1),i,e)}fonction Fi(t,e,i,s){retour s&&s.setContext&&i?function(t,e,i,s){const n=t._chart.getContext(),o=Vi(t.options),{_datasetIndex:a,options:{spanGaps:r}}=t,l=i.length,h=[];let c=o,d=e[0].start,u=d;function f(t,e,s,n){const o=r?-1:1;if(t!==e){for(t+=l;i[t%l].skip;)t-=o;for(;i[e%l].skip;)e+=o;t%l!=e%l&&(h.push({start:t%l,end:e%l,loop:s,style:n}),c=n,d=e%l)}}for(const t de e){d=r?d:t.start;let e,o=i[d%l];for(u=d+1;u<=t.end;u++){const r=i[u%l];e=Vi(s.setContext(Ci(n,{type:"segment",p0:o,p1:r,p0DataIndex:(u-1)%l,p1DataIndex:u%l,datasetIndex:a}))),Bi(e,c)&&f(d,u-1,t.loop,c),o=r,c=e}d<u-1&&f(d,u-1,t.loop,c)}retour h}(t,e,i,s):e}fonction Vi(t){retour{backgroundColor:t.backgroundColor,borderCapStyle:t.borderCapStyle,borderDash:t.borderDash,borderDashOffset:t.borderDashOffset,borderJoinStyle:t.borderJoinStyle,borderWidth:t.borderWidth,borderColor:t.borderColor}}fonction Bi(t,e){si(!e)retour!1;const i=[],s=fonction(t,e){retour Jt(e)?(i.includes(e)||i.push(e),i.indexOf(e)):e};retour JSON.stringify(t,s)!==JSON.stringify(e,s)}var Wi=Object.freeze({__proto__:null,HALF_PI:E,INFINITY:T,PI:C,PITAU:A,QUARTER_PI:R,RAD_PER_DEG:L,TAU:O,TWO_THIRDS_PI:I,_addGrace:Di,_alignPixel:Ae,_alignStartEnd:ft,_angleBetween:Z,_angleDiff:K,_arrayUnique:lt,_attachContext:$e,_bezierCurveTo:Ve,_bezierInterpolation:mi,_boundSegment:Ri,_boundSegments:Ii,_capitalize:w,_computeSegments:zi,_createResolver:je,_decimalPlaces:U,_deprecated:function(t,e,i,s){void 0!==e&&console.warn(t+': "'+i+'" est obsolète. Veuillez utiliser "'+s+'" au lieu de')},_descripteurs:Ye,_elementsEqual:f,_factorize:W,_filterBetween:nt,_getParentNode:ge,_getStartAndCountOfVisiblePoints:pt,_int16Range:Q,_isBetween:tt,_isClickEvent:D,_isDomSupported:fe,_isPointInArea:Re,_limitValue:J,_longestText:Oe,_lookup:et,_lookupByKey:it,_measureText:Ce,_merger:m,_mergerIf:_,_normalizeAngle:G,_parseObjectDataRadialScale:ii,_pointInLine:gi,_readValueToProps:vi,_rlookupByKey:st,_scaleRangesChanged:mt,_setMinAndMaxByKey:j,_splitKey:v,_steppedInterpolation : pi, _steppedLineTo : Fe, _textX : gt, _toLeftRightCenter : ut, _updateBezierControlPoints : hi, addRoundedRectPath : He, presque égal à : V, presque entier : H, rappel : d, clearCanvas : Te, clipArea : Ie, clone : g, couleur : Qt, createContext : Ci, debounce : dt, défini : k, distanceBetweenPoints : q, drawPoint : Le, drawPointLegend : Ee, each : u, easingEffects : fi, finieOrDefault : r, fontString : function(t, e, i){return e+" "+t+"px "+i},formatNumber:ne,getAngleFromPoint:X,getHoverColor:te,getMaximumSize:we,getRelativePosition:ve,getRtlAdapter:Oi,getStyle:be,isArray:n,isFinite:a,isFunction:S,isNullOrUndef:s,isNumber:N,isObject:o,isPatternOrGradient:Jt,listenArrayEvents:at,log10:z,merge:b,mergeIf:x,niceNum:B,noop:e,overrideTextDirection:Ai,readUsedSize:Pe,renderText:Ne,requestAnimFrame:ht,resolve :Pi,resolveObjectKey:M,restoreTextDirection:Ti,retinaScale:ke,setsEqual:P,sign:F,splineCurve:ai,splineCurveMonotone:ri,supportsEventListenerOptions:Se,throttled:ct,toDegrees:Y,toDimension:c,toFont:Si,toFontString:De,toLineHeight:_i,toPadding:ki,toPercentage:h,toRadians:$,toTRBL:Mi,toTRBLCorners:wi,uid:i,unclipArea:ze,unlistenArrayEvents:rt,valueOrDefault:l});fonction Ni(t,e,i,s){const{controller:n,data:o,_sorted:a}=t,r=n._cachedMeta.iScale;if(r&&e===r.axis&&"r"!==e&&a&&o.length){const t=r._reversePixels?st:it;if(!s)return t(o,e,i);if(n._sharedOptions){const s=o[0],n="function"==typeof s.getRange&&s.getRange(e);if(n){const s=t(o,e,in),a=t(o,e,i+n);return{lo:s.lo,hi:a.hi}}}}return{lo:0,hi:o.length-1}}function Hi(t,e,i,s,n){const o=t.getSortedVisibleDatasetMetas(),a=i[e];pour(soit t=0,i=o.length;t<i;++t){const{index:i,data:r}=o[t],{lo:l,hi:h}=Ni(o[t],e,a,n);pour(soit t=l;t<=h;++t){const e=r[t];e.skip||s(e,i,t)}}}fonction ji(t,e,i,s,n){const o=[];si(!n&&!t.isPointInArea(e))retour o;retour Salut(t,i,e,(function(i,a,r){(n||Re(i,t.chartArea,0))&&i.inRange(ex,ey,s)&&o.push({element:i,datasetIndex:a,index:r})}),!0),o}function $i(t,e,i,s,n,o){let a=[];const r=function(t){const e=-1!==t.indexOf("x"),i=-1!==t.indexOf("y");return function(t,s){const n=e?Math.abs(tx-sx):0,o=i?Math.abs(ty-sy):0;return Math.sqrt(Math.pow(n,2)+Math.pow(o,2))}}(i);let l=Nombre.INFINITÉ_POSITIF;retour Hi(t,i,e,(fonction(i,h,c){const d=i.inRange(ex,ey,n);si(s&&!d)retour;const u=i.getCenterPoint(n);si(!(!!o||t.isPointInArea(u))&&!d)retour;const f=r(e,u);f<l?(a=[{élément:i,datasetIndex:h,index:c}],l=f):f===l&&a.push({élément:i,datasetIndex:h,index:c})})),a}fonction Yi(t,e,i,s,n,o){retour o||t.isPointInArea(e)?"r"!==i||s?$i(t,e,i,s,n,o):fonction(t,e,i,s){let n=[];retour Hi(t,i,e,(function(t,i,o){const{startAngle:a,endAngle:r}=t.getProps(["startAngle","endAngle"],s),{angle:l}=X(t,{x:ex,y:ey});Z(l,a,r)&&n.push({element:t,datasetIndex:i,index:o})})),n}(t,e,i,n):[]}function Ui(t,e,i,s,n){const o=[],a="x"===i?"inXRange":"inYRange";laissez r=!1;retournez Hi(t,i,e,((t,s,l)=>{t[a]&&t[a](e[i],n)&&(o.push({element:t,datasetIndex:s,index:l}),r=r||t.inRange(ex,ey,n))})),s&&!r?[]:o}var Xi={evaluateInteractionItems:Hi,modes:{index(t,e,i,s){const n=ve(e,t),o=i.axis||"x",a=i.includeInvisible||!1,r=i.intersect?ji(t,n,o,s,a):Yi(t,n,o,!1,s,a),l=[];retournez r.length?(t.getSortedVisibleDatasetMetas().forEach((t=>{const e=r[0].index,i=t.data[e];i&&!i.skip&&l.push({element:i,datasetIndex:t.index,index:e})})),l):[]},dataset(t,e,i,s){const n=ve(e,t),o=i.axis||"xy",a=i.includeInvisible||!1;let r=i.intersect?ji(t,n,o,s,a):Yi(t,n,o,!1,s,a);si(r.length>0){const e=r[0].datasetIndex,i=t.getDatasetMeta(e).data;r=[];pour(let t=0;t<i.length;++t)r.push({element:i[t],datasetIndex:e,index:t})}retour r},point:(t,e,i,s)=>ji(t,ve(e,t),i.axis||"xy",s,i.includeInvisible||!1),nearest(t,e,i,s){const n=ve(e,t),o=i.axis||"xy",a=i.includeInvisible||!1;retour Yi(t,n,o,i.intersect,s,a)},x:(t,e,i,s)=>Ui(t,ve(e,t),"x",i.intersect,s),y:(t,e,i,s)=>Ui(t,ve(e,t),"y",i.intersect,s)}};const qi=["gauche","haut","droite","bas"];fonction Ki(t,e){retour t.filter((t=>t.pos===e))}fonction Gi(t,e){retour t.filter((t=>-1===qi.indexOf(t.pos)&&t.box.axis===e))}fonction Zi(t,e){retour t.sort(((t,i)=>{const s=e?i:t,n=e?t:i;retour s.weight===n.weight?s.index-n.index:s.weight-n.weight}))}fonction Ji(t,e){const i=fonction(t){const e={};pour(const i de t){const{pile:t,pos:s,pileWeight:n}=i;si(!t||!qi.includes(s))continue;const o=e[t]||(e[t]={count:0,placed:0,weight:0,size:0});o.count++,o.weight+=n}retour e}(t),{vBoxMaxWidth:s,hBoxMaxHeight:n}=e;soit o,a,r;pour(o=0,a=t.length;o<a;++o){r=t[o];const{fullSize:a}=r.box,l=i[r.stack],h=l&&r.stackWeight/l.weight;r.horizontal?(r.width=h?h*s:a&&e.availableWidth,r.height=n):(r.width=s,r.height=h?h*n:a&&e.availableHeight)}retour i}fonction Qi(t,e,i,s){retour Math.max(t[i],e[i])+Math.max(t[s],e[s])}fonction ts(t,e){t.top=Math.max(t.top,e.top),t.left=Math.max(t.left,e.left),t.bottom=Math.max(t.bottom,e.bottom),t.right=Math.max(t.right,e.right)}fonction es(t,e,i,s){const{pos:n,box:a}=i,r=t.maxPadding;if(!o(n)){i.size&&(t[n]-=i.size);const e=s[i.stack]||{size:0,count:1};e.size=Math.max(e.size,i.horizontal?a.height:a.width),i.size=e.size/e.count,t[n]+=i.size}a.getPadding&&ts(r,a.getPadding());const l=Math.max(0,e.outerWidth-Qi(r,t,"gauche","droite")),h=Math.max(0,e.outerHeight-Qi(r,t,"haut","bas")),c=l!==tw,d=h!==th;retour tw=l,th=h,i.horizontal?{même:c,autre:d}:{même:d,autre:c}}fonction is(t,e){const i=e.maxPadding;fonction s(t){const s={gauche:0,haut:0,droite:0,bas:0};retour t.forEach((t=>{s[t]=Math.max(e[t],i[t])})),s}retour s(t?["gauche","droite"]:["haut","bas"])}fonction ss(t,e,i,s){const n=[];soit o,a,r,l,h,c;pour(o=0,a=t.length,h=0;o<a;++o){r=t[o],l=r.box,l.update(r.width||ew,r.height||eh,is(r.horizontal,e));const{même:a,autre:d}=es(e,i,r,s);h|=a&&n.length,c=c||d,l.fullSize||n.push(r)}retour h&&ss(n,e,i,s)||c}fonction ns(t,e,i,s,n){t.top=i,t.left=e,t.right=e+s,t.bottom=i+n,t.width=s,t.height=n}fonction os(t,e,i,s){const n=i.padding;let{x:o,y:a}=e;for(const r de t){const t=r.box,l=s[r.stack]||{count:1,placed:0,weight:1},h=r.stackWeight/l.weight||1;if(r.horizontal){const s=ew*h,o=l.size||t.height;k(l.start)&&(a=l.start),t.fullSize?ns(t,n.left,a,i.outerWidth-n.right-n.left,o):ns(t,e.left+l.placed,a,s,o),l.start=a,l.placed+=s,a=t.bottom}else{const s=eh*h,a=l.size||t.width;k(l.start)&&(o=l.start),t.fullSize?ns(t,o,n.top,a,i.outerHeight-n.bottom-n.top):ns(t,o,e.top+l.placed,a,s),l.start=o,l.placed+=s,o=t.right}}ex=o,ey=a}var as={addBox(t,e){t.boxes||(t.boxes=[]),e.fullSize=e.fullSize||!1,e.position=e.position||"top",e.weight=e.weight||0,e._layers=e._layers||function(){return[{z:0,draw(t){e.draw(t)}}]},t.boxes.push(e)},removeBox(t,e){const i=t.boxes?t.boxes.indexOf(e):-1;-1!==i&&t.boxes.splice(i,1)},configure(t,e,i){e.fullSize=i.fullSize,e.position=i.position,e.weight=i.weight},update(t,e,i,s){if(!t)return;const n=ki(t.options.layout.padding),o=Math.max(en.width,0),a=Math.max(in.height,0),r=function(t){const e=function(t){const e=[];let i,s,n,o,a,r;pour(i=0,s=(t||[]).length;i<s;++i)n=t[i],({position:o,options:{stack:a,stackWeight:r=1}}=n),e.push({index:i,box:n,pos:o,horizontal:n.isHorizontal(),weight:n.weight,stack:a&&o+a,stackWeight:r});retour e}(t),i=Zi(e.filter((t=>t.box.fullSize)),!0),s=Zi(Ki(e,"gauche"),!0),n=Zi(Ki(e,"droite"),o=Zi(Ki(e,"haut"),!0),a=Zi(Ki(e,"bas"),r=Gi(e,"x"),l=Gi(e,"y");return{fullSize:i,gaucheEtHaut:s.concat(o),droiteEtBas:n.concat(l).concat(a).concat(r),graphiqueArea:Ki(e,"graphiqueArea"),vertical:s.concat(n).concat(l),horizontal:o.concat(a).concat(r)}}(t.boxes),l=r.vertical,h=r.horizontal;u(t.boxes,(t=>{"function"==typeof t.beforeLayout&&t.beforeLayout()}));const c=l.reduce(((t,e)=>e.box.options&&!1===e.box.options.display?t:t+1),0)||1,d=Objet.freeze({largeur extérieure : e, hauteur extérieure : i, rembourrage : n, largeur disponible : o, hauteur disponible : a, largeur maximale de la boîte de valeur : o/2/c, hauteur maximale de la boîte de valeur : a/2}),f=Objet.assign({},n);ts(f, ki(s));const g=Objet.assign({maxPadding:f,w:o,h:a,x:n.left,y:n.top},n),p=Ji(l.concat(h),d);ss(r.fullSize,g,d,p),ss(l,g,d,p),ss(h,g,d,p)&&ss(l,g,d,p),function(t){const e=t.maxPadding;function i(i){const s=Math.max(e[i]-t[i],0);return t[i]+=s,s}t.y+=i("haut"),t.x+=i("gauche"),i("droite"),i("bas")}(g),os(r.gaucheEtHaut,g,d,p),g.x+=gw,g.y+=gh,os(r.droiteEtBas,g,d,p),t.chartArea={gauche:g.gauche,haut:g.haut,droite:g.gauche+gw,bas:g.haut+gh,hauteur:gh,largeur:gw},u(r.chartArea,(e=>{const i=e.box;Object.assign(i,t.chartArea),i.update(gw,gh,{gauche:0,haut:0,droite:0,bas:0})}))}};classe rs{acquireContext(t,e){}releaseContext(t){retour!1}addEventListener(t,e,i){}removeEventListener(t,e,i){}getDevicePixelRatio(){retour 1}getMaximumSize(t,e,i,s){retour e=Math.max(0,e||t.width),i=i||t.height,{largeur:e,hauteur:Math.max(0,s?Math.floor(e/s):i)}}isAttached(t){retour!0}updateConfig(t){}}classe ls étend rs{acquireContext(t){retour t&&t.getContext&&t.getContext("2d")||null}updateConfig(t){t.options.animation=!1}}const hs="$chartjs",cs={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},ds=t=>null===t||""===t;const us=!!Se&&{passive:!0};function fs(t,e,i){t&&t.canvas&&t.canvas.removeEventListener(e,i,us)}function gs(t,e){for(const i de t)si(i===e||i.contains(e))retour!0}fonction ps(t,e,i){const s=t.canvas,n=nouveau MutationObserver((t=>{let e=!1;for(const i de t)e=e||gs(i.addedNodes,s),e=e&&!gs(i.removedNodes,s);e&&i()}));retour n.observe(document,{childList:!0,subtree:!0}),n}fonction ms(t,e,i){const s=t.canvas,n=nouveau MutationObserver((t=>{let e=!1;for(const i de t)e=e||gs(i.removedNodes,s),e=e&&!gs(i.addedNodes,s);e&&i()}));retour n.observe(document,{childList:!0,subtree:!0}),n}const bs=nouvelle carte;let xs=0;function _s(){const t=window.devicePixelRatio;t!==xs&&(xs=t,bs.forEach(((e,i)=>{i.currentDevicePixelRatio!==t&&e()})))}function ys(t,e,i){const s=t.canvas,n=s&&ge(s);if(!n)return;const o=ct(((t,e)=>{const s=n.clientWidth;i(t,e),s<n.clientWidth&&i()}),window),a=new ResizeObserver((t=>{const e=t[0],i=e.contentRect.width,s=e.contentRect.height;0===i&&0===s||o(i,s)}));retour a.observe(n),function(t,e){bs.size||window.addEventListener("resize",_s),bs.set(t,e)}(t,o),a}fonction vs(t,e,i){i&&i.disconnect(),"resize"===e&&function(t){bs.delete(t),bs.size||window.removeEventListener("resize",_s)}(t)}fonction Ms(t,e,i){const s=t.canvas,n=ct((e=>{null!==t.ctx&&i(function(t,e){const i=cs[t.type]||t.type,{x:s,y:n}=ve(t,e);retour{type:i,chart:e,native:t,x:void 0!==s?s:null,y:void 0!==n?n:null}}(e,t))}),t);retour function(t,e,i){t&&t.addEventListener(e,i,us)}(s,e,n),n}class ws extends rs{acquireContext(t,e){const i=t&&t.getContext&&t.getContext("2d");retour i&&i.canvas===t?(function(t,e){const i=t.style,s=t.getAttribute("hauteur"),n=t.getAttribute("largeur");si(t[hs]={initial:{hauteur:s,largeur:n,style:{affichage:i.display,hauteur:i.height,largeur:i.width}}},i.display=i.display||"bloc",i.boxSizing=i.boxSizing||"bordure - boîte",ds(n)){const e=Pe(t,"largeur");void 0!==e&&(t.width=e)}si(ds(s))si(""===t.style.height)t.height=t.width/(e||2);sinon{const e=Pe(t,"hauteur");void 0!==e&&(t.height=e)}}(t,e),i):null}releaseContext(t){const e=t.canvas;si(!e[hs])retour!1;const i=e[hs].initial;["hauteur","largeur"].forEach((t=>{const n=i[t];s(n)?e.removeAttribute(t):e.setAttribute(t,n)}));const n=i.style||{};retour Objet.keys(n).forEach((t=>{e.style[t]=n[t]})),e.width=e.width,delete e[hs],!0}addEventListener(t,e,i){this.removeEventListener(t,e);const s=t.$proxies||(t.$proxies={}),n={attach:ps,detach:ms,resize:ys}[e]||Ms;s[e]=n(t,e,i)}removeEventListener(t,e){const i=t.$proxies||(t.$proxies={}),s=i[e];if(!s)return;({attach:vs,detach:vs,resize:vs}[e]||fs)(t,e,s),i[e]=void 0}getDevicePixelRatio(){retour window.devicePixelRatio}getMaximumSize(t,e,i,s){retour we(t,e,i,s)}isAttached(t){const e=t&&ge(t);retour!(!e||!e.isConnected)}}function ks(t){retour!fe()||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas?ls:ws}var Ss=Object.freeze({__proto__:null,BasePlatform:rs,BasicPlatform:ls,DomPlatform:ws,_detectPlatform:ks});const Ps="transparent",Ds={booléen:(t,e,i)=>i>.5?e:t,couleur(t,e,i){const s=Qt(t||Ps),n=s.valid&&Qt(e||Ps);retour n&&n.valid?n.mix(s,i).hexString():e},nombre:(t,e,i)=>t+(et)*i};classe Cs{constructeur(t,e,i,s){const n=e[i];s=Pi([t.to,s,n,t.from]);const o=Pi([t.from,n,s]);this._active=!0,this._fn=t.fn||Ds[t.type||typeof o],this._easing=fi[t.easing]||fi.linear,this._start=Math.floor(Date.now()+(t.delay||0)),this._duration=this._total=Math.floor(t.duration),this._loop=!!t.loop,this._target=e,this._prop=i,this._from=o,this._to=s,this._promises=void 0}active(){retour this._active}update(t,e,i){si(this._active){this._notify(!1);const s=this._target[this._prop],n=i-this._start,o=this._duration-n;this._start=i,this._duration=Math.floor(Math.max(o,t.duration)),this._total+=n,this._loop=!!t.loop,this._to=Pi([t.to,e,s,t.from]),this._from=Pi([t.from,s,e])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(t){const e=t-this._start,i=this._duration,s=this._prop,n=this._from,o=this._loop,a=this._to;let r;si(this._active=n!==a&&(o||e<i),!this._active)retourner this._target[s]=a,void this._notify(!0);e<0?this._target[s]=n:(r=e/i%2,r=o&&r>1?2-r:r,r=this._easing(Math.min(1,Math.max(0,r))),this._target[s]=this._fn(n,a,r))}wait(){const t=this._promises||(this._promises=[]);retourner une nouvelle promesse(((e,i)=>{t.push({res:e,rej:i})}))}_notify(t){const e=t?"res":"rej",i=this._promises||[];pour(let t=0;t<i.length;t++)i[t][e]()}}classe Os{constructeur(t,e){this._chart=t,this._properties=nouvelle carte,this.configure(e)}configure(t){si(!o(t))retour;const e=Objet.keys(ue.animation),i=this._properties;Objet.getOwnPropertyNames(t).forEach((s=>{const a=t[s];si(!o(a))retour;const r={};for(const t de e)r[t]=a[t];(n(a.properties)&&a.properties||[s]).forEach((t=>{t!==s&&i.has(t)||i.set(t,r)}))})}_animateOptions(t,e){const i=e.options,s=function(t,e){if(!e)retour;let i=t.options;if(!i)retour void(t.options=e);i.$shared&&(t.options=i=Object.assign({},i,{$shared:!1,$animations:{}}));retour i}(t,i);si(!s)retour[];const n=this._createAnimations(s,i);retour i.$shared&&function(t,e){const i=[],s=Object.keys(e);for(let e=0;e<s.length;e++){const n=t[s[e]];n&&n.active()&&i.push(n.wait())}return Promise.all(i)}(t.options.$animations,i).then((()=>{t.options=i}),(()=>{})),n}_createAnimations(t,e){const i=this._properties,s=[],n=t.$animations||(t.$animations={}),o=Object.keys(e),a=Date.now();let r;for(r=o.length-1;r>=0;--r){const l=o[r];si("$"===l.charAt(0))continue;si("options"===l){s.push(...this._animateOptions(t,e));continue}const h=e[l];let c=n[l];const d=i.get(l);si(c){si(d&&c.active()){c.update(d,h,a);continue}c.cancel()}d&&d.duration?(n[l]=c=new Cs(d,t,l,h),s.push(c)):t[l]=h}retour s}update(t,e){si(0===this._properties.size)retour void Object.assign(t,e);const i=this._createAnimations(t,e);retour i.length?(xt.add(this._chart,i),!0):void 0}}fonction As(t,e){const i=t&&t.options||{},s=i.reverse,n=void 0===i.min?e:0,o=void 0===i.max?e:0;retour{début:s?o:n,fin:s?n:o}}fonction Ts(t,e){const i=[],s=t._getSortedDatasetMetas(e);let n,o;pour(n=0,o=s.length;n<o;++n)i.push(s[n].index);retour i}fonction Ls(t,e,i,s={}){const n=t.keys,o="single"===s.mode;let r, l, h, c; si (null!==e) {pour (r=0, l=n. length; r<l; ++r) {si (h=+n[r], h===i) {si (s. all) continue; break} c=t. value[h], a(c)&&(o|| 0===e|| F(e)===F(c))&&(e+=c)} renvoie e}} fonction Es(t, e) {const i=t&&t. options. stacked; renvoie i|| void 0===i&&void 0!==e. stack} fonction Rs(t, e, i) {const s=t[e]|| (t[e]={}); renvoie s[i]|| (s[i]={})} fonction Is(t, e, i, s) {pour (const n de e.getMatchingVisibleMetas(s).reverse()){const e=t[n.index];si(i&&e>0||!i&&e<0)retourner n.index}retourner null}fonction zs(t,e){const{chart:i,_cachedMeta:s}=t,n=i._stacks||(i._stacks={}),{iScale:o,vScale:a,index:r}=s,l=o.axis,h=a.axis,c=function(t,e,i){return`${t.id}.${e.id}.${i.stack||i.type}`}(o,a,s),d=e.length;soit u;pour(soit t=0;t<d;++t){const i=e[t],{[l]:o,[h]:d}=i;u=(i._stacks||(i._stacks={}))[h]=Rs(n,c,o),u[r]=d,u._top=Est(u,a,!0,s.type),u._bottom=Est(u,a,!1,s.type);(u._visualValues||(u._visualValues={}))[r]=d}}fonction Fs(t,e){const i=t.scales;retour Objet.keys(i).filter((t=>i[t].axis===e)).shift()}fonction Vs(t,e){const i=t.controller.index,s=t.vScale&&t.vScale.axis;si(s){e=e||t._parsed;pour(const t de e){const e=t._stacks;if(!e||void 0===e[s]||void 0===e[s][i])return;supprimer e[s][i],void 0!==e[s]._visualValues&&void 0!==e[s]._visualValues[i]&&supprimer e[s]._visualValues[i]}}}const Bs=t=>"reset"===t||"none"===t,Ws=(t,e)=>e?t:Object.assign({},t);class Ns{static defaults={};static datasetElementType=null;static dataElementType=null;constructor(t,e){this.chart=t,this._ctx=t.ctx,this.index=e,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}initialize(){const t=this._cachedMeta;this.configure(),this.linkScales(),t._stacked=Es(t.vScale,t),this.addElements(),this.options.fill&&!this.chart.isPluginEnabled("filler")&&console.warn("J'ai essayé d'utiliser l'option 'fill' sans le plugin 'Filler' activé. Veuillez importer et enregistrer le plugin 'Filler' et vous assurer qu'il n'est pas désactivé dans les options")}updateIndex(t){this.index!==t&&Vs(this._cachedMeta),this.index=t}linkScales(){const t=this.chart,e=this._cachedMeta,i=this.getDataset(),s=(t,e,i,s)=>"x"===t?e:"r"===t?s:i,n=e.xAxisID=l(i.xAxisID,Fs(t,"x")),o=e.yAxisID=l(i.yAxisID,Fs(t,"y")),a=e.rAxisID=l(i.rAxisID,Fs(t,"r")),r=e.indexAxis,h=e.iAx isID=s(r,n,o,a),c=e.vAxisID=s(r,o,n,a);e.xScale=this.getScaleForId(n),e.yScale=this.getScaleForId(o),e.rScale=this.getScaleForId(a),e.iScale=this.getScaleForId(h),e.vScale=this.getScale ForId(c)}getDataset(){retour ceci.chart.data.datasets[this.index]}getMeta(){retournez ceci.chart.getDatasetMeta(this.index)}getScaleForId(t){retournez ceci.chart.scales[t]}_getOtherScale(t){const e=this._cachedMeta;retournez t===e.iScale?e.vScale:e.iScale}reset(){this._update("reset")}_destroy(){const t=this._cachedMeta;this._data&&rt(this._data,this),t._stacked&&Vs(t)}_dataCheck(){const t=this.getDataset(),e=t.data||(t.data=[]),i=this._data;si(o(e)){const t=this._cachedMeta;this._data=function(t,e){const{iScale:i,vScale:s}=e,n="x"===i.axis?"x":"y",o="x"===s.axis?"x":"y",a=Object.keys(t),r=new Array(a.length);let l,h,c;for(l=0,h=a.length;l<h;++l)c=a[l],r[l]={[n]:c,[o]:t[c]};return r}(e,t)}else if(i!==e){if(i){rt(i,this);const t=this._cachedMeta;Vs(t),t._parsed=[]}e&&Object.isExtensible(e)&&at(e,this),this._syncList=[],this._data=e}}addElements(){const t=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(t.dataset=nouveau this.datasetElementType)}buildOrUpdateElements(t){const e=this._cachedMeta,i=this.getDataset();let s=!1;this._dataCheck();const n=e._stacked;e._stacked=Es(e.vScale,e),e.stack!==i.stack&&(s=!0,Vs(e),e.stack=i.stack),this._resyncElements(t),(s||n!==e._stacked)&&(zs(this,e._parsed),e._stacked=Es(e.vScale,e))}configure(){const t=this.chart.config,e=t.datasetScopeKeys(this._type),i=t.getOptionScopes(this.getDataset(),e,!0);this.options=t.createResolver(i,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(t,e){const{_cachedMeta:i,_data:s}=this,{iScale:a,_stacked:r}=i,l=a.axis;let h, c, d, u = 0 === t & & e === s. length | | i._sorted, f = t > 0 & & i._parsed [t-1] ; si (! 1 === this._parsing) i._parsed = s, i._sorted = ! 0, d = s ; sinon {d = n (s [t]) ? this.parseArrayData (i, s, t, e) : o (s [t]) ? this.parseObjectData (i, s, t, e) : this.parsePrimitiveData (i, s, t, e) ; const a=()=>null===c[l]||f&&c[l]<f[l];for(h=0;h<e;++h)i._parsed[h+t]=c=d[h],u&&(a()&&(u=!1),f=c);i._sorted=u}r&&zs(this,d)}parsePrimitiveData(t,e,i,s){const{iScale:n,vScale:o}=t,a=n.axis,r=o.axis,l=n.getLabels(),h=n===o,c=new Array(s);let d,u,f;for(d=0,u=s;d<u;++d)f=d+i,c[d]={[a]:h||n.parse(l[f],f),[r]:o.parse(e[f],f)};return c}parseArrayData(t,e,i,s){const{xScale:n,yScale:o}=t,a=nouveau tableau(x);soit r,l,h,c;pour(r=0,l=s;r<l;++r)h=r+i,c=e[h],a[r]={x:n.parse(c[0],h),y:o.parse(c[1],h)};retourner a}parseObjectData(t,e,i,s){const{xScale:n,yScale:o}=t,{xAxisKey:a="x",yAxisKey:r="y"}=this._parsing,l=nouveau tableau(x);soit h, c, d, u; pour (h = 0, c = s; h < c; ++ h) d = h + i, u = e [ d], l [h] = { x: n. parse ( M (u, a), d), y: o. parse ( M (u, r), d)}; retour l} getParsed ( t) {retourne this. _cachedMeta. _parsed [ t]} getDataElement ( t) {retourne this. _cachedMeta. data [ t]} applyStack ( t, e, i) { const s = this. chart, n = this. _cachedMeta, o = e [ t. axis]; retour Ls ( { clés : Ts ( s,! 0), valeurs : e. _stacks [ t. axis ]. _visualValues}, o, n. index, { mode : i})} updateRangeFromParsed ( t, e, i, s) { const n=i[e.axis];let o=null===n?NaN:n;const a=s&&i._stacks[e.axis];s&&a&&(s.values=a,o=Ls(s,n,this._cachedMeta.index)),t.min=Math.min(t.min,o),t.max=Math.max(t.max,o)}getMinMax(t,e){const i=this._cachedMeta,s=i._parsed,n=i._sorted&&t===i.iScale,o=s.length,r=this._getOtherScale(t),l=((t,e,i)=>t&&!e.hidden&&e._stacked&&{keys:Ts(i,!0),values:null})(e,i,this.chart),h={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:c,max:d}=function(t){const{min:e,max:i,minDefined:s,maxDefined:n}=t.getUserBounds();return{min:s?e:Number.NEGATIVE_INFINITY,max:n?i:Number.POSITIVE_INFINITY}}(r);soit u,f;function g(){f=s[u];const e=f[r.axis];retour!a(f[t.axis])||c>e||d<e}pour(u=0;u<o&&(g()||(this.updateRangeFromParsed(h,t,f,l),!n));++u);si(n)pour(u=o-1;u>=0;--u)si(!g()){this.updateRangeFromParsed(h,t,f,l);break}retour h}getAllParsedValues(t){const e=this._cachedMeta._parsed,i=[];let s,n,o;pour(s=0,n=e.length;s<n;++s)o=e[s][t.axis],a(o)&&i.push(o);retour i}getMaxOverflow(){return!1}getLabelAndValue(t){const e=this._cachedMeta,i=e.iScale,s=e.vScale,n=this.getParsed(t);return{étiquette:i?""+i.getLabelForValue(n[i.axis]):"",valeur:s?""+s.getLabelForValue(n[s.axis]):""}}_update(t){const e=this._cachedMeta;this.update(t||"default"),e._clip=function(t){let e,i,s,n;return o(t)?(e=t.top,i=t.droite, s = t. bas, n = t. gauche): e = i = s = n = t, {haut: e, droite: i, bas: s, gauche: n, désactivé:! 1 === t}} (l (this. options. clip, fonction (t, e, i) {si (! 1 === i) retour! 1; const s = Comme (t, i), n = Comme (e, i); retour {haut: n. fin, droite: s. fin, bas: n. début, gauche: s. début}} (e. x Scale, e. y Scale, this. getMax Overflow ()))} mise à jour (t) {} dessiner () {const t=this._ctx,e=this.chart,i=this._cachedMeta,s=i.data||[],n=e.chartArea,o=[],a=this._drawStart||0,r=this._drawCount||s.length-a,l=this.options.drawActiveElementsOnTop;let h;for(i.dataset&&i.dataset.draw(t,n,a,r),h=a;h<a+r;++h){const e=s[h];e.hidden||(e.active&&l?o.push(e):e.draw(t,n))}for(h=0;h<o.length;++h)o[h].draw(t,n)}getStyle(t,e){const i=e?"active":"default";return void 0===t&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(i):this.resolveDataElementOptions(t||0,i)}getContext(t,e,i){const s=this.getDataset();let n;si(t>=0&&t<this._cachedMeta.data.length){const e=this._cachedMeta.data[t];n=e.$context||(e.$context=function(t,e,i){return Ci(t,{active:!1,dataIndex:e,analysé:void 0,raw:void 0, élément : i, index : e, mode : « par défaut », type : « données »})}(this. getContext(), t, e)), n. parsed = this. getParsed(t), n. raw = s. data[t], n. index = n. dataIndex = t} sinon n = this. $context||(this. $context=function(t, e){retour Ci(t, {actif : !1, ensemble de données : void 0, ensemble de données Index : e, index : e, mode : « par défaut », type : « ensemble de données »})}(this. chart. getContext(), this. index)), n. dataset= s, n. index = n. datasetIndex = this. index ; retour n. active=!!e, n. mode=i, n} resolveDatasetElementOptions(t){retour ceci._resolveElementOptions(this.datasetElementType.id,t)}resolveDataElementOptions(t,e){retour ceci._resolveElementOptions(this.dataElementType.id,e,t)}_resolveElementOptions(t,e="par défaut",i){const s="actif"===e,n=this._cachedDataOpts,o=t+"-"+e,a=n[o],r=this.enableOptionSharing&&k(i);si(a)retour Ws(a,r);const l=this.chart.config,h=l.datasetElementScopeKeys(this._type,t),c=s?[`${t}Hover`,"hover",t,""]:[t,""],d=l.getOptionScopes(this.getDataset(),h),u=Object.keys(ue.elements[t]),f=l.resolveNamedOptions(d,u,(()=>this.getgetDataset();let n;si(t>=0&&t<this._cachedMeta.data.length){const e=this._cachedMeta.data[t];n=e.$context||(e.$context=function(t,e,i){retour Ci(t,{actif:!1,dataIndex:e,analysé:void 0,raw:void 0,élément:i,index:e,mode:"par défaut",type:"données"})}(this.getContext(),t,e)),n.parsed=this.getParsed(t),n.raw=s.data[t],n.index=n.dataIndex=t}sinon n=this.$context||(this.$context=function(t,e){retour Ci(t,{actif:!1,dataset:void 0, datasetIndex:e, index:e, mode:"par défaut", type:"dataset"})}(this.chart.getContext(),this.index)),n.dataset=s,n.index=n.datasetIndex=this.index;retour n.active=!!e,n.mode=i,n}resolveDatasetElementOptions(t){retourner this._resolveElementOptions(this.datasetElementType.id,t)}resolveDataElementOptions(t,e){retourner this._resolveElementOptions(this.dataElementType.id,e,t)}_resolveElementOptions(t,e="par défaut",i){const s="active"===e,n=this._cachedDataOpts,o=t+"-"+e,a=n[o],r=this.enableOptionSharing&&k(i);si(a)retourner Ws(a,r);const l=this.chart.config,h=l.datasetElementScopeKeys(this._type,t),c=s?[`${t}Hover`,"hover",t,""]:[t,""],d=l.getOptionScopes(this.getDataset(),h),u=Object.keys(ue.elements[t]),f=l.resolveNamedOptions(d,u,(()=>this.getgetDataset();let n;si(t>=0&&t<this._cachedMeta.data.length){const e=this._cachedMeta.data[t];n=e.$context||(e.$context=function(t,e,i){retour Ci(t,{actif:!1,dataIndex:e,analysé:void 0,raw:void 0,élément:i,index:e,mode:"par défaut",type:"données"})}(this.getContext(),t,e)),n.parsed=this.getParsed(t),n.raw=s.data[t],n.index=n.dataIndex=t}sinon n=this.$context||(this.$context=function(t,e){retour Ci(t,{actif:!1,dataset:void 0, datasetIndex:e, index:e, mode:"par défaut", type:"dataset"})}(this.chart.getContext(),this.index)),n.dataset=s,n.index=n.datasetIndex=this.index;retour n.active=!!e,n.mode=i,n}resolveDatasetElementOptions(t){retourner this._resolveElementOptions(this.datasetElementType.id,t)}resolveDataElementOptions(t,e){retourner this._resolveElementOptions(this.dataElementType.id,e,t)}_resolveElementOptions(t,e="par défaut",i){const s="active"===e,n=this._cachedDataOpts,o=t+"-"+e,a=n[o],r=this.enableOptionSharing&&k(i);si(a)retourner Ws(a,r);const l=this.chart.config,h=l.datasetElementScopeKeys(this._type,t),c=s?[`${t}Hover`,"hover",t,""]:[t,""],d=l.getOptionScopes(this.getDataset(),h),u=Object.keys(ue.elements[t]),f=l.resolveNamedOptions(d,u,(()=>this.getContexte(i,s,e)),c);retour f.$shared&&(f.$shared=r,n[o]=Object.freeze(Ws(f,r))),f}_resolveAnimations(t,e,i){const s=this.chart,n=this._cachedDataOpts,o=`animation-${e}`,a=n[o];si(a)retour a;let r;si(!1!==s.options.animation){const s=this.chart.config,n=s.datasetAnimationScopeKeys(this._type,e),o=s.getOptionScopes(this.getDataset(),n);r=s.createResolver(o,this.getContext(t,i,e))}const l=nouveau Os(s,r&&r.animations);retour r&&r._cacheable&&(n[o]=Object.freeze(l)),l}getSharedOptions(t){si(t.$shared)retourner ceci._sharedOptions||(ceci._sharedOptions=Object.assign({},t))}includeOptions(t,e){retourner!e||Bs(t)||ceci.chart._animationsDisabled}_getSharedOptions(t,e){const i=ceci.resolveDataElementOptions(t,e),s=ceci._sharedOptions,n=ceci.getSharedOptions(i),o=ceci.includeOptions(e,n)||n!==s;retourner ceci.updateSharedOptions(n,e,i),{sharedOptions:n,includeOptions:o}}updateElement(t,e,i,s){Bs(s)?Object.assign(t,i):this._resolveAnimations(e,s).update(t,i)}updateSharedOptions(t,e,i){t&&!Bs(e)&&this._resolveAnimations(void 0,e).update(t,i)}_setStyle(t,e,i,s){t.active=s;const n=this.getStyle(e,s);this._resolveAnimations(e,i,s).update(t,{options:!s&&this.getSharedOptions(n)||n})}removeHoverStyle(t,e,i){this._setStyle(t,i,"actif",!1)}setHoverStyle(t,e,i){this._setStyle(t,i,"actif",!0)}_removeDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,"actif",!1)}_setDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,"actif",!0)}_resyncElements(t){const e=this._data,i=this._cachedMeta.data;for(const[t,e,i]of this._syncList)this[t](e,i);this._syncList=[];const s=i.length,n=e.length,o=Math.min(n,s);o&&this.parse(0,o),n>s?this._insertElements(s,ns,t):n<s&&this._removeElements(n,sn)}_insertElements(t,e,i=!0){const s=this._cachedMeta,n=s.data,o=t+e;soit a;const r=t=>{pour(t.length+=e,a=t.length-1;a>=o;a--)t[a]=t[ae]};pour(r(n),a=t;a<o;++a)n[a]=nouveau this.dataElementType;this._parsing&&r(s._parsed),this.parse(t,e),i&&this.updateElements(n,t,e,"reset")}updateElements(t,e,i,s){}_removeElements(t,e){const i=this._cachedMeta;si(this._parsing){const s=i._parsed.splice(t,e);i._stacked&&Vs(i,s)}i.data.splice(t,e)}_sync(t){si(this._parsing)this._syncList.push(t);sinon{const[e,i,s]=t;this[e](i,s)}this.chart._dataChanges.push([this.index,...t])}_onDataPush(){const t=arguments.length;this._sync(["_insertElements",this.getDataset().data.length-t,t])}_onDataPop(){this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync(["_removeElements",0,1])}_onDataSplice(t,e){e&&this._sync(["_removeElements",t,e]);const i=arguments.length-2;i&&this._sync(["_insertElements",t,i])}_onDataUnshift(){this._sync(["_insertElements",0,arguments.longueur])}}classe Hs{paramètres par défaut statiques={};paramètres par défaut statiquesRoutes=void 0;x;y;active=!1;options;$animations;tooltipPosition(t){const{x:e,y:i}=this.getProps(["x","y"],t);retour{x:e,y:i}}hasValue(){retour N(this.x)&&N(this.y)}getProps(t,e){const i=this.$animations;si(!e||!i)retourner ceci;const s={};retourner t.forEach((t=>{s[t]=i[t]&&i[t].active()?i[t]._to:this[t]})),s}}fonction js(t,e){const i=t.options.ticks,n=fonction(t){const e=t.options.offset,i=t._tickSize(),s=t._length/i+(e?0:1),n=t._maxLength/i;retour Math.floor(Math.min(s,n))}(t),o=Math.min(i.maxTicksLimit||n,n),a=i.major.enabled?function(t){const e=[];let i,s;for(i=0,s=t.length;i<s;i++)t[i].major&&e.push(i);retour e}(e):[],r=a.length,l=a[0],h=a[r-1],c=[];si(r>o)retour function(t,e,i,s){let n,o=0,a=i[0];pour(s=Math.ceil(s),n=0;n<t.length;n++)n===a&&(e.push(t[n]),o++,a=i[o*s])}(e,c,a,r/o),c;const d=function(t,e,i){const s=function(t){const e=t.length;soit i,s;si(e<2)retour!1;pour(s=t[0],i=1;i<e;++i)si(t[i]-t[i-1]!==s)retour!1;retour s}(t),n=e.length/i;si(!s)retour Math.max(n,1);const o=W(s);pour(soit t=0,e=o.length-1;t<e;t++){const e=o[t];si(e>n)retour e}retour Math.max(n,1)}(a,e,o);si(r>0){soit t,i;const n=r>1?Math.round((hl)/(r-1)):null;pour($s(e,c,d,s(n)?0:ln,l),t=0,i=r-1;t<i;t++)$s(e,c,d,a[t],a[t+1]);retour $s(e,c,d,h,s(n)?e.length:h+n),c}retour $s(e,c,d),c}fonction $s(t,e,i,s,n){const o=l(s,0),a=Math.min(l(n,t.length),t.length);soit r,h,c,d=0;pour(i=Math.ceil(i),n&&(r=ns,i=r/Math.floor(r/i)),c=o;c<0;)d++,c=Math.round(o+d*i);pour(h=Math.max(o,0);h<a;h++)h===c&&(e.push(t[h]),d++,c=Math.round(o+d*i))}const Ys=(t,e,i)=>"haut"===e||"gauche"===e?t[e]+i:t[e]-i,Us=(t,e)=>Math.min(e||t,t);fonction Xs(t,e){const i=[],s=t.length/e,n=t.length;soit o=0;for(;o<n;o+=s)i.push(t[Math.floor(o)]);retour i}fonction qs(t,e,i){const s=t.ticks.length,n=Math.min(e,s-1),o=t._startPixel,a=t._endPixel,r=1e-6;let l,h=t.getPixelForTick(n);si(!(i&&(l=1===s?Math.max(ho,ah):0===e?(t.getPixelForTick(1)-h)/2:(ht.getPixelForTick(n-1))/2,h+=n<e?l:-l,h<or||h>a+r)))retour h}fonction Ks(t){retour t.drawTicks?t.tickLength:0}fonction Gs(t,e){si(!t.display)retourne 0;const i=Si(t.font,e),s=ki(t.padding);retourne(n(t.text)?t.text.length:1)*i.lineHeight+s.height}fonction Zs(t,e,i){let s=ut(t);retourne(i&&"droite"!==e||!i&&"droite"===e)&&(s=(t=>"gauche"===t?"droite":"droite"===t?"gauche":t)(s)),s}classe Js étend Hs{constructeur(t){super(),this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={gauche:0,droite:0,haut:0,bas:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(t){this.options=t.setContext(this.getContext()),this.axis=t.axis,this._userMin=this.parse(t.min),this._userMax=this.parse(t.max),this._suggestedMin=this.parse(t.suggestedMin),this._suggestedMax=this.parse(t.suggestedMax)}parse(t,e){retour t}getUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:i,_suggestedMax:s}=ceci;retour t=r(t,Nombre.INFINITÉ_POSITIF),e=r(e,Nombre.INFINITÉ_NÉGATIVE),i=r(i,Nombre.INFINITÉ_POSITIF),s=r(s,Nombre.INFINITÉ_NÉGATIVE),{min:r(t,i),max:r(e,s),minDefined:a(t),maxDefined:a(e)}}getMinMax(t){let e,{min:i,max:s,minDefined:n,maxDefined:o}=this.getUserBounds();if(n&&o)return{min:i,max:s};const a=this.getMatchingVisibleMetas();for(let r=0,l=a.length;r<l;++r)e=a[r].controller.getMinMax(this,t),n||(i=Math.min(i,e.min)),o||(s=Math.max(s,e.max));retour i=o&&i>s?s:i,s=n&&i>s?i:s,{min:r(i,r(s,i)),max:r(s,r(i,s))}}getPadding(){retour{gauche:this.paddingLeft||0,haut:this.paddingTop||0,droite:this.paddingRight||0,bas:this.paddingBottom||0}}getTicks(){retour this.ticks}getLabels(){const t=this.chart.data;retour ceci.options.étiquettes||(ceci.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}getLabelItems(t=this.chart.chartArea){retour ceci._labelItems||(this._labelItems=this._computeLabelItems(t))}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){d(this.options.beforeUpdate,[this])}update(t,e,i){const{beginAtZero:s,grace:n,ticks:o}=this.options,a=o.sampleSize;this.beforeUpdate(),this.maxWidth=t,this.maxHeight=e,this._margins=i=Object.assign({gauche:0,droite:0,haut:0,bas:0},i),this.ticks=null,this._labelSizes=null,this._gridLineItems= null, this._labelItems=null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength= this.isHorizontal()? this.width+i.left+i.right: this.height+i.top+i.bottom, this._dataLimitsCached||(this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range=Di(this,n,s), this._dataLimitsCached=!0), this.beforeBuildTicks(), this.ticks= this.buildTicks()||[], this.afterBuildTicks();const r=a<this.ticks.length;this._convertTicksToLabels(r?Xs(this.ticks,a):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),o.display&&(o.autoSkip||"auto"===o.source)&&(this.ticks=js(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),r&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let t,e,i=this.options.reverse;this.isHorizontal()?(t=this.left,e=this.right):(t=this.top,e=this.bottom,i=!i),this._startPixel=t,this._endPixel=e,this._reversePixels=i,this._length=et,this._alignToPixels=this.options.alignToPixels}afterUpdate(){d(this.options.afterUpdate,[this] )}beforeSetDimensions(){d(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddi ngRight=0,this.paddingBottom=0}afterSetDimensions(){d(this.options.afterSetDimensions,[this])}_callHooks(t){this.chart.notifyPlugins(t,this.getContext()),d(this.options[t],[this])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits( ){this._callHooks("afterDataLimits")}avantBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}aprèsBuildTicks(){this._callHooks("afterBuildTicks")}avantTickToLabelConversion(){d(this.options.beforeTickToLabelConversion,[this])}générerTickLabels(t){const t=this.options.ticks;soit i,s,n;pour(i=0,s=t.length;i<s;i++)n=t[i],n.label=d(e.callback,[n.value,i,t],this)}afterTickToLabelConversion(){d(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){d(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const t=this.options,e=t.ticks,i=Us(this.ticks.length,t.ticks.maxTicksLimit),s=e.minRotation||0,n=e.maxRotation;soit o,a,r,l=s;si(!this._isVisible()||!e.display||s>=n||i<=1||!this.isHorizontal())retour void(this.labelRotation=s);const h=this._getLabelSizes(),c=h.largeur.la.plus.large,d=h.hauteur.la.plus.haute,u=J(this.chart.width-c,0,this.maxWidth);o=t.offset?this.maxWidth/i:u/(i-1),c+6>o&&(o=u/(i-(t.offset?.5:1)),a=this.maxHeight-Ks(t.grid)-e.padding-Gs(t.title,this.chart.options.font),r=Math.sqrt(c*c+d*d),l=Y(Math.min(Math.asin (J((h.plus haut.hauteur+6)/o,-1,1)),Math.asin(J(a/r,-1,1))-Math.asin(J(d/r,-1,1)))),l=Math.max(s,Math.min(n,l))),this.labelRotation=l}afterCalculateLabelRotation(){d(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){d(this.options.beforeFit,[this])}fit(){const t={width:0,height:0},{chart:e,options:{ticks:i,title:s,grid:n}}=this,o=this._isVisible(),a=this.isHorizontal();si(o){const o=Gs(s,e.options.font);si(a?(t.width=this.maxWidth,t.height=Ks(n)+o):(t.height=this.maxHeight,t.width=Ks(n)+o),i.display&&this.ticks.length){const{first:e,last:s,widest:n,highest:o}=this._getLabelSizes(),r=2*i.padding,l=$(this.labelRotation),h=Math.cos(l),c=Math.sin(l);si(a){const e=i.mirror?0:c*n.width+h*o.height;t.height=Math.min(this.maxHeight,t.height+e+r)}else{const e=i.mirror?0:h*n.width+c*o.height;t.width=Math.min(this.maxWidth,t.width+e+r)}this._calculatePadding(e,s,c,h)}}this._handleMargins(),a?(this.width=this._length=e.width-this._margins.left-this._margins.right,this.height=t.height):(this.width=t.width,this.height=this._length=e.height-this._margins.top-this._margins.bottom)}_calculatePadding(t,e,i,s){const{ticks:{align:n,padding:o},position:a}=this.options,r=0!==this.labelRotation,l="top"!==a&&"x"===this.axis;if(this.isHorizontal()){const a=this.getPixelForTick(0)-this.left,h=this.right-this.getPixelForTick(this.ticks.length-1);soit c=0,d=0;r?l?(c=s*t.width,d=i*e.height):(c=i*t.height,d=s*e.width):"début"===n?d=e.width:"fin"===n?c=t.width:"intérieur"!==n&&(c=t.width/2,d=e.width/2),this.paddingLeft=Math.max((c-a+o)*this.width/(this.width-a),0),this.paddingRight=Math.max((d-h+o)*this.width/(this.width-h),0)}else{let i=e.height/2,s=t.height/2;"start"===n?(i=0,s=t.height):"end"===n&&(i=e.height,s=0),this.paddingTop=i+o,this.paddingBottom=s+o}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),thi s._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){d(this.options.afterFit,[this])}isHorizontal(){const{axis:t,position:e}=this.options;return"top"===e||"bottom"===e||"x"===t}isFullSize(){return this.options.fullSize}_convertTicksToLabels(t){let e,i;for(this.beforeTickToLabelConversion(),this.generateTickLabels(t),e=0,i=t.length;e<i;e++)s(t[e].label)&&(t.splice(e,1),i--,e--);this.afterTickToLabelConversion()}_getLabelSizes(){let t=this._labelSizes;if(!t){const e=this.options.ticks.sampleSize;let i=this.ticks;e<i.length&&(i=Xs(i,e)),this._labelSizes=t=this._computeLabelSizes(i,i.length,this.options.ticks.maxTicksLimit)}retour t}_computeLabelSizes(t,e,i){const{ctx:o,_longestTextCache:a}=this,r=[],l=[],h=Math.floor(e/Us(e,i));soit c, d, f, g, p, m, b, x, _, y, v, M = 0, w = 0; pour (c = 0; c < e; c + = h) {si (g = t [c]. label, p = this. _ resolve TickFontOptions (c), o. font = m = p. string, b = a [m] = a [m] | | {données: {}, gc: []}, x = p. lineHeight, _ = y = 0, s (g) | | n (g)) {si (n (g)) pour (d = 0, f = g. length; d < f; ++ d) v = g [d], s (v) | | n (v) | | (_ = Ce (o, b. data, b. gc, _, v), y + = x)} sinon _=Ce(o,b.data,b.gc,_,g),y=x;r.push(_),l.push(y),M=Math.max(_,M),w=Math.max(y,w)}!function(t,e){u(t,(t=>{const i=t.gc,s=i.length/2;let n;si(s>e){pour(n=0;n<s;++n)supprimer t.data[i[n]];i.splice(0,s)}}))}(a,e);const k=r.indexOf(M),S=l.indexOf(w),P=t=>({largeur:r[t]||0,hauteur:l[t]||0});retour{premier:P(0),dernier:P(e-1),le plus large:P(k),le plus haut:P(S),largeurs:r,hauteurs:l}}getLabelForValue(t){retour t}getPixelForValue(t,e){retour NaN}getValueForPixel(t){}getPixelForTick(t){const e=this.ticks;retour t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getPixelForDecimal(t){this._reversePixels&&(t=1-t);const e=this._startPixel+t*this._length;retourner Q(this._alignToPixels?Ae(this.chart,e,0):e)}getDecimalForPixel(t){const e=(t-this._startPixel)/this._length;retourner ceci._reversePixels?1-e:e}getBasePixel(){retourner this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:t,max:e}=this;retourner t<0&&e<0?e:t>0&&e>0?t:0}getContext(t){const e=this.ticks||[];si(t>=0&&t<e.length){const i=e[t];retourner i.$context||(i.$context=function(t,e,i){retourner Ci(t,{tick:i,index:e,type:"tick"})}(this.getContext(),t,i))}retourner ceci.$context||(ceci.$context=Ci(ceci.chart.getContext(),{échelle:ceci,type:"échelle"}))}_tickSize(){const t=ceci.options.ticks,e=$(ceci.labelRotation),i=Math.abs(Math.cos(e)),s=Math.abs(Math.sin(e)),n=ceci._getLabelSizes(),o=t.autoSkipPadding||0,a=n?n.widest.width+o:0,r=n?n.highest.height+o:0;retour ceci.isHorizontal()?r*i>a*s?a/i:r/s:r*s<a*i?r/i:a/s}_isVisible(){const t=this.options.display;retour"auto"!==t?!!t:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(t){const e=this.axis,i=this.chart,s=this.options,{grid:n,position:a,border:r}=s,h=n.offset,c=this.isHorizontal(),d=this.ticks.length+(h?1:0),u=Ks(n),f=[],g=r.setContext(this.getContext()),p=g.display?g.width:0,m=p/2,b=function(t){retour Ae(i,t,p)};let x,_,y,v,M,w,k,S,P,D,C,O;si("haut"===a)x=b(ceci.bas),w=ceci.bas-u,S=xm,D=b(t.haut)+m,O=t.bas;sinon si("bas"===a)x=b(ceci.haut),D=t.haut,O=b(t.bas)-m,w=x+m,S=ceci.haut+u;sinon si("gauche"===a)x=b(ceci.droite),M=ceci.droite-u,k=xm,P=b(t.gauche)+m,C=t.droite;sinon si("droite"===a)x=b(ceci.gauche),P=t.gauche,C=b(t.droite)-m,M=x+m,k=ceci.gauche+u;sinon si("x"===e){si("centre"===a)x=b((t.haut+t.bas)/2+.5);sinon si(o(a)){const t=Object.keys(a)[0],e=a[t];x=b(this.chart.scales[t].getPixelForValue(e))}D=t.haut,O=t.bas,w=x+m,S=w+u}sinon si("y"===e){si("centre"===a)x=b((t.gauche+t.droite)/2);sinon si(o(a)){const t=Object.keys(a)[0],e=a[t];x=b(this.chart.scales[t].getPixelForValue(e))}M=xm,k=Mu,P=t.gauche,C=t.droite}const A=l(s.ticks.maxTicksLimit,d),T=Math.max(1,Math.ceil(d/A));for(_=0;_<d;_+=T){const t=this.getContext(_),e=n.setContext(t),s=r.setContext(t),o=e.lineWidth,a=e.color,l=s.dash||[],d=s.dashOffset,u=e.tickWidth,g=e.tickColor,p=e.tickBorderDash||[],m=e.tickBorderDashOffset;y=qs(this,_,h),void 0!==y&&(v=Ae(i,y,o),c?M=k=P=C=v:w=S=D=O=v,f.push({tx1:M,ty1:w,tx2:k,ty2:S,x1:P,y1:D,x2:C,y2:O,width:o,color:a,borderDash:l,borderDashOffset:d,tickWidth:u,tickColor:g,tickBorderDash:p,tickBorderDashOffset:m}))}retourne this._ticksLength=d,this._borderValue=x,f}_computeLabelItems(t){const e=cet.axe,i=cet.options,{position:s,ticks:a}=i,r=cet.isHorizontal(),l=cet.ticks,{align:h,crossAlign:c,padding:d,mirror:u}=a,f=Ks(i.grid),g=f+d,p=u?-d:g,m=-$(cet.labelRotation),b=[];let x,_,y,v,M,w,k,S,P,D,C,O,A="milieu";si("haut"===s)w=cet.bas-p,k=cet._getXAxisLabelAlignment();sinon si("bas"===s)w=cet.haut+p,k=cet._getXAxisLabelAlignment();sinon si("gauche"===s){const t=this._getYAxisLabelAlignment(f);k=t.textAlign,M=tx}sinon si("droite"===s){const t=this._getYAxisLabelAlignment(f);k=t.textAlign,M=tx}sinon si("x"===e){si("centre"===s)w=(t.haut+t.bas)/2+g;sinon si(o(s)){const t=Object.keys(s)[0],e=s[t];w=this.chart.scales[t].getPixelForValue(e)+g}k=this._getXAxisLabelAlignment()}sinon si("y"===e){si("centre"===s)M=(t.gauche+t.droite)/2-g;sinon si(o(s)){const t=Object.keys(s)[0],e=s[t];M=this.chart.scales[t].getPixelForValue(e)}k=this._getYAxisLabelAlignment(f).textAlign}"y"===e&&("start"===h?A="top":"end"===h&&(A="bottom"));const T=this._getLabelSizes();for(x=0,_=l.length;x<_;++x){y=l[x],v=y.label;const t=a.setContext(this.getContext(x));S=this.getPixelForTick(x)+a.labelOffset,P=this._resolveTickFontOptions(x),D=P.lineHeight,C=n(v)?v.length:1;const e=C/2,i=t.color,o=t.textStrokeColor,h=t.textStrokeWidth;soit d,f=k;si(r?(M=S,"inner"===k&&(f=x===_-1?this.options.reverse?"left":"right":0===x?this.options.reverse?"right":"left":"center"),O="top"===s?"near"===c||0!==m?-C*D+D/2:"center"===c?-T.highest.height/2-e*D+D: -T.la.hauteur.la.plus.haute+D/2:"près"===c||0!==m?D/2:"centre"===c?T.la.hauteur.la.plus.haute/2-e*D:T.la.hauteur.la.plus.haute-C*D,u&&(O*=-1),0===m||t.showLabelBackdrop||(M+=D/2*Math.sin(m))):(w=S,O=(1-C)*D/2),t.showLabelBackdrop){const e=ki(t.backdropPadding),i=T.heights[x],s=T.widths[x];let n=Oe.top,o=0-e.left;switch(A){case"middle":n-=i/2;break;case"bottom":n-=i}switch(k){case"center":o-=s/2;break;case"right":o-=s;break;case"inner":x===_-1?o-=s:x>0&&(o-=s/2)}d={gauche:o,haut:n,largeur:s+e.width,hauteur:i+e.height,couleur:t.backdropColor}}b.push({label:v,police:P,textOffset:O,options:{rotation:m,couleur:i,strokeColor:o,strokeWidth:h,textAlign:f,textBaseline:A,traduction:[M,w],backdrop:d}})}retour b}_getXAxisLabelAlignment(){const{position:t,ticks:e}=this.options;si(-$(this.labelRotation))retour"haut"===t?"gauche":"droite";let i="centre";retour"début"===e.align?i="gauche":"fin"===e.align?i="droite":"intérieur"===e.align&&(i="intérieur"),i}_getYAxisLabelAlignment(t){const{position:e,ticks:{crossAlign:i,mirror:s,padding:n}}=this.options,o=t+n,a=this._getLabelSizes().widest.width;let r, l; retour"gauche"===e? s? (l=this. right+n,"near"===i? r="left":"center"===i? (r="center", l+=a/2): (r="right", l+=a)): (l=this. right-o,"near"===i? r="right":"center"===i? (r="center", l-=a/2): (r="left", l=this. left)): "right"===e? s? (l=this. left+n,"near"===i? r="right":"center"===i? (r="center", l-=a/2): (r="left", l-=a)): (l=this. left+o,"near"===i? r="left":"centre"===i?(r="centre",l+=a/2):(r="droite",l=this.droite)):r="droite",{textAlign:r,x:l}}_computeLabelArea(){if(this.options.ticks.mirror)return;const t=this.chart,e=this.options.position;return"gauche"===e||"droite"===e?{haut:0,gauche:this.gauche,bas:t.hauteur,droite:this.droite}:"haut"===e||"bas"===e?{haut:this.haut,gauche:0,bas:this.bas,droite:t.largeur}:void 0}drawBackground(){const{ctx:t,options:{backgroundColor:e},left:i,top:s,width:n,height:o}=ceci;e&&(t.save(),t.fillStyle=e,t.fillRect(i,s,n,o),t.restore())}getLineWidthForValue(t){const e=ceci.options.grid;si(!this._isVisible()||!e.display)retourne 0;const i=ceci.ticks.findIndex((e=>e.value===t));si(i>=0){retourne e.setContext(this.getContext(i)).lineWidth}retourne 0}drawGrid(t){const e=this.options.grid,i=this.ctx,s=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t));let n,o;const a=(t,e,s)=>{s.width&&s.color&&(i.save(),i.lineWidth=s.width,i.strokeStyle=s.color,i.setLineDash(s.borderDash||[]),i.lineDashOffset=s.borderDashOffset,i.beginPath(),i.moveTo(tx,ty),i.lineTo(ex,ey),i.stroke(),i.restore())};si(e.display)pour(n=0,o=s.length;n<o;++n){const t=s[n];e.drawOnChartArea&&a({x:t.x1,y:t.y1},{x:t.x2,y:t.y2},t),e.drawTicks&&a({x:t.tx1,y:t.ty1},{x:t.tx2,y:t.ty2},{color:t.tickColor,width:t.tickWidth,borderDash:t.tickBorderDash,borderDashOffset:t.tickBorderDashOffset})}}drawBorder(){const{chart:t,ctx:e,options:{border:i,grid:s}}=this,n=i.setContext(this.getContext()),o=i.display?n.width:0;if(!o)return;const a=s.setContext(this.getContext(0)).lineWidth,r=this._borderValue;soit l,h,c,d;this.isHorizontal()?(l=Ae(t,this.left,o)-o/2,h=Ae(t,this.right,a)+a/2,c=d=r):(c=Ae(t,this.top,o)-o/2,d=Ae(t,this.bottom,a)+a/2,l=h=r),e.save(),e.lineWidth=n.width,e.strokeStyle=n.color,e.beginPath(),e.moveTo(l,c),e.lineTo(h,d),e.stroke(),e.restore()}drawLabels(t){if(!this.options.ticks.display)return;const e=this.ctx,i=this._computeLabelArea();i&&Ie(e,i);const s=this.getLabelItems(t);pour(const t de s){const i=t.options,s=t.font;Ne(e,t.label,0,t.textOffset,s,i)}i&&ze(e)}drawTitle(){const{ctx:t,options:{position:e,title:i,reverse:s}}=this;si(!i.display)retour;const a=Si(i.font),r=ki(i.padding),l=i.align;let h=a.lineHeight/2;"bottom"===e||"center"===e||o(e)?(h+=r.bottom,n(i.text)&&(h+=a.lineHeight*(i.text.length-1))):h+=r.top;const{titleX:c,titleY:d,maxWidth:u,rotation:f}=function(t,e,i,s){const{top:n,left:a,bottom:r,right:l,chart:h}=t,{chartArea:c,scales:d}=h;let u,f,g,p=0;const m=rn,b=la;si(t.isHorizontal()){si(f=ft(s,a,l),o(i)){const t=Object.keys(i)[0],s=i[t];g=d[t].getPixelForValue(s)+me}else g="center"===i?(c.bottom+c.top)/2+me:Ys(t,i,e);u=la}else{if(o(i)){const t=Object.keys(i)[0],s=i[t];f=d[t].getPixelForValue(s)-b+e}else f="center"===i?(c.left+c.right)/2-b+e:Ys(t,i,e);g=ft(s,r,n),p="left"===i?-E:E}retour{titreX:f,titreY:g,largeurmax:u,rotation:p}}(ceci,h,e,l);Ne(t,i.texte,0,0,a,{couleur:i.color,largeurmax:u,rotation:f,alignementdutexte:Zs(l,e,s),lignedebasedutexte:"milieu",traduction:[c,d]})}dessiner(t){ceci._isVisible()&&(ceci.drawBackground(),ceci.drawGrid(t),ceci.drawBorder(),ceci.drawTitle(),ceci.drawLabels(t))}_layers(){const t=ceci.options,e=t.ticks&&t.ticks.z||0,i=l(t.grid&&t.grid.z,-1),s=l(t.border&&t.border.z,0);retour ceci._isVisible()&&ce.draw===Js.prototype.draw?[{z:i,draw:t=>{ce.drawBackground(),this.drawGrid(t),this.drawTitle()}},{z:s,draw:()=>{ce.drawBorder()}},{z:e,draw:t=>{ce.drawLabels(t)}}]:[{z:e,draw:t=>{ce.draw(t)}}]}getMatchingVisibleMetas(t){const e=ce.chart.getSortedVisibleDatasetMetas(),i=ce.axis+"AxisID",s=[];let n,o;for(n=0,o=e.length;n<o;++n){const o=e[n];o[i]!==ce.id||t&&o.type!==t||s.push(o)}retour s}_resolveTickFontOptions(t){retour Si(this.options.ticks.setContext(this.getContext(t)).font)}_maxDigits(){const t=this._resolveTickFontOptions(0).lineHeight;retour(this.isHorizontal()?this.width:this.height)/t}}classe Qs{constructeur(t,e,i){this.type=t,this.scope=e,this.override=i,this.items=Object.create(null)}isForType(t){retour Objet.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}register(t){const e=Object.getPrototypeOf(t);let i;(fonction(t){retour"id"dans t&&"defaults"dans t})(e)&&(i=this.register(e));const s=this.items,n=t.id,o=this.scope+"."+n;si(!n)throw new Error("la classe n'a pas d'identifiant : "+t);retourne n dans s||(s[n]=t,function(t,e,i){const s=b(Object.create(null),[i?ue.get(i):{},ue.get(e),t.defaults]);ue.set(e,s),t.defaultRoutes&&function(t,e){Object.keys(e).forEach((i=>{const s=i.split("."),n=s.pop(),o=[t].concat(s).join("."),a=e[i].split("."),r=a.pop(),l=a.join(".");ue.route(o,n,l,r)}))}(e,t.defaultRoutes);t.descriptors&&ue.describe(e,t.descriptors)}(t,o,i),this.override&&ue.override(t.id,t.overrides)),o}get(t){retourne this.items[t]}unregister(t){const e=this.items,i=t.id,s=this.scope;i dans e&&supprimer e[i],s&&i dans ue[s]&&(supprimer ue[s][i],this.override&&supprimer re[i])}}classe tn{constructor(){this.controllers=nouveau Qs(Ns,"datasets",!0),this.elements=nouveau Qs(Hs,"elements"),this.plugins=nouveau Qs(Object,"plugins"),this.scales=nouveau Qs(Js,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...t){this._each("register",t)}remove(...t){this._each("unregister",t)}addControllers(...t){this._each("register",t,this.controllers)}addElements(...t){this._each("register",t,this.elements)}addPlugins(...t){this._each("register",t,this.plugins)}addScales(...t){this._each("register",t,this.scales)}getController(t){return this._get(t,this.controllers,"contrôleur")}getElement(t){retourne this._get(t,this.elements,"élément")}getPlugin(t){retourne this._get(t,this.plugins,"plugin")}getScale(t){retourne this._get(t,this.scales,"échelle")}removeControllers(...t){this._each("unregister",t,this.controllers)}removeElements(...t){this._each("unregister",t,this.elements)}removePlugins(...t){this._each("unregister",t,this.plugins)}removeScales(...t){this._each("unregister",t,this.scales)}_each(t,e,i){[...e].forEach((e=>{const s=i||this._getRegistryForType(e);i||s.isForType(e)||s===this.plugins&&e.id?this._exec(t,s,e):u(e,(e=>{const s=i||this._getRegistryForType(e);this._exec(t,s,e)}))})}_exec(t,e,i){const s=w(t);d(i["avant"+s],[],i),e[t](i),d(i["après"+s],[],i)}_getRegistryForType(t){for(let e=0;e<this._typedRegistries.length;e++){const i=this._typedRegistries[e];if(i.isForType(t))return i}return this.plugins}_get(t,e,i){const s=e.get(t);if(void 0===s)throw new Error('"'+t+'" n'est pas un ' + i + "."); return s}}var en = new tn; class sn { constructor() { this._init = [] } notify(t, e, i, s) { "beforeInit" === e && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install")); const n = s ? this._descriptors(t).filter(s) : this._descriptors(t), o = this._notify(n, t, e, i); return "afterDestroy" === e && (this._notify(n, t, "stop"), this._notify(this._init, t, "uninstall")), o } _notify(t, e, i, s) { s = s || {}; for (const n of t) { const t = n.plugin; if (!1 === d(t[i], [e, s, n.options], t) && s.cancelable) return !1 } return !0 } invalidate() { s(this._cache) || (this._oldCache = this._cache, this._cache = void 0) } _descriptors(t) { if (this._cache) return this._cache; const e = this._cache = this._createDescriptors(t);retourne this._notifyStateChanges(t), e } _createDescriptors(t, e) { const i = t && t.config, s = l(i.options && i.options.plugins, {}), n = function (t) { const e = {}, i = [], s = Object.keys(en.plugins.items); pour(soit t = 0; t < s.length; t++) i.push(en.getPlugin(s[t])); const n = t.plugins || []; pour(soit t = 0; t < n.length; t++) { const s = n[t]; -1 === i.indexOf(s) && (i.push(s), e[s.id] = !0) }retour{ plugins: i, localIds: e } }(i); retour!1 !== s || e ? fonction(t, { plugins: e, localIds: i }, s, n){ const o = [], a = t.getContext(); pour(const r de e) { const e = r.id, l = nn(s[e], n); null !== l && o.push({ plugin: r, options: on(t.config, { plugin: r, local: i[e] }, l, a) }) }retour o }(t, n, s, e): []}_notifyStateChanges(t){ const e = this._oldCache || [], i = this._cache, s = (t, e) => t.filter((t => !e.some((e => t.plugin.id === e.plugin.id)))); this._notify(s(e, i), t, "stop"), this._notify(s(i, e), t, "start") }}fonction nn(t, e){retour e || !1 !== t ? !0 === t ? {} : t : null }fonction on(t, { plugin: e, local: i }, s, n){ const o = t.pluginScopeKeys(e), a = t.getOptionScopes(s, o);retour i && e.defaults && a.push(e.defaults), t.createResolver(a, n, [""], { scriptable: !1, indexable: !1, allKeys: !0 }) }fonction an(t, e){ const i = ue.datasets[t] || {}; return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || i.indexAxis || "x" } function rn(t) { if ("x" === t || "y" === t || "r" === t) return t } function ln(t, ...e) { if (rn(t)) return t; for (const s of e) { const e = s.axis || ("top" === (i = s.position) || "bottom" === i ? "x" : "left" === i || "right" === i ? "y" : void 0) || t.length > 1 && rn(t[0].toLowerCase()); if (e) return e } var i; throw new Error(`Impossible de déterminer le type de l'axe '${t}'. Veuillez fournir 'axis' ou 'position' option.`) } function hn(t, e, i) { if (i[e + "AxisID"] === t) return { axis: e } } function cn(t, e) { const i = re[t.type] || { scales: {} }, s = e.scales || {}, n = an(t.type, e), a = Object.create(null); return Object.keys(s).forEach((e => { const r = s[e]; if (!o(r)) return console.error(`Configuration d'échelle non valide pour l'échelle : ${e}`); if (r._proxy) return console.warn(`Ignorer le résolveur transmis en tant qu'options pour l'échelle : ${e}`); const l = ln(e, r, function (t, e) { if (e.data && e.data.datasets) { const i = e.data.datasets.filter((e => e.xAxisID === t || e.yAxisID === t)); si(i.length)retour hn(t, "x", i[0]) || hn(t, "y", i[0]) }retour{ } }(e, t), ue.scales[r.type]), h = function (t, e) {retour t === e ? "_index_" : "_value_" }(l, n), c = i.scales || {}; a[e] = x(Object.create(null), [{ axis: l }, r, c[l], c[h]]) })), t.data.datasets.forEach((i => { const n = i.type || t.type, o = i.indexAxis || an(n, e), r = (re[n] || {}).scales || {}; Object.keys(r).forEach((t => { const e = function (t, e) { let i = t; return "_index_" === t ? i = e : "_value_" === t && (i = "x" === e ? "y" : "x"), i }(t, o), n = i[e + "AxisID"] || e; a[n] = a[n] || Object.create(null), x(a[n], [{ axis: e }, s[n], r[t]]) })) })), Object.keys(a).forEach((t => { const e = a[t]; x(e, [ue.scales[e.type], ue.scale]) })), a } function dn(t) { const e = t.options || (t.options = {}); e.plugins = l(e.plugins, {}), e.scales = cn(t, e) }fonction un(t){ return (t = t || {}).datasets = t.datasets || [], t.labels = t.labels || [], t } const fn = nouvelle carte, gn = nouvel ensemble;fonction pn(t, e){ let i = fn.get(t); return i || (i = e(), fn.set(t, i), gn.add(i)), i } const mn = (t, e, i) => { const s = M(e, i); void 0 !== s && t.add(s) };classe bn{ constructor(t){ this._config = function (t) { return (t = t || {}).data = un(t.data), dn(t), t }(t), this._scopeCache = new Map, this._resolverCache = new Map }obtenir la plateforme(){retourner this._config.platform }obtenir le type(){retourner this._config.type }définir le type(t){ this._config.type = t }obtenir les données(){retourner this._config.data }définir les données(t){ this._config.data = un(t) }obtenir les options(){retourner this._config.options }définir les options(t){ this._config.options = t }obtenir les plugins(){retourner this._config.plugins }mise à jour(){ const t = this._config; this.clearCache(), dn(t) } clearCache(){ this._scopeCache.clear(), this._resolverCache.clear() } datasetScopeKeys(t){retour pn(t, (() => [[`ensembles de données.${t}`, ""]])) } datasetAnimationScopeKeys(t, e){retour pn(`${t}.transition.${e}`, (() => [[`ensembles de données.${t}.transitions.${e}`, `transitions.${e}`], [`ensembles de données.${t}`, ""]])) } datasetElementScopeKeys(t, e){retour pn(`${t}-${e}`, (() => [[`ensembles de données.${t}.éléments.${e}`, `ensembles de données.${t}`, `éléments.${e}`, ""]])) } pluginScopeKeys(t){ const e = t.id;retour pn(`${this.type}-plugin-${e}`, (() => [[`plugins.${e}`, ...t.additionalOptionScopes || []]])) } _cachedScopes(t, e){ const i = this._scopeCache; let s = i.get(t);retour s && !e || (s = nouveau Carte, i.set(t, s)), s } getOptionScopes(t, e, i){ const { options: s, type: n } = this, o = this._cachedScopes(t, i), a = o.get(e); si(a)retourne a; const r = nouvel ensemble; e.forEach((e => { t && (r.add(t), e.forEach((e => mn(r, t, e)))), e.forEach((t => mn(r, s, t))), e.forEach((t => mn(r, re[n] || {}, t))), e.forEach((t => mn(r, ue, t))), e.forEach((t => mn(r, le, t))) })); const l = Array.from(r);retour 0 === l.length && l.push(Object.create(null)), gn.has(e) && o.set(e, l), l } chartOptionScopes(){ const { options: t, type: e } = this; return [t, re[e] || {}, ue.datasets[e] || {}, { type: e }, ue, le] } resolveNamedOptions(t, e, i, s = [""]){ const o = { $shared: !0 }, { resolver: a, subPrefixes: r } = xn(this._resolverCache, t, s); let l = a; if (function (t, e) { const { isScriptable: i, isIndexable: s } = Ye(t); for (const o de e) { const e = i(o), a = s(o), r = (a || e) && t[o]; si(e && (S(r) || _n(r)) || a && n(r))retour!0 }retour!1 } (a, e)) { o.$shared = !1; l = $e(a, i = S(i) ? i() : i, this.createResolver(t, i, r)) } pour(const t de e) o[t] = l[t];retour o } createResolver(t, e, i = [""], s){ const { resolver: n } = xn(this._resolverCache, t, i);retour o(e) ? $e(n, e, void 0, s) : n }}fonction xn(t, e, i){ let s = t.get(e); s || (s = nouveau Carte, t.set(e, s)); const n = i.join(); let o = s.get(n); if (!o) { o = { résolveur: je(e, i), subPrefixes: i.filter((t => !t.toLowerCase().inclus(" hover "))}, s.set(n, o) } renvoie o } const _ n = t => o(t) & & Object.getOwnPropertyNames(t).some((e => S(t[e]))); const yn = [" haut ", " bas ", " gauche ", " droite ", " chartArea "]; function vn(t, e) { renvoie " haut " === t | | " bas " === t | | -1 === yn.indexOf(t) & & " x " === e } function Mn(t, e) { renvoie function (i, s) { renvoie i[t] === s[t] ? i[e] - s[e] : i[t] - s[t] } }fonction wn(t){ const e = t.chart, i = e.options.animation; e.notifyPlugins("afterRender"), d(i && i.onComplete, [t], e) }fonction kn(t){ const e = t.chart, i = e.options.animation; d(i && i.onProgress, [t], e) }fonction Sn(t){retour fe() && "string" == typeof t ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t } const Pn = {}, Dn = t => { const e = Sn(t);retour Objet.valeurs(Pn).filtre((t => t.canvas === e)).pop() }; fonction Cn(t, e, i) { const s = Objet.clés(t); pour(const n de s) { const s = + n; si(s > = e) { const o = t[n]; supprimer t[n], (i > 0 | | s > e) & & (t[s + i] = o) } }} fonction On(t, e, i) { retourner t.options.clip ? t[i] : e[i] } classe An { valeurs par défaut statiques = ue; instances statiques = Pn; overrides statiques = re; registre statique = fr; version statique = "4.4.5"; getChart statique = Dn; registre statique(...t) { en.add(...t), Tn() } unregister statique(...t) { en.remove(...t), Tn() } constructeur(t, e) { const s = this.config = nouveau bn(e), n = Sn(t), o = Dn(n); if (o) throw new Error("Le canevas est déjà utilisé. Le graphique avec l'ID '" + o.id + "' doit être détruit avant que le canevas avec l'ID '" + o.canvas.id + "' puisse être réutilisé."); const a = s.createResolver(s.chartOptionScopes(), this.getContext()); this.platform = new (s.platform || ks(n)), this.platform.updateConfig(s); const r = this.platform.acquireContext(n, a.aspectRatio), l = r && r.canvas, h = l && l.height, c = l && l.width; this.id = i(), this.ctx = r, this.canvas = l, this.width = c, this.height = h, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new sn, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = dt((t => this.update(t)), a.resizeDelay || 0), this._dataChanges = [], Pn[this.id] = this, r && l ? (xt.listen(this, "complete", wn), xt.listen(this, "progress", kn), this._initialize(), this.attached && this.update()) : console.error("Échec de la création du graphique : impossible d'acquérir le contexte à partir de l'élément donné") }get aspectRatio(){ const { options: { aspectRatio: t, maintainAspectRatio: e }, width: i, height: n, _aspectRatio: o } = this;retour s(t) ? e && o ? o : n ? i / n : null : t }obtenir des données(){retourner this.config.data }définir des données(t){ this.config.data = t }obtenir des options(){retourner this._options }définir des options(t){ this.config.options = t }obtenir le registre(){retourner fr } _initialize(){retourner this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : ke(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this } clear(){retourner Te(this.canvas, this.ctx), this } arrêter(){retourner xt.stop(ceci), ceci } resize(t, e){ xt.running(ceci) ? ceci._resizeBeforeDraw = { largeur: t, hauteur: e } : ceci._resize(t, e) } _resize(t, e){ const i = ceci.options, s = ceci.canvas, n = i.maintainAspectRatio && ceci.aspectRatio, o = ceci.platform.getMaximumSize(s, t, e, n), a = i.devicePixelRatio || ceci.platform.getDevicePixelRatio(), r = ceci.largeur ? "resize" : "attach"; ceci.largeur = o.largeur, ceci.hauteur = o.hauteur, ceci._aspe ctRatio = ceci.aspectRatio, ke(ceci, a, !0) && (ceci.notifyPlugins("resize", { size: o }), d(i.onResize, [ceci, o], ceci), ceci.attached && ceci._doResize(r) && ceci.render()) } ensureScalesHaveIDs(){ u(ceci.options.scales || {}, ((t, e) => { t.id = e })) } buildOrUpdateScales(){ const t = this.options, e = t.scales, i = this.scales, s = Object.keys(i).reduce(((t, e) => (t[e] = !1, t)), {}); let n = []; e && (n = n.concat(Object.keys(e).map((t => { const i = e[t], s = ln(t, i), n = "r" === s, o = "x" === s; return { options: i, dposition: n ? "chartArea" : o ? "bottom" : "gauche", dtype: n ? "radialLinear" : o ? "category" : "linéaire" } })))), u(n, (e => { const n = e.options, o = n.id, a = ln(o, n), r = l(n.type, e.dtype); void 0 !== n.position && vn(n.position, a) === vn(e.dposition) || (n.position = e.dposition), s[o] = !0; let h = null; if (o in i && i[o].type === r) h = i[o]; else { h = new (en.getScale(r))({ id: o, type: r, ctx: this.ctx, chart: this }), i[h.id] = h } h.init(n, t) })), u(s, ((t, e) => { t || delete i[e] })), u(i, (t => { as.configure(this, t, t.options), as.addBox(this, t) })) } _updateMetasets(){ const t = this._metasets, e = this.data.datasets.length, i = t.length; if (t.sort(((t, e) => t.index - e.index)), i > e) { for (let t = e; t < i; ++t)this._destroyDatasetMeta(t); t.splice(e, ie) } this._sortedMetasets = t.slice(0).sort(Mn("order", "index")) } _removeUnreferencedMetasets(){ const { _metasets: t, data: { datasets: e } } = this; t.length > e.length && delete this._stacks, t.forEach(((t, i) => { 0 === e.filter((e => e === t._dataset)).length && this._destroyDatasetMeta(i) })) } buildOrUpdateControllers(){ const t = [], e = this.data.datasets;soit i, s; pour(this._removeUnreferencedMetasets(), i = 0, s = e.length; i < s; i++) { const s = e[i];soit n = this.getDatasetMeta(i); const o = s.type || this.config.type; si(n.type && n.type !== o && (this._destroyDatasetMeta(i), n = this.getDatasetMeta(i)), n.type = o, n.indexAxis = s.indexAxis || an(o, this.options), n.order = s.order || 0, n.index = i, n.label = "" + s.label, n.visible = this.isDatasetVisible(i), n.controller)n.controller.updateIndex(i), n.controller.linkScales();sinon{ const e = fr.getController(o), { datasetElementType: s, dataElementType: a } = ue.datasets[o]; Object.assign(e, { dataElementType: en.getElement(a), datasetElementType: s && en.getElement(s) }), n.controller = nouveau e(this, i), t.push(n.controller) } }retourner ceci._updateMetasets(), t } _resetElements(){ u(this.data.datasets, ((t, e) => { this.getDatasetMeta(e).controller.reset() }), this) } reset(){ this._resetElements(), this.notifyPlugins("reset") }mise à jour(t){ const e = this.config; e.update(); const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()), s = this._animationsDisabled = !i.animation; if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins("avant la mise à jour", { mode: t, annulable: !0 })) return; const n = this.buildOrUpdateControllers(); this.notifyPlugins("avant la mise à jour des éléments");soit o = 0; pour(soit t = 0, e = this.data.datasets.length; t < e; t++) { const { controller: e } = this.getDatasetMeta(t), i = !s && -1 === n.indexOf(e); e.buildOrUpdateElements(i), o = Math.max(+e.getMaxOverflow(), o) } o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), s || u(n, (t => { t.reset() })), this._updateDatasets(t), this.notifyPlugins("après Mise à jour", { mode: t }), this._layers.sort(Mn("z", "_idx")); const { _active: a, _lastEvent: r } = this; r ? this._eventHandler(r, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render() } _updateScales(){ u(this.scales, (t => { as.removeBox(this, t) })), this.ensureScalesHaveIDs(), this.buildOrUpdateScales() } _checkEventBindings(){ const t = this.options, e = new Set(Object.keys(this._listeners)), i = nouveau Set(t.events); P(e, i) && !!this._responsiveListeners === t.responsive || (this.unbindEvents(), this.bindEvents()) } _updateHiddenIndices(){ const { _hiddenIndices: t } = this, e = this._getUniformDataChanges() || []; for (const { method: i, start: s, count: n } of e) { Cn(t, s, "_removeElements" === i ? -n : n) } } _getUniformDataChanges(){ const t = this._dataChanges; if (!t || !t.length) return; this._dataChanges = []; const e = this.data.datasets.length, i = e => nouveau Set(t.filter((t => t[0] === e)).map(((t, e) => e + "," + t.splice(1).join(",")))), s = i(0); for (let t = 1; t < e; t++)if (!P(s, i(t))) return; return Array.from(s).map((t => t.split(","))).map((t => ({ method: t[1], start: +t[2], count: +t[3] }))) } _updateLayout(t){ if (!1 === this.notifyPlugins("beforeLayout", { cancelable: !0 })) return; as.update(this, this.width, this.height, t); const e = this.chartArea, i = e.width <= 0 || e.height <= 0; this._layers = [], u(this.boxes, (t => { i && "chartArea" === t.position || (t.configure && t.configure(), this._layers.push(...t._layers())) }), this), this._layers.forEach(((t, e) => { t._idx = e })), this.notifyPlugins("afterLayout") } _updateDatasets(t){ if (!1 !== this.notifyPlugins("beforeDatasetsUpdate", { mode: t, cancelable: !0 })) { for (let t = 0, e = this.data.datasets.length; t < e; ++t)this.getDatasetMeta(t).controller.configure(); for (let e = 0, i = this.data.datasets.length; e < i; ++e)this._updateDataset(e, S(t) ? t({ datasetIndex: e }) : t); this.notifyPlugins("afterDatasetsUpdate", { mode: t }) } } _updateDataset(t, e){ const i = this.getDatasetMeta(t), s = { meta: i, index: t, mode: e, annulable: !0 }; !1 !== this.notifyPlugins("avantDatasetUpdate", s) && (i.controller._update(e), s.cancelable = !1, this.notifyPlugins("aprèsDatasetUpdate", s)) } render(){ !1 !== this.notifyPlugins("avantRender", { annulable: !0 }) && (xt.has(this) ? this.attached && !xt.running(this) && xt.start(this) : (this.draw(), wn({ chart: this }))) } draw(){ let t; si(this._resizeBeforeDraw){ const { width: t, height: e } = this._resizeBeforeDraw; this._resizeBeforeDraw = null, this._resize(t, e) } si(this.clear(), this.width <= 0 || this.height <= 0)retour; si(!1 === this.notifyPlugins("beforeDraw", { annulable: !0 }))retour; const e = this._layers; pour(t = 0; t < e.length && e[t].z <= 0; ++t) e[t].draw(this.chartArea); pour(this._drawDatasets(); t < e.length; ++t) e[t].draw(this.chartArea); this.notifyPlugins("afterDraw") } _getSortedDatasetMetas(t){ const e = this._sortedMetasets, i = [];soit s, n; pour(s = 0, n = e.length; s < n; ++s) { const n = e[s]; t && !n.visible || i.push(n) }retour i } getSortedVisibleDatasetMetas(){retour this._getSortedDatasetMetas(!0) } _drawDatasets(){ si(!1 === this.notifyPlugins("beforeDatasetsDraw", { annulable: !0 }))retour; const t = this.getSortedVisibleDatasetMetas(); pour(soit e = t.length - 1; e >= 0; --e) this._drawDataset(t[e]); this.notifyPlugins("afterDatasetsDraw") } _drawDataset(t){ const e = this.ctx, i = t._clip, s = !i.désactivé, n = fonction(t, e){ const{ xScale: i, yScale: s } = t;retour i && s ? { gauche: Sur(i, e, "gauche"), droite: Sur(i, e, "droite"), haut: Sur(s, e, "haut"), bas: Sur(s, e, "bas") } : e } (t, this.chartArea), o = { meta: t, index: t.index, annulable: !0 }; !1 !== this.notifyPlugins("beforeDatasetDraw", o) && (s && Ie(e, { gauche: !1 === i.left ? 0 : n.left - i.lef t, droite: !1 === i.droite ? this.largeur : n.droite + i.droite, haut: !1 === i.haut ? 0 : n.haut - i.haut, bas: !1 === i.bas ? this.hauteur : n.bas + i.bas }), t.controller.draw(), s && ze(e), o.cancelable = !1, this.notifyPlugins("afterDatasetDraw", o)) } isPointInArea(t){retour Re(t, this.chartArea, this._minPadding) } getElementsAtEventForMode(t, e, i, s){ const n = Xi.modes[e];retour"fonction" == typeof n ? n(this, t, i, s) : [] } getDatasetMeta(t){ const e = this.data.datasets[t], i = this._metasets; let s = i.filter((t => t && t._dataset === e)).pop();retour s || (s = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: e && e.order || 0, index: t, _dataset: e, _parsed: [], _sorted: !1 }, i.push(s)), s } getContext(){retourne ceci.$context || (ceci.$context = Ci(null, { graphique: ceci, type: "graphique" })) } getVisibleDatasetCount(){retourne ceci.getSortedVisibleDatasetMetas().length } isDatasetVisible(t){ const e = ceci.données.datasets[t]; si(!e)retourne!1; const i = ceci.getDatasetMeta(t);retourne"booléen" == typeof i.hidden ? !i.hidden : !e.hidden } setDatasetVisibility(t, e){ this.getDatasetMeta(t).hidden = !e } toggleDataVisibility(t){ this._hiddenIndices[t] = !this._hiddenIndices[t] } getDataVisibility(t){ return !this._hiddenIndices[t] } _updateVisibility(t, e, i){ const s = i ? "show" : "masquer", n = this.getDatasetMeta(t), o = n.controller._resolveAnimations(void 0, s); k(e) ? (n.data[e].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), o.update(n, { visible: i }), this.update((e => e.datasetIndex === t ? s : void 0))) } masquer(t, e){ this._updateVisibility(t, e, !1) } afficher(t, e){ this._updateVisibility(t, e, !0) } _destroyDatasetMeta(t){ const e = this._metasets[t]; e && e.controller && e.controller._destroy(), supprimer this._metasets[t] } _stop(){ let t, e; for (this.stop(), xt.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t)this._destroyDatasetMeta(t) } destroy(){ this.notifyPlugins("beforeDestroy"); const { canvas: t, ctx: e } = this; this._stop(), this.config.clearCache(), t && (this.unbindEvents(), Te(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), delete Pn[this.id], this.notifyPlugins("afterDestroy") } toBase64Image(...t){ return this.canvas.toDataURL(...t) } bindEvents(){ this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0 } bindUserEvents(){ const t = this._listeners, e = this.platform, i = (i, s) => { e.addEventListener(this, i, s), t[i] = s }, s = (t, e, i) => { t.offsetX = e, t.offsetY = i, this._eventHandler(t) }; u(this.options.events, (t => i(t, s))) } bindResponsiveEvents(){ this._responsiveListeners || (this._responsiveListeners = {}); const t = this._responsiveListeners, e = this.platform, i = (i, s) => { e.addEventListener(this, i, s), t[i] = s }, s = (i, s) => { t[i] && (e.removeEventListener(this, i, s), supprimer t[i]) }, n = (t, e) => { this.canvas && this.resize(t, e) }; let o; const a = () => { s("attach", a), this.attached = !0, this.resize(), i("resize", n), i("detach", o) }; o = () => { this.attached = !1, s("resize", n), this._stop(), this._resize(0, 0), i("attach", a) }, e.isAttached(this.canvas) ? a() : o() } unbindEvents(){ u(this._listeners, ((t, e) => { this.platform.removeEventListener(this, e, t) })), this._listeners = {}, u(this._responsiveListeners, ((t, e) => { this.platform.removeEventListener(this, e, t) })), this._responsiveListeners = void 0 } updateHoverStyle(t, e, i){ const s = i ? "set" : "supprimer"; let n, o, a, r; for ("dataset" === e && (n = this.getDatasetMeta(t[0].datasetIndex), n.controller["_" + s + "DatasetHoverStyle"]()), a = 0, r = t.length; a < r; ++a) { o = t[a]; const e = o && this.getDatasetMeta(o.datasetIndex).controller; e && e[s + "HoverStyle"](o.element, o.datasetIndex, o.index) } } getActiveElements(){ return this._active || [] } setActiveElements(t){ const e = this._active || [], i = t.map((({ datasetIndex: t, index: e }) => { const i = this.getDatasetMeta(t); if (!i) throw new Erreur("Aucun ensemble de données trouvé à l'index " + t); return { datasetIndex: t, element: i.data[e], index: e } })); !f(i, e) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, e)) } notifyPlugins(t, e, i){ return this._plugins.notify(this, t, e, i) } isPluginEnabled(t){ return 1 === this._plugins._cache.filter((e => e.plugin.id === t)).length } _updateHoverStyles(t, e, i){ const s = this.options.hover, n = (t, e) => t.filter((t => !e.some((e => t.datasetIndex === e.datasetIndex && t.index === e.index)))), o = n(e, t), a = i ? t : n(t, e); o.length && this.updateHoverStyle(o, s.mode, !1), a.length && s.mode && this.updateHoverStyle(a, s.mode, !0) } _eventHandler(t, e){ const i = { événement: t, relecture: e, annulable: !0, inChartArea: this.isPointInArea(t) }, s = e => (e.options.events || this.options.events).includes(t.native.type); si(!1 === this.notifyPlugins("beforeEvent", i, s)) retour; const n = this._handleEvent(t, e, i.inChartArea); retour i.cancelable = !1, this.notifyPlugins("afterEvent", i, s), (n || i.changed) && this.render(), this } _handleEvent(t, e, i){ const { _active: s = [], options: n } = this, o = e, a = this._getActiveElements(t, s, i, o), r = D(t), l = function (t, e, i, s) { return i && "mouseout" !== t.type ? s ? e : t : null }(t, this._lastEvent, i, r); i && (this._lastEvent = null, d(n.onHover, [t, a, this], this), r && d(n.onClick, [t, a, this], this)); const h = !f(a, s); return (h || e) && (this._active = a, this._updateHoverStyles(a, s, e)), this._lastEvent = l, h } _getActiveElements(t, e, i, s){ if ("mouseout" === t.type) return []; if (!i) return e; const n = this.options.hover; return this.getElementsAtEventForMode(t, n.mode, n, s) }}function Tn() { return u(An.instances, (t => t._plugins.invalidate())) } function Ln() { throw new Error("Cette méthode n'est pas implémentée : vérifiez qu'un adaptateur de date complet est fourni.") }classe En{static override(t){ Object.assign(En.prototype, t) } options; constructeur(t){ this.options = t || {} } init(){ } formats(){retour Ln() } parse(){retour Ln() } format(){retour Ln() } add(){retour Ln() } diff(){retour Ln() } startOf(){retour Ln() } endOf(){retour Ln() } } var Rn = { _date: En };fonction In(t){ const e = t.iScale, i = function (t, e) { if (!t._cache.$bar) { const i = t.getMatchingVisibleMetas(e); let s = []; for (let e = 0, n = i.length; e < n; e++)s = s.concat(i[e].controller.getAllParsedValues(t)); t._cache.$bar = lt(s.sort(((t, e) => te))) }retour t._cache.$bar }(e, t.type); let s, n, o, a, r = e._length; const l = () => { 32767 !== o && -32768 !== o && (k(a) && (r = Math.min(r, Math.abs(oa) || r)), a = o) }; pour(s = 0, n = i.length; s < n; ++s) o = e.getPixelForValue(i[s]), l(); pour(a = void 0, s = 0, n = e.ticks.length; s < n; ++s) o = e.getPixelForTick(s), l();retour r }fonction zn(t, e, i, s){retour n(t) ? fonction(t, e, i, s){ const n = i.parse(t[0], s), o = i.parse(t[1], s), a = Math.min(n, o), r = Math.max(n, o); let l = a, h = r; Math.abs(a) > Math.abs(r) && (l = r, h = a), e[i.axis] = h, e._custom = { barStart: l, barEnd: h, start: n, end: o, min: a, max: r } } (t, e, i, s): e[i.axis] = i.parse(t, s), e }fonction Fn(t, e, i, s){ const n = t.iScale, o = t.vScale, a = n.getLabels(), r = n === o, l = [];soit h, c, d, u; pour(h = i, c = i + s; h < c; ++h) u = e[h], d = {}, d[n.axis] = r || n.parse(a[h], h), l.push(zn(u, d, o, h));retour l }fonction Vn(t){retour t && void 0 !== t.barStart && void 0 !== t.barEnd }fonction Bn(t, e, i, s){ let n = e.borderSkipped; const o = {}; si(!n)retour void (t.borderSkipped = o); si(!0 === n)retour void (t.borderSkipped = { haut: !0, droite: !0, bas: !0, gauche: !0 }); const { début: a, fin: r, inverse: l, haut: h, bas: c } = function (t) { let e, i, s, n, o; return t.horizontal ? (e = t.base > tx, i = "gauche", s = "droite") : (e = t.base < ty, i = "bas", s = "haut"), e ? (n = "fin", o = "début") : (n = "début", o = "fin"), { début: i, fin: s, inverse: e, haut: n, bas: o } }(t); "milieu" === n && i && (t.enableBorderRadius = !0, (i._top || 0) === s ? n = h : (i._bottom || 0) === s ? n = c : (o[Wn(c, a, r, l)] = !0, n = h)), o[Wn(n, a, r, l)] = !0, t.borderSkipped = o }fonction Wn(t, e, i, s){ var n, o, a;retour s ? (a = i, t = Nn(t = (n = t) === (o = e) ? a : n === a ? o : n, i, e)) : t = Nn(t, e, i), t }fonction Nn(t, e, i){ return "start" === t ? e : "end" === t ? i : t }fonction Hn(t, { inflateAmount: e }, i){ t.inflateAmount = "auto" === e ? 1 === i ? .33 : 0 : e }classe jn étend Ns{static id = "doughnut";static defaults = { datasetElementType: !1, dataElementType: "arc", animation: { animateRotate: !0, animateScale: !1 }, animations: { numbers: { type: "number", properties: ["circonférence", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "décalage", "borderWidth", "espacement"] } }, cutout: "50%", rotation: 0, circonférence: 360, rayon: "100%", espacement: 0, indexAxis: "r" };static descriptors = { _scriptable: t => "espacement" !== t, _indexable: t => "espacement" !== t && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash") }; remplacements statiques = { aspectRatio: 1, plugins: { légende: { étiquettes: { generateLabels(t) { const e = t.data; si(e.labels.length && e.datasets.length){ const { étiquettes: { pointStyle: i, color: s } } = t.legend.options;retour e.labels.map(((e, n) => { const o = t.getDatasetMeta(0).controller.getStyle(n);retour{ texte: e, fillStyle: o.backgroundColor, strokeStyle: o.borderColor, fontColor: s, lineWidth: o.borderWidth, pointStyle: i, masqué: !t.getDataVisibility(n), index: n } })) } retour[] } }, onClick(t, e, i) { i.chart.toggleDataVisibility(e.index), i.chart.update() } } } }; constructeur(t, e){ super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0 } linkScales(){ } parse(t, e){ const i = this.getDataset().data, s = this._cachedMeta; si(!1 === this._parsing)s._parsed = i;sinon{ let n, a, r = t => +i[t]; si(o(i[t])){ const { key: t = "value" } = this._parsing; r = e => +M(i[e], t) } pour(n = t, a = t + e; n < a; ++n) s._parsed[n] = r(n) } } _getRotation(){retourne $(this.options.rotation - 90) } _getCircumference(){retourne $(this.options.circumference) } _getRotationExtents(){ let t = O, e = -O; pour(let i = 0; i < this.chart.data.datasets.length; ++i) si(this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type){ const s = this.chart.getDatasetMeta(i).controller, n = s._getRotation(), o = s._getCircumference(); t = Math.min(t, n), e = Math.max(e, n + o) }retour{ rotation: t, circonférence: et } }mise à jour(t){ const e = this.chart, { chartArea: i } = e, s = this._cachedMeta, n = s.data, o = this.getMaxBorderWidth() + this.getMaxOffset(n) + this.options.spacing, a = Math.max((Math.min(i.width, i.height) - o) / 2, 0), r = Math.min(h(this.options.cutout, a), 1), l = this._getRingWeight(this.index), { circonférence: d, rotation: u } = this._getRotationExtents(), { ratioX: f, ratioY: g, offsetX: p, offsetY: m } = function (t, e, i) { let s = 1, n = 1, o = 0, a = 0; if (e < O) { const r = t, l = r + e, h = Math.cos(r), c = Math.sin(r), d = Math.cos(l), u = Math.sin(l), f = (t, e, s) => Z(t, r, l, !0) ? 1 : Math.max(e, e * i, s, s * i), g = (t, e, s) => Z(t, r, l, !0) ? -1 : Math.min(e, e * i, s, s * i), p = f(0, h, d), m = f(E, c, u), b = g(C, h, d), x = g(C + E, c, u); s = (pb) / 2, n = (mx) / 2, o = -(p + b) / 2, a = -(m + x) / 2 }retour{ ratioX: s, ratioY: n, offsetX: o, offsetY: a } }(u, d, r), b = (i.largeur - o) / f, x = (i.hauteur - o) / g, _ = Math.max(Math.min(b, x) / 2, 0), y = c(this.options.radius, _), v = (y - Math.max(y * r, 0)) / this._getVisibleDatasetWeightTotal(); this.offsetX = p * y, this.offsetY = m * y, s.total = this.calculateTotal(), this.outerRadius = yv * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - v * l, 0), this.updateElements(n, 0, n.length, t) } _circonférence(t, e){ const i = this.options, s = this._cachedMeta, n = this._getCircumference();retour e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || null === s._parsed[t] || s.data[t].hidden ? 0 : this.calculateCircumference(s._parsed[t] * n / O) } updateElements(t, e, i, s){ const n = "reset" === s, o = this.chart, a = o.chartArea, r = o.options.animation, l = (a.gauche + a.droite) / 2, h = (a.haut + a.bas) / 2, c = n && r.animateScale, d = c ? 0 : this.innerRadius, u = c ? 0 : this.externalRadius, { sharedOptions: f, includeOptions: g } = this._getSharedOptions(e, s);soit p, m = this._getRotation(); pour(p = 0; p < e; ++p) m += this._circumference(p, n); pour(p = e; p < e + i; ++p) { const e = this._circumference(p, n), i = t[p], o = { x: l + this.offsetX, y: h + this.offsetY, startAngle: m, endAngle: m + e, circumference: e, outerRadius: u, innerRadius: d }; g && (o.options = f || this.resolveDataElementOptions(p, i.active ? "active" : s)), m += e, this.updateElement(i, p, o, s) } } calculateTotal(){ const t = this._cachedMeta, e = t.data; let i, s = 0; for (i = 0; i < e.length; i++) { const n = t._parsed[i]; null === n || isNaN(n) || !this.chart.getDataVisibility(i) || e[i].hidden || (s += Math.abs(n)) }retour s } calculateCircumference(t){ const e = this._cachedMeta.total;retour e > 0 && !isNaN(t) ? O * (Math.abs(t) / e) : 0 } getLabelAndValue(t){ const e = this._cachedMeta, i = this.chart, s = i.data.labels || [], n = ne(e._parsed[t], i.options.locale);retour{ étiquette: s[t] || "", valeur: n } } getMaxBorderWidth(t){ let e = 0; const i = this.chart; let s, n, o, a, r; si(!t)pour(s = 0, n = i.data.datasets.length; s < n; ++s) si(i.isDatasetVisible(s)){ o = i.getDatasetMeta(s), t = o.data, a = o.controller; break } si(!t)retour 0; pour(s = 0, n = t.length; s < n; ++s) r = a.resolveDataElementOptions(s), "inner"! = r.borderAlign && (e = Math.max(e, r.borderWidth | | 0, r.hoverBorderWidth | | 0)); retour e } getMaxOffset(t) { soit e = 0; pour(soit i = 0, s = t.length; i < s; ++i) { const t = this.resolveDataElementOptions(i); e = Math.max(e, t.offset | | 0, t.hoverOffset | | 0) } retour e } _ getRingWeightOffset(t) { soit e = 0; pour(soit i = 0; i < t; ++i) this.chart.isDatasetVisible(i) && (e + = this._ getRingWeight(i)); retour e } _getRingWeight(t){retour Math.max(l(this.chart.data.datasets[t].weight, 1), 0) } _getVisibleDatasetWeightTotal(){retour this._getRingWeightOffset(this.chart.data.datasets.length) || 1 } }classe $n étend Ns{static id = "polarArea";static defaults = { dataElementType: "arc", animation: { animateRotate: !0, animateScale: !0 }, animations: { numbers: { type: "number", properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"] } }, indexAxis: "r", startAngle: 0 };static overrides = { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(t) { const e = t.data; si(e.labels.length && e.datasets.length){ const { labels: { pointStyle: i, color: s } } = t.legend.options;retour e.labels.map(((e, n) => { const o = t.getDatasetMeta(0).controller.getStyle(n); return { text: e, fillStyle: o.backgroundColor, strokeStyle: o.borderColor, fontColor: s, lineWidth: o.borderWidth, pointStyle: i, hidden: !t.getDataVisibility(n), index: n } })) } return [] } }, onClick(t, e, i) { i.chart.toggleDataVisibility(e.index), i.chart.update() } } }, scales: { r: { type: "radialLinear", angleLines: { display: !1 }, beginAtZero: !0, grid: { circular: !0 }, pointLabels: { display: !1 }, startAngle: 0 } } }; constructor(t, e){ super(t, e), this.innerRadius = void 0, this.outerRadius = void 0 } getLabelAndValue(t){ const e = this._cachedMeta, i = this.chart, s = i.data.labels || [], n = ne(e._parsed[t].r, i.options.locale); return { label: s[t] || "", valeur: n } } parseObjectData(t, e, i, s){retour ii.bind(this)(t, e, i, s) } update(t){ const e = this._cachedMeta.data; this._updateRadius(), this.updateElements(e, 0, e.length, t) } getMinMax(){ const t = this._cachedMeta, e = { min: Nombre.INFINITÉ_POSITIF, max: Nombre.INFINITÉ_NÉGATIVE };retour t.data.forEach(((t, i) => { const s = this.getParsed(i).r; !isNaN(s) && this.chart.getDataVisibility(i) && (s < e.min && (e.min = s), s > e.max && (e.max = s)) })), e } _updateRadius(){ const t = ce.graphique, e = t.graphiqueArea, i = t.options, s = Math.min(e.droite - e.gauche, e.bas - e.haut), n = Math.max(s / 2, 0), o = (n - Math.max(i.cutoutPercentage ? n / 100 * i.cutoutPercentage : 1, 0)) / t.getVisibleDatasetCount(); this.outerRadius = no * this.index, this.innerRadius = this.outerRadius - o } updateElements(t, e, i, s){ const n = "reset" === s, o = ce.graphique, a = o.options.animation, r = this._cachedMeta.rScale, l = r.xCenter, h = r.yCenter, c = r.getIndexAngle(0) - .5 * C; let d, u = c; const f = 360 / this.countVisibleElements(); pour(d = 0; d < e; ++d) u += this._computeAngle(d, s, f); pour(d = e; d < e + i; d++) { const e = t[d]; let i = u, g = u + this._computeAngle(d, s, f), p = o.getDataVisibility(d) ? r.getDistanceFromCenterForValue(this.getParsed(d).r) : 0; u = g, n && (a.animateScale && (p = 0), a.animateRotate && (i = g = c)); const m = { x: l, y: h, innerRadius: 0, outerRadius: p, startAngle: i, endAngle: g, options: this.resolveDataElementOptions(d, e.active ? "active" : s) }; this.updateElement(e, d, m, s) } } countVisibleElements(){ const t = this._cachedMeta; let e = 0; return t.data.forEach(((t, i) => { !isNaN(this.getParsed(i).r) && this.chart.getDataVisibility(i) && e++ })), e } _computeAngle(t, e, i){ return this.chart.getDataVisibility(t) ? $(this.resolveDataElementOptions(t, e).angle || i) : 0 } } var Yn = Object.freeze({ __proto__: null, BarController: class extends Ns { static id = "bar"; static defaults = { datasetElementType: !1, dataElementType: "bar", categoryPercentage: .8, barPercentage: .9, grouped: !0, animations: { numbers: { type: "number", properties: ["x", "y", "base", "width", "height"] } } }; static overrides = { scales: { _index_: { type: "category", offset: !0, grid: { offset: !0 } }, _value_: { type: "linear", beginAtZero: !0 } } }; parsePrimitiveData(t, e, i, s) { return Fn(t, e, i, s) } parseArrayData(t, e, i, s) { return Fn(t, e, i, s) } parseObjectData(t, e, i, s) { const { iScale: n, vScale: o } = t, { xAxisKey: a = "x", yAxisKey: r = "y" } = this._parsing, l = "x" === n.axis ? a : r, h = "x" === o.axis ? a : r, c = []; let d, u, f, g; for (d = i, u = i + s; d < u; ++d)g = e[d], f = {}, f[n.axis] = n.parse(M(g, l), d), c.push(zn(M(g, h), f, o, d)); return c } updateRangeFromParsed(t, e, i, s) { super.updateRangeFromParsed(t, e, i, s); const n = i._custom; n && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, n.min), t.max = Math.max(t.max, n.max)) } getMaxOverflow() { return 0 } getLabelAndValue(t) { const e = this._cachedMeta, { iScale: i, vScale: s } = e, n = this.getParsed(t), o = n._custom, a = Vn(o) ? "[" + o.start + ", " + o.end + "]" : "" + s.getLabelForValue(n[s.axe]);retour{ étiquette: "" + i.getLabelForValue(n[i.axis]), valeur : a } } initialiser() { this.enableOptionSharing = !0, super.initialize(); this._cachedMeta.stack = this.getDataset().stack }mise à jour(t) { const e = this._cachedMeta; this.updateElements(e.data, 0, e.data.length, t) }mise à jourElements(t, e, i, n) { const o = "reset" === n, { index: a, _cachedMeta: { vScale: r } } = this, l = r.getBasePixel(), h = r.isHorizontal(), c = this._getRuler(), { sharedOptions: d, includeOptions: u } = this._getSharedOptions(e, n); pour(let f = e; f < e + i; f++){ const e = this.getParsed(f), i = o || s(e[r.axis]) ? { base: l, head: l } : this._calculateBarValuePixels(f), g = this._calculateBarIndexPixels(f, c), p = (e._stacks || {})[r.axis], m = { horizontal: h, base: i.base, enableBorderRadius: !p || Vn(e._custom) || a === p._top || a === p._bottom, x: h ? i.head : g.center, y: h ? g.center : i.head, height: h ? g.size : Math.abs(i.size), width: h ? Math.abs(i.size) : g.size }; u && (m.options = d || this.resolveDataElementOptions(f, t[f].active ? "active" : n)); const b = m.options || t[f].options; Bn(m, b, p, a), Hn(m, b, c.ratio), this.updateElement(t[f], f, m, n)}}_getStacks(t, e){ const { iScale: i } = this._cachedMeta, n = i.getMatchingVisibleMetas(this._type).filter((t => t.controller.options.grouped)), o = i.options.stacked, a = [], r = this._cachedMeta.controller.getParsed(e), l = r && r[i.axis], h = t => { const e = t._parsed.find((t => t[i.axis] === l)), n = e && e[t.vScale.axis]; si(s(n) || isNaN(n))retour!0 }; pour(const i de n) si((void 0 === e || !h(i)) && ((!1 === o || -1 === a.indexOf(i.stack) || void 0 === o && void 0 === i.stack) && a.push(i.stack), i.index === t))pause;retourner a.length || a.push(void 0), a } _getStackCount(t){retourner this._getStacks(void 0, t).length } _getStackIndex(t, e, i){ const s = this._getStacks(t, i), n = void 0 !== e ? s.indexOf(e) : -1; return -1 === n ? s.length - 1 : n } _getRuler(){ const t = this.options, e = this._cachedMeta, i = e.iScale, s = []; let n, o; for (n = 0, o = e.data.length; n < o; ++n)s.push(i.getPixelForValue(this.getParsed(n)[i.axis], n)); const a = t.barThickness;retour{ min: a || In(e), pixels: s, début: i._startPixel, fin: i._endPixel, stackCount: this._getStackCount(), échelle: i, groupé: t.groupé, ratio: a ? 1 : t.categoryPercentage * t.barPercentage } } _calculateBarValuePixels(t){ const { _cachedMeta: { vScale: e, _stacked: i, index: n }, options: { base: o, minBarLength: a } } = this, r = o || 0, l = this.getParsed(t), h = l._custom, c = Vn(h);soit d, u, f = l[e.axis], g = 0, p = i ? this.applyStack(e, l, i) : f; p !== f && (g = pf, p = f), c && (f = h.barStart, p = h.barEnd - h.barStart, 0 !== f && F(f) !== F(h.barEnd) && (g = 0), g += f); const m = s(o) || c ? g : o; let b = e.getPixelForValue(m); si(d = this.chart.getDataVisibility(t) ? e.getPixelForValue(g + p) : b, u = db, Math.abs(u) < a){ u = function (t, e, i) { return 0 !== t ? F(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= i ? 1 : -1) }(u, e, r) * a, f === r && (b -= u / 2); const t = e.getPixelForDecimal(0), s = e.getPixelForDecimal(1), o = Math.min(t, s), h = Math.max(t, s); b = Math.max(Math.min(b, h), o), d = b + u, i && !c && (l._stacks[e.axis]._visualValues[n] = e.getValueForPixel(d) - e.getValueForPixel(b)) } si(b === e.getPixelForValue(r)){ const t = F(u) * e.getLineWidthForValue(r) / 2; b += t, u -= t }retour{ taille: u, base: b, tête: d, centre: d + u / 2 } } _calculateBarIndexPixels(t, e){ const i = e.scale, n = this.options, o = n.skipNull, a = l(n.maxBarThickness, 1 / 0);soit r, h; si(e.grouped){ const i = o ? this._getStackCount(t) : e.stackCount, l = "flex" === n.barThickness ? function (t, e, i, s) { const n = e.pixels, o = n[t];soit a = t > 0 ? n[t - 1] : null, r = t < n.length - 1 ? n[t + 1] : null; const l = i.categoryPercentage; null === a && (a = o - (null === r ? e.end - e.start : ro)), null === r && (r = o + oa); const h = o - (o - Math.min(a, r)) / 2 * l;retour{ chunk: Math.abs(ra) / 2 * l / s, ratio: i.barPercentage, début: h } }(t, e, n, i) : function (t, e, i, n) { const o = i.barThickness;soit a, r;retour s(o) ? (a = e.min * i.categoryPercentage, r = i.barPercentage) : (a = o * n, r = 1), { chunk: a / n, ratio: r, start: e.pixels[t] - a / 2 } }(t, e, n, i), c = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0); r = l.start + l.chunk * c + l.chunk / 2, h = Math.min(a, l.chunk * l.ratio) }else r = i.getPixelForValue(this.getParsed(t)[i.axis], t), h = Math.min(a, e.min * e.ratio); return { base: rh / 2, head: r + h / 2, center: r, size: h } } draw(){ const t = this._cachedMeta, e = t.vScale, i = t.data, s = i.length;soit n = 0; pour(; n < s; ++n) null === this.getParsed(n)[e.axis] || i[n].hidden || i[n].draw(this._ctx) }}, BubbleController: class extends Ns { static id = "bubble"; static defaults = { datasetElementType: !1, dataElementType: "point", animations: { numbers: { type: "number", properties: ["x", "y", "borderWidth", "radius"] } } }; static overrides = { scales: { x: { type: "linear" }, y: { type: "linear" } } }; initialize() { this.enableOptionSharing = !0, super.initialize() } parsePrimitiveData(t, e, i, s) { const n = super.parsePrimitiveData(t, e, i, s); pour(soit t = 0; t < n.length; t++) n[t]._custom = this.resolveDataElementOptions(t + i).radius;retourne n } parseArrayData(t, e, i, s) { const n = super.parseArrayData(t, e, i, s); pour(soit t = 0; t < n.length; t++) { const s = e[i + t]; n[t]._custom = l(s[2], this.resolveDataElementOptions(t + i).radius) }retourne n } parseObjectData(t, e, i, s) { const n = super.parseObjectData(t, e, i, s); pour(soit t = 0; t < n.length; t++) { const s = e[i + t]; n[t]._custom = l(s && s.r && +sr, this.resolveDataElementOptions(t + i).radius) }retour n } getMaxOverflow() { const t = this._cachedMeta.data;soit e = 0; pour(soit i = t.length - 1; i >= 0; --i) e = Math.max(e, t[i].size(this.resolveDataElementOptions(i)) / 2);retour e > 0 && e } getLabelAndValue(t) { const e = this._cachedMeta, i = this.chart.data.labels || [], { xScale: s, yScale: n } = e, o = this.getParsed(t), a = s.getLabelForValue(ox), r = n.getLabelForValue(oy), l = o._custom;retour{ label: i[t] || "", valeur: "(" + a + ", " + r + (l ? ", " + l : "") + ")" } }mise à jour(t) { const e = this._cachedMeta.data; this.updateElements(e, 0, e.length, t) } updateElements(t, e, i, s) { const n = "réinitialiser" === s, { iScale: o, vScale: a } = this._cachedMeta, { sharedOptions: r, includeOptions: l } = this._getSharedOptions(e, s), h = o.axe, c = a.axe; pour(let d = e ; d < e + i; d++) { const e = t[d], i = !n && this.getParsed(d), u = {}, f = u[h] = n ? o.getPixelForDecimal(.5) : o.getPixelForValue(i[h]), g = u[c] = n ? a.getBasePixel() : a.getPixelForValue(i[c]); u.skip = isNaN(f) || isNaN(g), l && (u.options = r || this.resolveDataElementOptions(d, e.active ? "active" : s), n && (u.options.radius = 0)), this.updateElement(e, d, u, s) } } resolveDataElementOptions(t, e) { const i = this.getParsed(t); let s = super.resolveDataElementOptions(t, e); s.$shared && (s = Object.assign({}, s, { $shared: !1 })); const n = s.radius;retour"actif" !== e && (s.radius = 0), s.radius += l(i && i._custom, n), s } }, DoughnutController: jn, LineController: class extends Ns { static id = "line"; static defaults = { datasetElementType: "line", dataElementType: "point", showLine: !0, spanGaps: !1 }; static overrides = { scales: { _index_: { type: "category" }, _value_: { type: "linear" } } }; initialize() { this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize() } update(t) { const e = this._cachedMeta, { dataset: i, data: s = [], _dataset: n } = e, o = this.chart._animationsDisabled; let { start: a, count: r } = pt(e, s, o); this._drawStart = a, this._drawCount = r, mt(e) && (a = 0, r = s.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!n._decimated, i.prides = { aspectRatio: 1, scales: { r: { type: "radialLinear" } } }; getLabelAndValue(t){ const e = this._cachedMeta.vScale, i = this.getParsed(t);retour{ étiquette: e.getLabels()[t], valeur: "" + e.getLabelForValue(i[e.axis]) } } parseObjectData(t, e, i, s){retour ii.bind(this)(t, e, i, s) } update(t){ const e = this._cachedMeta, i = e.dataset, s = e.data || [], n = e.iScale.getLabels(); si(i.points = s, "resize" !== t){ const e = this.resolveDatasetElementOptions(t); this.options.showLine || (e.borderWidth = 0); const o = { _loop: !0, _fullLoop: n.length === s.length, options: e }; this.updateElement(i, void 0, o, t) } this.updateElements(s, 0, s.length, t) } updateElements(t, e, i, s){ const n = this._cachedMeta.rScale, o = "reset" === s; for (let a = e; a < e + i; a++) { const e = t[a], i = this.resolveDataElementOptions(a, e.active ? "active" : s), r = n.getPointPositionForValue(a, this.getParsed(a).r), l = o ? n.xCenter : rx, h = o ? n.yCenter : ry, c = { x: l, y: h, angle: r.angle, skip: isNaN(l) || isNaN(h), options: i }; this.updateElement(e, a, c, s) } } }, ScatterController: class extends Ns{static id = "scatter"; static defaults = { datasetElementType: !1, dataElementType: "point", showLine: !1, fill: !1 }; static remplace = { interaction: { mode: "point " }, échelles: { x: { type: "linéaire " }, y: { type: "linéaire " } } }; getLabelAndValue(t) { const e = this._cachedMeta, i = this.chart.data.labels || [], { xScale: s, yScale: n } = e, o = this.getParsed(t), a = s.getLabelForValue(ox), r = n.getLabelForValue(oy); retour { étiquette: i[t] || " ", valeur : "(" + a + ", " + r + ")" } } mise à jour(t) { const e = this._cachedMeta, { data: i = [] } = e, s = this.chart._animationsDisabled; let { start: n, count: o } = pt(e, i, s); if (this._drawStart = n, this._drawCount = o, mt(e) && (n = 0, o = i.length), this.options.showLine) { this.datasetElementType || this.addElements(); const { dataset: n, _dataset: o } = e; n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!o._decimated, n.points = i; const a = this.resolveDatasetElementOptions(t); a.segment = this.options.segment, this.updateElement(n, void 0, { animated: !s, options: a }, t) } else ceci.datasetElementType && (supprimer e.dataset, ceci.datasetElementType = !1); ceci.updateElements(i, n, o, t) } addElements() { const { showLine: t } = this.options; !ceci.datasetElementType && t && (ce.datasetElementType = this.chart.registry.getElement("line")), super.addElements() } updateElements(t, e, i, n) { const o = "reset" === n, { iScale: a, vScale: r, _stacked: l, _dataset: h } = this._cachedMeta, c = this.resolveDataElementOptions(e, n), d = this.getSharedOptions(c), u = this.includeOptions(n, d), f = a.axis, g = r.axis, { spanGaps: p, segment: m } = this.options, b = N(p) ? p : Number.POSITIVE_INFINITY, x = this.chart._animationsDisabled || o || "none" === n; let _ = e > 0 && this.getParsed(e - 1); for (let c = e; c < e + i; ++c) { const e = t[c], i = this.getParsed(c), p = x ? e : {}, y = s(i[g]), v = p[f] = a.getPixelForValue(i[f], c), M = p[g] = o || y ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, i, l) : i[g], c); p.skip = isNaN(v) || isNaN(M) || y, p.stop = c > 0 && Math.abs(i[f] - _[f]) > b, m && (p.parsed = i, p.raw = h.données[c]), u && (p.options = d || this.resolveDataElementOptions(c, e.active ? "active" : n)), x || this.updateElement(e, c, p, n), _ = i } this.updateSharedOptions(d, n, c) } getMaxOverflow() { const t = this._cachedMeta, e = t.data || []; si(!this.options.showLine){ let t = 0; pour(let i = e.length - 1; i >= 0; --i) t = Math.max(t, e[i].size(this.resolveDataElementOptions(i)) / 2);retourner t > 0 && t } const i = t.dataset, s = i.options && i.options.borderWidth || 0; si(!e.length)retourner s; const n = e[0].size(this.resolveDataElementOptions(0)), o = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));retour Math.max(s, n, o) / 2 } }});fonction Un(t, e, i, s){ const n = vi(t.options.borderRadius, ["outerStart", "outerEnd", "innerStart", "innerEnd"]); const o = (ie) / 2, a = Math.min(o, s * e / 2), r = t => { const e = (i - Math.min(o, t)) * s / 2;retour J(t, 0, Math.min(o, e)) };retour{ outerStart: r(n.outerStart), outerEnd: r(n.outerEnd), innerStart: J(n.innerStart, 0, a), innerEnd: J(n.innerEnd, 0, a) } }fonction Xn(t, e, i, s){retour{ x: i + t * Math.cos(e), y: s + t * Math.sin(e) } }fonction qn(t, e, i, s, n, o){ const { x: a, y: r, startAngle: l, pixelMargin: h, innerRadius: c } = e, d = Math.max(e.outerRadius + s + ih, 0), u = c > 0 ? c + s + i + h : 0;soit f = 0; const g = nl; si(s){ const t = ((c > 0 ? cs : 0) + (d > 0 ? ds : 0)) / 2; f = (g - (0 !== t ? g * t / (t + s) : g)) / 2 } const p = (g - Math.max(.001, g * di / C) / d) / 2, m = l + p + f, b = npf, { outerStart: x, outerEnd: _, innerStart: y, innerEnd: v } = Un(e, u, d, bm), M = dx, w = d - _, k = m + x / M, S = b - _ / w, P = u + y, D = u + v, O = m + y / P, A = bv / D; si(t.beginPath(), o){ const e = (k + S) / 2; si(t.arc(a, r, d, k, e), t.arc(a, r, d, e, S), _ > 0){ const e = Xn(w, S, a, r); t.arc(ex, ey, _, S, b + E) } const i = Xn(D, b, a, r); si(t.lineTo(ix, iy), v > 0){ const e = Xn(D, A, a, r); t.arc(ex, ey, v, b + E, A + Math.PI) } const s = (bv / u + (m + y / u)) / 2; si(t.arc(a, r, u, bv / u, s, !0), t.arc(a, r, u, s, m + y / u, !0), y > 0){ const e = Xn(P, O, a, r); t.arc(ex, ey, y, O + Math.PI, mE) } const n = Xn(M, m, a, r); si(t.lineTo(nx, ny), x > 0){ const e = Xn(M, k, a, r); t.arc(ex, ey, x, mE, k) } }sin{ t.moveTo(a, r); const e = Math.cos(k) * d + a, i = Math.sin(k) * d + r; t.lineTo(e, i); const s = Math.cos(S) * d + a, n = Math.sin(S) * d + r; t.lineTo(s, n) } t.closePath() }fonction Kn(t, e, i, s, n){ const { fullCircles: o, startAngle: a, circumference: r, options: l } = e, { borderWidth: h, borderJoinStyle: c, borderDash: d, borderDashOffset: u } = l, f = "inner" === l.borderAlign; si(!h)retour; t.setLineDash(d || []), t.lineDashOffset = u, f ? (t.lineWidth = 2 * h, t.lineJoin = c || "round") : (t.lineWidth = h, t.lineJoin = c || "bevel");soit g = e.endAngle; si(o){ qn(t, e, i, s, g, n); pour(soit e = 0; e < o; ++e) t.stroke(); isNaN(r) || (g = a + (r % O || O)) } f && function (t, e, i) { const { startAngle: s, pixelMargin: n, x: o, y: a, outerRadius: r, innerRadius: l } = e; let h = n / r; t.beginPath(), t.arc(o, a, r, sh, i + h), l > n ? (h = n / l, t.arc(o, a, l, i + h, sh, !0)) : t.arc(o, a, n, i + E, sE), t.closePath(), t.clip() }(t, e, g), o || (qn(t, e, i, s, g, n), t.stroke()) } function Gn(t, e, i = e) { t.lineCap = l(i.borderCapStyle, e.borderCapStyle), t.setLineDash(l(i.borderDash, e.borderDash)), t.lineDashOffset = l(i.borderDashOffset, e.borderDashOffset), t.lineJoin = l(i.borderJoinStyle, e.borderJoinStyle), t.lineWidth = l(i.borderWidth, e.borderWidth), t.strokeStyle = l(i.borderColor, e.borderColor) }fonction Zn(t, e, i){ t.lineTo(ix, iy) }fonction Jn(t, e, i = {}){ const s = t.length, { début: n = 0, fin: o = s - 1 } = i, { début: a, fin: r } = e, l = Math.max(n, a), h = Math.min(o, r), c = n < a && o < a || n > r && o > r;retour{ nombre: s, début: l, boucle: e.loop, ilen: h < l && !c ? s + hl : hl } }fonction Qn(t, e, i, s){ const { points: n, options: o } = e, { count: a, start: r, loop: l, ilen: h } = Jn(n, i, s), c = function (t) {retour t.stepped ? Fe : t.tension || "monotone" === t.cubicInterpolationMode ? Ve : Zn }(o); let d, u, f, { move: g = !0, reverse: p } = s || {}; for (d = 0; d <= h; ++d)u = n[(r + (p ? hd : d)) % a], u.skip || (g ? (t.moveTo(ux, uy), g = !1) : c(t, f, u, p, o.stepped), f = u);retour l && (u = n[(r + (p ? h : 0)) % a], c(t, f, u, p, o.stepped)), !!l }fonction to(t, e, i, s){ const n = e.points, { count: o, start: a, ilen: r } = Jn(n, i, s), { move: l = !0, reverse: h } = s || {};soit c, d, u, f, g, p, m = 0, b = 0; const x = t => (a + (h ? rt : t)) % o, _ = () => { f !== g && (t.lineTo(m, g), t.lineTo(m, f), t.lineTo(m, p)) }; for (l && (d = n[x(0)], t.moveTo(dx, dy)), c = 0; c <= r; ++c) { if (d = n[x(c)], d.skip) continue; const e = dx, i = dy, s = 0 | e; s === u ? (i < f ? f = i : i > g && (g = i), m = (b * m + e) / ++b) : (_(), t.lineTo(e, i), u = s, b = 0, f = g = i), p = i } _() }fonction eo(t){ const e = t.options, i = e.borderDash && e.borderDash.length; return !(t._decimated || t._loop || e.tension || "monotone" === e.cubicInterpolationMode || e.stepped || i) ? to : Qn } const io = "function" == typeof Path2D; function so(t, e, i, s) { io && !e.options.segment ? function (t, e, i, s) { let n = e._path; n || (n = e._path = new Path2D, e.path(n, i, s) && n.closePath()), Gn(t, e.options), t.stroke(n) }(t, e, i, s) : function (t, e, i, s) { const { segments: n, options: o } = e, a = eo(e); for (const r de n) Gn(t, o, r.style), t.beginPath(), a(t, e, r, { start: i, end: i + s - 1 }) && t.closePath(), t.stroke()}(t, e, i, s) }classe non étend Hs{static id = "line";static defaults = { borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderWidth: 3, capBezierPoints: !0, cubicInterpolationMode: "default", fill: !1, spanGaps: !1, stepped: !1, tension: 0 };static defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" };static descripteurs = { _scriptable: !0, _indexable: t => "borderDash" !== t && "fill" !== t }; constructeur(t){ super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t) } updateControlPoints(t, e){ const i = this.options; si((i.tension || "monotone" === i.cubicInterpolationMode) && !i.stepped && !this._pointsUpdated){ const s = i.spanGaps ? this._loop : this._fullLoop; hi(this._points, i, t, s, e), this._pointsUpdated = !0 } }définir des points(t){ this._points = t, supprimer this._segments, supprimer this._path, this._pointsUpdated = !1 }obtenir des points(){renvoyer this._points }obtenir des segments(){renvoyer this._segments || (this._segments = zi(this, this.options.segment)) } first(){ const t = this.segments, e = this.points;retour t.length && e[t[0].start] } last(){ const t = this.segments, e = this.points, i = t.length;retour i && e[t[i - 1].end] } interpolate(t, e){ const i = this.options, s = t[e], n = this.points, o = Ii(this, { property: e, start: s, end: s }); if (!o.length) retour; const a = [], r = function (t) {retour t.stepped ? pi : t.tension || "monotone" === t.cubicInterpolationMode ? mi : gi }(i); let l, h; pour(l = 0, h = o.length; l < h; ++l) { const { start: h, end: c } = o[l], d = n[h], u = n[c]; si(d === u){ a.push(d); continue } const f = r(d, u, Math.abs((sd[e]) / (u[e] - d[e])), i.stepped); f[e] = t[e], a.push(f) }retour 1 === a.length ? a[0] : a } pathSegment(t, e, i){retour eo(this)(t, this, e, i) } path(t, e, i){ const s = this.segments, n = eo(this); let o = this._loop; e = e || 0, i = i || this.points.length - e; pour(const a de s) o&=n(t, this, a, { start: e, end: e + i - 1 }); retour!!o } draw(t, e, i, s){ const n = this.options || {}; (this.points || []).length && n.borderWidth && (t.save(), so(t, this, i, s), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0) } }fonction oo(t, e, i, s){ const n = t.options, { [i]: o } = t.getProps([i], s);retour Math.abs(eo) < n.radius + n.hitRadius }fonction ao(t, e){ const { x: i, y: s, base: n, largeur: o, hauteur: a } = t.getProps(["x", "y", "base", "largeur", "hauteur"], e);soit r, l, h, c, d;retour t.horizontal ? (d = a / 2, r = Math.min(i, n), l = Math.max(i, n), h = sd, c = s + d) : (d = o / 2, r = id, l = i + d, h = Math.min(s, n), c = Math.max(s, n)), { gauche: r, haut: h, droite: l, bas: c } }fonction ro(t, e, i, s){retour t ? 0 : J(e, i, s) }fonction lo(t){ const e = ao(t), i = e.droite - e.gauche, s = e.bas - e.haut, n = function (t, e, i) { const s = t.options.borderWidth, n = t.borderSkipped, o = Mi(s);retour{ t: ro(n.haut, o.haut, 0, i), r: ro(n.droite, o.droite, 0, e), b: ro(n.bas, o.bas, 0, i), l: ro(n.gauche, o.gauche, 0, e) } }(t, i / 2, s / 2), a = function (t, e, i) { const { enableBorderRadius: s } = t.getProps(["enableBorderRadius"]), n = t.options.borderRadius, a = wi(n), r = Math.min(e, i), l = t.borderSkipped, h = s || o(n);retour{ hautgauche: ro(!h || l.top || l.gauche, a.topLeft, 0, r), hautdroite: ro(!h || l.top || l.droite, a.topRight, 0, r), basL eft: ro(!h || l.bottom || l.left, a.bottomLeft, 0, r), bottomRight: ro(!h || l.bottom || l.right, a.bottomRight, 0, r) } }(t, i / 2, s / 2);retour{ extérieur: { x: e.left, y: e.top, w: i, h: s, rayon: a }, intérieur: { x: e.left + nl, y: e.top + nt, w:in.ln.r, h: sn.tn.b, ra dius: {en haut à gauche: Math.max(0, a.topLeft - Math.max(nt, nl)), en haut à droite: Math.max(0, a.topRight - Math.max(nt, nr)), en bas à gauche: Math.max(0, a.bottomLeft - Math.max(nb, nl)), en bas à droite: Math.max(0, a.bottomRight - Math.max(nb, nr)) } } } }fonction ho(t, e, i, s){ const n = null === e, o = null === i, a = t && !(n && o) && ao(t, s);retour a && (n || tt(e, a.gauche, a.droite)) && (o || tt(i, a.haut, a.bas)) }fonction co(t, e){ t.rect(ex, ey, ew, eh) }fonction uo(t, e, i = {}){ const s = tx !== ix ? -e : 0, n = ty !== iy ? -e : 0, o = (t.x + tw !== i.x + iw ? e : 0) - s, a = (t.y + th !== i.y + ih ? e : 0) - n;retour{ x: t.x + s, y: t.y + n, w: t.w + o, h: t.h + a, rayon: t.rayon } } var fo = Object.freeze({ __proto__: null, ArcElement: class extends Hs { static id = "arc"; static defaults = { borderAlign: "centre", borderColor: "#fff", borderDash: [], borderDashOffset: 0, borderJoinStyle: void 0, borderRadius: 0, borderWidth: 2, offset: 0, spacing: 0, angle: void 0, circular: !0 }; static defaultRoutes = { backgroundColor: "backgroundColor" }; static descriptors = { _scriptable: !0, _indexable: t => "borderDash" !== t }; circonférence; endAngle; fullCircles; innerRadius; outerRadius; pixelMargin; startAngle; constructor(t) { super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t) } inRange(t, e, i) { const s = this.getProps(["x", "y"], i), { angle: n, distance: o } = X(s, { x: t, y: e }), { startAngle: a, endAngle: r, innerRadius: h, outerRadius: c, circumference: d } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], i), u = (this.options.spacing + this.options.borderWidth) / 2, f = l(d, ra), g = Z(n, a, r) && a !== r, p = f >= O || g, m = tt(o, h + u, c + u);retour p && m } getCenterPoint(t) { const { x: e, y: i, startAngle: s, endAngle: n, innerRadius: o, outerRadius: a } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"], t), { offset: r, spacing: l } = this.options, h = (s + n) / 2, c = (o + a + l + r) / 2;retour{ x: e + Math.cos(h) * c, y: i + Math.sin(h) * c } } tooltipPosition(t) {retour ceci.getCenterPoint(t) } draw(t) { const { options: e, circumference: i } = ceci, s = (e.offset || 0) / 4, n = (e.spacing || 0) / 2, o = e.circular; si(ceci.pixelMargin = "inner" === e.borderAlign ? .33 : 0, ceci.fullCircles = i > O ? Math.floor(i / O) : 0, 0 === i || ceci.innerRadius < 0 || ceci.outerRadius < 0)retour; t.save(); const a = (ceci.startAngle + ceci.endAngle) / 2; t.translate(Math.cos(a) * s, Math.sin(a) * s); const r = s * (1 - Math.sin(Math.min(C, i || 0))); t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor, function (t, e, i, s, n) { const { fullCircles: o, startAngle: a, circumference: r } = e;soit l = e.endAngle; si(o){ qn(t, e, i, s, l, n); pour(soit e = 0; e < o; ++e)t.fill(); isNaN(r) || (l = a + (r % O || O))}qn(t, e, i, s, l, n), t.fill()}(t, this, r, n, o), Kn(t, this, r, n, o), t.restore()}}, BarElement: class étend Hs{static id = "bar";static defaults = { borderSkipped: "start", borderWidth: 0, borderRadius: 0, inflateAmount: "auto", pointStyle: void 0 };static defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" }; constructor(t){ super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t) } draw(t){ const { inflateAmount: e, options: { borderColor: i, backgroundColor: s } } = this, { inner: n, outer: o } = lo(this), a = (r = o.radius).topLeft || r.topRight || r.bottomLeft || r.bottomRight ? He : co; var r; t.save(), ow === nw && o.h === nh || (t.beginPath(), a(t, uo(o, e, n)), t.clip(), a(t, uo(n, -e, o)), t.fillStyle = i, t.fill("evenodd")), t.beginPath(), a(t, uo(n, e)), t.fillStyle = s, t.fill(), t.restore() } inRange(t, e, i){retour ho(this, t, e, i) } inXRange(t, e){retour ho(this, t, null, e) } inYRange(t, e){retour ho(this, null, t, e) } getCenterPoint(t){ const { x: e, y: i, base: s, horizontal: n } = this.getProps(["x", "y", "base", "horizontal"], t);retour{ x: n ? (e + s) / 2 : e, y: n ? i : (i + s) / 2 } } getRange(t){retour"x" === t ? this.width / 2 : this.height / 2 } }, LineElement: non, PointElement:classe étend Hs{static id = "point"; analysé; ignorer; arrêter;statique defaults = { borderWidth: 1, hitRadius: 1, hoverBorderWidth: 1, hoverRadius: 4, pointStyle: "circle", radius: 3, rotation: 0 };static defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" }; constructor(t){ super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t) } inRange(t, e, i){ const s = this.options, { x: n, y: o } = this.getProps(["x", "y"], i); return Math.pow(tn, 2) + Math.pow(eo, 2) < Math.pow(s.hitRadius + s.radius, 2) } inXRange(t, e){ return oo(ceci, t, "x", e) } inYRange(t, e){retour oo(ceci, t, "y", e) } getCenterPoint(t){ const { x: e, y: i } = this.getProps(["x", "y"], t);retour{ x: e, y: i } } taille(t){ let e = (t = t || this.options || {}).radius || 0; e = Math.max(e, e && t.hoverRadius || 0);retour 2 * (e + (e && t.borderWidth || 0)) } dessiner(t, e){ const i = ceci.options; ceci.sauter || i.radius < .1 || !Re(ceci, e, ceci.taille(i) / 2) || (t.strokeStyle = i.borderColor, t.lineWidth = i.borderWidth, t.fillStyle = i.backgroundColor, Le(t, i, ceci.x, ceci.y)) } getRange(){ const t = ceci.options || {};retour t.radius + t.hitRadius } }});fonction go(t, e, i, s){ const n = t.indexOf(e); si(-1 === n)retour((t, e, i, s) => ("string" == typeof e ? (i = t.push(e) - 1, s.unshift({ index: i, label: e })) : isNaN(e) && (i = null), i))(t, e, i, s);retour n !== t.lastIndexOf(e) ? i : n }fonction po(t){ const e = this.getLabels();retour t >= 0 && t < e.length ? e[t] : t }fonction mo(t, e, { horizontal: i, minRotation: s }){ const n = $(s), o = (i ? Math.sin(n) : Math.cos(n)) || .001, a = .75 * e * ("" + t).length;retour Math.min(e / o, a) }classe bo étend Js{ constructeur(t){ super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0 } analyse(t, e){retour s(t) || ("number" == typeof t || t instanceof Number) && !isFinite(+t) ? null : +t } handleTickRangeOptions(){ const { beginAtZero: t } = this.options, { minDefined: e, maxDefined: i } = this.getUserBounds(); let { min: s, max: n } = this; const o = t => s = e ? s : t, a = t => n = i ? n : t; si(t){ const t = F(s), e = F(n); t < 0 && e < 0 ? a(0) : t > 0 && e > 0 && o(0) } si(s === n){ let e = 0 === n ? 1 : Math.abs(.05 * n); a(n + e), t || o(se) } this.min = s, this.max = n } getTickLimit(){ const t = this.options.ticks; let e, { maxTicksLimit: i, stepSize: s } = t; return s ? (e = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, e > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s} générerait jusqu'à ${e} ticks. Limitation à 1000.`), e = 1e3)) : (e = this.computeTickLimit(), i = i || 11), i && (e = Math.min(i, e)), e } computeTickLimit(){ return Number.POSITIF_INFINITÉ } buildTicks(){ const t = this.options, e = t.ticks; let i = this.getTickLimit(); i = Math.max(2, i); const n = function (t, e) { const i = [], { bornes: n, pas: o, min: a, max: r, précision: l, compte: h, maxTicks: c, maxDigits: d, includeBounds: u } = t, f = o || 1, g = c - 1, { min: p, max: m } = e, b = !s(a), x = !s(r), _ = !s(h), y = (mp) / (d + 1); let v, M, w, k, S = B((mp) / g / f) * f; si(S < 1e-14 && !b && !x)retour[{ valeur: p }, { valeur: m }]; k = Math.ceil(m / S) - Math.floor(p / S), k > g && (S = B(k * S / g / f) * f), s(l) || (v = Math.pow(10, l), S = Math.ceil(S * v) / v), "ticks" === n ? (M = Math.floor(p / S) * S, w = Ma th.ceil(m / S) * S): (M = p, w = m), b && x && o && H((ra) / o, S / 1e3) ? (k = Math.round(Math.min((ra) / S, c)), S = (ra) / k, M = a, w = r) : _ ? (M = b ? a : M, w = x ? r : w, k = h - 1, S = (wM) / k) : (k = (wM) / S, k = V(k, Math.round(k), S / 1e3) ? Math.round(k) : Math.ceil(k)); const P = Math.max(U(S), U(M)); v = Math.pow(10, s(l) ? P : l), M = Math.round(M * v) / v, w = Math.round(w * v) / v;soit D = 0; pour(b && (u && M !== a ? (i.push({ valeur: a }), M < a && D++, V(Math.round((M + D * S) * v) / v, a, mo(a, y, t)) && D++) : M < a && D++); D < k; ++D) { const t = Math.round((M + D * S) * v) / v; si(x && t > r)break; i.push({ valeur: t }) }retour x && u && w !== r ? i.length && V(i[i.length - 1].value, r, mo(r, y, t)) ? i[i.length - 1].value = r : i.push({ value: r }) : x && w !== r || i.push({ value: w }), i }({ maxTicks: i, bounds: t.bounds, min: t.min, max: t.max, precision: e.precision, step: e.stepSize, count: e.count, maxDigits: this._maxDigits(), horizontal: t his.isHorizontal(), minRotation: e.minRotation || 0, includeBounds: !1 !== e.includeBounds }, this._range || this); return "ticks" === t.bounds && j(n, this, "value"), t.reverse ? (n.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), n } configure(){ const t = this.ticks; let e = this.min, i = this.max; if (super.configure(), this.options.offset && t.length) { const s = (ie) / Math.max(t.length - 1, 1) / 2; e -= s, i += s } this._startValue = e, this._endValue = i, this._valueRange = ie } getLabelForValue(t){ return ne(t, this.chart.options.locale, this.options.ticks.format) } }classe xo étend bo{static id = "linear";static defaults = { ticks: { callback: ae.formatters.numeric } }; determineDataLimits(){ const { min: t, max: e } = this.getMinMax(!0); this.min = a(t) ? t : 0, this.max = a(e) ? e : 1, this.handleTickRangeOptions() } computeTickLimit(){ const t = this.isHorizontal(), e = t ? this.width : this.height, i = $(this.options.ticks.minRotation), s = (t ? Math.sin(i) : Math.cos(i)) || .001, n = this._resolveTickFontOptions(0);retour Math.ceil(e / Math.min(40, n.lineHeight / s)) } getPixelForValue(t){retour null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange) } getValueForPixel(t){retourner this._startValue + this.getDecimalForPixel(t) * this._valueRange } } const _o = t => Math.floor(z(t)), yo = (t, e) => Math.pow(10, _o(t) + e);fonction vo(t){retourner 1 === t / Math.pow(10, _o(t)) }fonction Mo(t, e, i){ const s = Math.pow(10, i), n = Math.floor(t / s);retourner Math.ceil(e / s) - n }fonction wo(t, { min: e, max: i }){ e = r(t.min, e); const s = [], n = _o(e);soit o = fonction(t, e){soit i = _o(et); pour(; Mo(t, e, i) > 10;) i++; pour(; Mo(t, e, i) < 10;) i--;retour Math.min(i, _o(t)) } (e, i), a = o < 0 ? Math.pow(10, Math.abs(o)) : 1; const l = Math.pow(10, o), h = n > o ? Math.pow(10, n) : 0, c = Math.round((eh) * a) / a, d = Math.floor((eh) / l / 10) * l * 10;soit u = Math.floor((cd) / Math.pow(10, o)), f = r(t.min, Math.round((h + d + u * Math.pow(10, o)) * a) / a); for (; f < i;)s.push({ valeur: f, major: vo(f), significande: u }), u >= 10 ? u = u < 15 ? 15 : 20 : u++, u >= 20 && (o++, u = 2, a = o >= 0 ? 1 : a), f = Math.round((h + d + u * Math.pow(10, o)) * a) / a; const g = r(t.max, f); return s.push({ valeur: g, major: vo(g), significande: u }), s }classe ko étend Js{static id = "logarithmique";static defaults = { ticks: { callback: ae.formatters.logarithmic, major: { enabled: !0 } } }; constructor(t){ super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0 } parse(t, e){ const i = bo.prototype.parse.apply(this, [t, e]); if (0 !== i) return a(i) && i > 0 ? i : null; this._zero = !0 } determineDataLimits(){ const { min: t, max: e } = this.getMinMax(!0); this.min = a(t) ? Math.max(0, t) : null, this.max = a(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !a(this._userMin) && (this.min = t === yo(this.min, 0) ? yo(this.min, -1) : yo(this.min, 0)), this.handleTickRangeOptions() } handleTickRangeOptions(){ const { minDefined: t, maxDefined: e } = this.getUserBounds(); let i = ceci.min, s = ceci.max; const n = e => i = t ? i : e, o = t => s = e ? s : t; i === s && (i <= 0 ? (n(1), o(10)) : (n(yo(i, -1)), o(yo(s, 1)))), i <= 0 && n(yo(s, -1)), s <= 0 && o(yo(i, 1)), this.min = i, this.max = s } buildTicks(){ const t = this.options, e = wo({ min: this._userMin, max: this._userMax }, this);retour"ticks" === t.bounds && j(e, this, "value"), t.reverse ? (e.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), e } getLabelForValue(t){retour void 0 === t ? "0" : ne(t, this.chart.options.locale, this.options.ticks.format) } configure(){ const t = this.min; super.configure(), this._startValue = z(t), this._valueRange = z(this.max) - z(t) } getPixelForValue(t){retour void 0 !== t && 0 !== t || (t = this.min), null === t || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (z(t) - this._startValue) / this._valueRange) } getValueForPixel(t){ const e = this.getDecimalForPixel(t);retour Math.pow(10, this._startValue + e * this._valueRange) } }fonction So(t){ const e = t.ticks; si(e.display && t.display){ const t = ki(e.backdropPadding);retour l(e.font && e.font.size, ue.font.size) + t.height }retour 0 }fonction Po(t, e, i, s, n){retour t === s || t === n ? { start: ei / 2, end: e + i / 2 } : t < s || t > n ? { start: ei, end: e } : { start: e, end: e + i } }fonction Do(t){ const e = { l: t.gauche + t._padding.gauche, r: t.droite - t._padding.droite, t: t.haut + t._padding.haut, b: t.bas - t._padding.bas }, i = Objet.assigner({}, e), s = [], o = [], a = t._pointLabels.longueur, r = t.options.pointLabels, l = r.centerPointLabels ? C / a : 0; pour(soit u = 0; u < a; u++) { const a = r.setContext(t.getPointLabelContext(u)); o[u] = a.padding; const f = t.getPointPosition(u, t.drawingArea + o[u], l), g = Si(a.font), p = (h = t.ctx, c = g, d = n(d = t._pointLabels[u]) ? d : [d], { w: Oe(h, c.string, d), h: d.longueur * c.lineHeight }); s[u] = p; const m = G(t.getIndexAngle(u) + l), b = Math.round(Y(m)); Co(i, e, m, Po(b, fx, pw, 0, 180), Po(b, fy, ph, 90, 270)) } var h, c, d; t.setCenterPoint(el - il, ir - er, et - it, ib - eb), t._pointLabelItems = function (t, e, i) { const s = [], n = t._pointLabels.length, o = t.options, { centerPointLabels: a, display: r } = o.pointLabels, l = { extra: So(o) / 2, additionalAngle: a ? C / n : 0 };soit h; pour(soit o = 0; o < n; o++) { l.padding = i[o], l.size = e[o]; const n = Oo(t, o, l); s.push(n), "auto" === r && (n.visible = Ao(n, h), n.visible && (h = n)) }retour s }(t, s, o) }fonction Co(t, e, i, s, n){ const o = Math.abs(Math.sin(i)), a = Math.abs(Math.cos(i));soit r = 0, l = 0; s.start < el ? (r = (el - s.start) / o, tl = Math.min(tl, el - r)) : s.end > er && (r = (s.end - er) / o, tr = Math.max(tr, e.r + r)), n.start < et ? (l = (et - n.start) / a, tt = Math.min(tt, et - l)) : n.end > eb && (l = (n.end - eb) / a, tb = Math.max(tb, e.b + l)) }fonction Oo(t, e, i){ const s = t.drawingArea, { extra: n, additionalAngle: o, padding: a, size: r } = i, l = t.getPointPosition(e, s + n + a, o), h = Math.round(Y(G(l.angle + E))), c = function (t, e, i) { 90 === i || 270 === i ? t -= e / 2 : (i > 270 || i < 90) && (t -= e);retour t }(ly, rh, h), d = function (t) { if (0 === t || 180 === t)retour"centre"; if (t < 180)retour"gauche";retour"droite" }(h), u = function (t, e, i) { "droite" === i ? t -= e : "centre" === i && (t -= e / 2);retour t }(lx, rw, d);retour{ visible: !0, x: lx, y: c, textAlign: d, gauche: u, haut: c, droite: u + rw, bas: c + rh } }fonction Ao(t, e){ si(!e)retour!0; const { gauche: i, haut: s, droite: n, bas: o } = t; retour!(Re({ x: i, y: s }, e) || Re({ x: i, y: o }, e) || Re({ x: n, y: s }, e) || Re({ x: n, y: o }, e)) }fonction To(t, e, i){ const { gauche: n, haut: o, droite: a, bas: r } = i, { backdropColor: l } = e; si(!s(l)){ const i = wi(e.borderRadius), s = ki(e.backdropPadding); t.fillStyle = l; const h = ns.left, c = os.top, d = a - n + s.width, u = r - o + s.height; Object.values(i).some((t => 0 !== t)) ? (t.beginPath(), He(t, { x: h, y: c, w: d, h: u, radius: i }), t.fill()) : t.fillRect(h, c, d, u) } }fonction Lo(t, e, i, s){ const { ctx: n } = t; si(i)n.arc(t.xCenter, t.yCenter, e, 0, O);sinon{ let i = t.getPointPosition(0, e); n.moveTo(ix, iy); pour(let o = 1; o < s; o++) i = t.getPointPosition(o, e), n.lineTo(ix, iy) } }classe Eo étend bo{static id = "radialLinear";static defaults = { affichage: !0, animate: !0, position: "chartArea", angleLines: { affichage: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 }, grid: { circulaire: !1 }, startAngle: 0, ticks: { showLabelBackdrop: !0, callback: ae.formatters.numeric }, pointLabels: { backdropColor: void 0, backdropPadding: 2, affichage: !0, police: { taille: 10 }, callback: t => t, padding: 5, centerPointLabels: !1 } };static defaultRoutes = { "angleLines.color": "borderColor", "pointLabels.color": "couleur", "ticks.color": "couleur" };static descriptors = { angleLines: { _fallback: "grid" } }; constructor(t){ super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [] } setDimensions(){ const t = this._padding = ki(So(this.options) / 2), e = this.width = this.maxWidth - t.width, i = this.height = this.maxHeight - t.hauteur; this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + i / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, i) / 2) } determineDataLimits(){ const { min: t, max: e } = this.getMinMax(!1); this.min = a(t) && !isNaN(t) ? t : 0, this.max = a(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions() } computeTickLimit(){retour Math.ceil(this.drawingArea / So(this.options)) } generateTickLabels(t){ bo.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map(((t, e) => { const i = d(this.options.pointLabels.callback, [t, e], this); return i || 0 === i ? i : "" })).filter(((t, e) => this.chart.getDataVisibility(e))) } fit(){ const t = this.options; t.display && t.pointLabels.display ? Do(this) : this.setCenterPoint(0, 0, 0, 0) } setCenterPoint(t, e, i, s){ this.xCenter += Math.floor((te) / 2), this.yCenter += Math.floor((is) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, i, s)) } getIndexAngle(t){retour G(t * (O / (this._pointLabels.length || 1)) + $(this.options.startAngle || 0)) } getDistanceFromCenterForValue(t){ si(s(t))retour NaN; const e = this.drawingArea / (this.max - this.min);retour ceci.options.reverse ? (this.max - t) * e : (t - this.min) * e } getValueForDistanceFromCenter(t){ si(s(t))retourner NaN; const e = t / (this.drawingArea / (this.max - this.min));retourner ceci.options.reverse ? this.max - e : this.min + e } getPointLabelContext(t){ const e = this._pointLabels || []; si(t >= 0 && t < e.length){ const i = e[t];retourner function(t, e, i) {retourner Ci(t, { étiquette: i, index: e, type: "pointLabel" }) } (this.getContext(), t, i) } } getPointPosition(t, e, i = 0){ const s = this.getIndexAngle(t) - E + i;retour{ x: Math.cos(s) * e + this.xCenter, y: Math.sin(s) * e + this.yCenter, angle: s } } getPointPositionForValue(t, e){retourne this.getPointPosition(t, this.getDistanceFromCenterForValue(e)) } getBasePosition(t){retourne this.getPointPositionForValue(t || 0, this.getBaseValue()) } getPointLabelPosition(t){ const { gauche: e, haut: i, droite: s, bas: n } = this._pointLabelItems[t];retourne{ gauche: e, haut: i, droite: s, bas: n } } drawBackground(){ const { backgroundColor: t, grid: { circular: e } } = this.options; si(t){ const i = this.ctx; i.save(), i.beginPath(), Lo(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), i.closePath(), i.fillStyle = t, i.fill(), i.restore() } } drawGrid(){ const t = this.ctx, e = this.options, { angleLines: i, grid: s, border: n } = e, o = this._pointLabels.length;soit a, r, l; si(e.pointLabels.display && function (t, e) { const { ctx: i, options: { pointLabels: s } } = t; pour(soit n = e - 1; n >= 0; n--){ const e = t._pointLabelItems[n]; si(!e.visible)continue; const o = s.setContext(t.getPointLabelContext(n)); To(i, o, e); const a = Si(o.font), { x: r, y: l, textAlign: h } = e; Ne(i, t._pointLabels[n], r, l + a.lineHeight / 2, a, { color: o.color, textAlign: h, textBaseline: "middle" }) } } (this, o), s.display && this.ticks.forEach(((t, e) => { if (0 !== e || 0 === e && this.min < 0) { r = this.getDistanceFromCenterForValue(t.value); const i = this.getContext(e), a = s.setContext(i), l = n.setContext(i); !function (t, e, i, s, n) { const o = t.ctx, a = e.circulaire, { couleur: r, largeur de ligne: l } = e; !a && !s || !r || !l || i < 0 || (o.save(), o.strokeStyle = r, o.lineWidth = l, o.setLineDash(n.dash || []), o.lineDashOffset = n.dashOffset, o.beginPath(), Lo(t, i, a, s), o.closePath(), o.stroke(), o.restore()) }(this, a, r, o, l) } })), i.display) { pour(t.save(), a = o - 1; a >= 0; a--) { const s = i.setContext(this.getPointLabelContext(a)), { color: n, lineWidth: o } = s; o && n && (t.lineWidth = o, t.strokeStyle = n, t.setLineDash(s.borderDash), t.lineDashOffset = s.borderDashOffset, r = this.getDistanceFromCenterForValue(e.reverse ? this.min : this.max), l = this.getPointPosition(a, r), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(lx, ly), t.stroke()) } t.restore() } } drawBorder(){ } drawLabels(){ const t = this.ctx, e = this.options, i = e.ticks; if (!i.display) return; const s = this.getIndexAngle(0); let n, o; t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(s), t.textAlign = "centre", t.textBaseline = "milieu", this.ticks.forEach(((s, a) => { si(0 === a && this.min >= 0 && !e.reverse)retour; const r = i.setContext(this.getContext(a)), l = Si(r.font); si(n = this.getDistanceFromCenterForValue(this.ticks[a].value), r.showLabelBackdrop){ t.font = l.string, o = t.measureText(s.label).width, t.fillStyle = r.backdropColor; const e = ki(r.backdropPadding); t.fillRect(-o / 2 - e.left, -nl.size / 2 - e.top, o + e.width, l.size + e.height) } Ne(t, s.label, 0, -n, l, { couleur: r.color, strokeColor: r.textStrokeColor, strokeWidth: r.textStrokeWidth }) })), t.restore() } drawTitle(){ }}const Ro = { milliseconde: { common: !0, size: 1, steps: 1e3 }, seconde: { common: !0, size: 1e3, steps: 60 }, minute: { common: !0, size: 6e4, steps: 60 }, heure: { common: !0, size: 36e5, steps: 24 }, jour: { common: !0, size: 864e5, steps: 30 }, semaine: { common: !1, size: 6048e5, steps: 4 }, mois: { common: !0, size: 2628e6, steps: 12 }, trimestre: { common: !1, size: 7884e6, steps: 4 }, année: { common: !0, size: 3154e7 } }, Io = Object.keys(Ro); function zo(t, e) { return te } function Fo(t, e) { if (s(e)) return null; const i = t._adapter, { analyseur: n, round: o, isoWeekday: r } = t._parseOpts;soit l = e;retour"fonction" == typeof n && (l = n(l)), a(l) || (l = "string" == typeof n ? i.parse(l, n) : i.parse(l)), null === l ? null : (o && (l = "week" !== o || !N(r) && !0 !== r ? i.startOf(l, o) : i.startOf(l, "isoWeek", r)), +l) }fonction Vo(t, e, i, s){ const n = Io.length; pour(soit o = Io.indexOf(t); o < n - 1; ++o) { const t = Ro[Io[o]], n = t.steps ? t.steps : Number.MAX_SAFE_INTEGER; si(t.common && Math.ceil((ie) / (n * t.size)) <= s)retour Io[o] }retour Io[n - 1] }fonction Bo(t, e, i){ si(i){ si(i.length){ const { lo: s, hi: n } = et(i, e); t[i[s] >= e ? i[s] : i[n]] = !0 } }sinon t[e] = !0 }fonction Wo(t, e, i){ const s = [], n = {}, o = e.length;soit a, r; pour(a = 0; a < o; ++a) r = e[a], n[r] = a, s.push({ valeur: r, major: !1 });retour 0 !== o && i ? function (t, e, i, s) { const n = t._adapter, o = +n.startOf(e[0].value, s), a = e[e.length - 1].value; let r, l; for (r = o; r <= a; r = +n.add(r, 1, s))l = i[r], l >= 0 && (e[l].major = !0); return e }(t, s, n, i) : s } class No extends Js { static id = "time"; static defaults = { bounds: "data", adapters: {}, time: { parser: !1, unit: !1, round: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: {} }, ticks: { source: "auto", callback: !1, major: { enabled: !1 } } }; constructor(t) { super(t), this._cache = { data: [], labels: [], all: [] }, this._unit = "jour", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0 } init(t, e = {}) { const i = t.time || (t.time = {}), s = this._adapter = new Rn._date(t.adapters.date); s.init(e), x(i.displayFormats, s.formats()), this._parseOpts = { analyseur: i.parser, round: i.round, isoWeekday: i.isoWeekday }, super.init(t), this._normalized = e.normalized } parse(t, e) {retour void 0 === t ? null : Fo(this, t) } beforeLayout() { super.beforeLayout(), this._cache = { données: [], étiquettes: [], tout: [] } } determineDataLimits() { const t = this.options, e = this._adapter, i = t.time.unit || "jour"; let { min: s, max: n, minDefined: o, maxDefined: r } = this.getUserBounds();fonction l(t){ o || isNaN(t.min) || (s = Math.min(s, t.min)), r || isNaN(t.max) || (n = Math.max(n, t.max)) } o && r || (l(this._getLabelBounds()), "ticks" === t.bounds && "labels" === t.ticks.source || l(this.getMinMax(!1))), s = a(s) && !isNaN(s) ? s : +e.startOf(Date.now(), i), n = a(n) && !isNaN(n) ? n : +e.endOf(Date.now(), i) + 1, this.min = Math.min(s, n - 1), this.max = Math.max(s + 1, n) } _getLabelBounds() { const t = this.getLabelTimestamps(); let e = Nombre.INFINITÉ_POSITIF, i = Nombre.INFINITÉ_NÉGATIVE;retour t.length && (e = t[0], i = t[t.length - 1]), { min: e, max: i } } buildTicks() { const t = this.options, e = t.time, i = t.ticks, s = "labels" === i.source ? this.getLabelTimestamps() : this._generate(); "ticks" === t.bounds && s.length && (this.min = this._userMin || s[0], this.max = this._userMax || s[s.length - 1]); const n = this.min, o = nt(s, n, this.max);retour ceci._unit = e.unit || (i.autoSkip ? Vo(e.minUnit, this.min, this.max, this._getLabelCapacity(n)) : function (t, e, i, s, n) { for (let o = Io.length - 1; o >= Io.indexOf(i); o--) { const i = Io[o]; if (Ro[i].common && t._adapter.diff(n, s, i) >= e - 1) return i } return Io[i ? Io.indexOf(i) : 0] }(this, o.length, e.minUnit, this.min, this.max)), this._majorUnit = i.major.enabled && "year" !== this._unit ? function (t ...e = Io.indexOf(t) + 1, i = Io.length; e<i;++e) si(Ro[Io[e]].common)retour Io[e] }(this._unit): void 0, this.initOffsets(s), t.reverse && o.reverse(), Wo(this, o, this._majorUnit)}afterAutoSkip(){ this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t => +t.value))) } initOffsets(t = []){ let e, i, s = 0, n = 0; this.options.offset && t.length && (e = this.getDecimalForValue(t[0]), s = 1 === t.length ? 1 - e : (this.getDecimalForValue(t[1]) - e) / 2, i = this.getDecimalForValue(t[t.length - 1]), n = 1 === t.length ? i : (i - this.getDecimalForValue(t[t.length - 2])) / 2); const o = t.length < 3 ? .5 : .25; s = J(s, 0, o), n = J(n, 0, o), this._offsets = { début: s, fin: n, facteur: 1 / (s + 1 + n) } } _generate(){ const t = cet._adaptateur, e = cet.min, i = cet.max, s = cet.options, n = s.time, o = n.unit || Vo(n.minUnit, e, i, cet._getLabelCapacity(e)), a = l(s.ticks.stepSize, 1), r = "week" === o && n.isoWeekday, h = N(r) || !0 === r, c = {}; let d, u, f = e; if (h && (f = +t.startOf(f, "isoWeek", r)), f = +t.startOf(f, h ? "day" : o), t.diff(i, e, o) > 1e5 * a) throw new Error(e + " et " + i + " sont trop éloignés avec un stepSize de " + a + " " + o); const g = "data" === s.ticks.source && this.getDataTimestamps(); for (d = f, u = 0; d < i; d = +t.add(d, a, o), u++)Bo(c, d, g); return d !== i && "ticks" !== s.bounds && 1 !== u || Bo(c, d, g), Object.keys(c).sort(zo).map((t => +t)) } getLabelForValue(t){ const e = this._adapter, i = this.options.time; return i.tooltipFormat ? e.format(t, i.tooltipFormat) : e.format(t, i.displayFormats.datetime) } format(t, e){ const i = this.options.time.displayFormats, s = this._unit, n = e || i[s];retourne this._adapter.format(t, n) } _tickFormatFunction(t, e, i, s){ const n = this.options, o = n.ticks.callback; si(o)retourne d(o, [t, e, i], this); const a = n.time.displayFormats, r = this._unit, l = this._majorUnit, h = r && a[r], c = l && a[l], u = i[e], f = l && c && u && u.major;retourne this._adapter.format(t, s || (f ? c : h)) } generateTickLabels(t){ let e, i, s; pour(e = 0, i = t.length; e < i; ++e) s = t[e], s.label = this._tickFormatFunction(s.value, e, t) } getDecimalForValue(t){retourner null === t ? NaN : (t - this.min) / (this.max - this.min) } getPixelForValue(t){ const e = this._offsets, i = this.getDecimalForValue(t);retourner this.getPixelForDecimal((e.start + i) * e.factor) } getValueForPixel(t){ const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end;retourner this.min + i * (this.max - this.min) } _getLabelSize(t){ const e = this.options.ticks, i = this.ctx.measureText(t).width, s = $(this.isHorizontal() ? e.maxRotation : e.minRotation), n = Math.cos(s), o = Math.sin(s), a = this._resolveTickFontOptions(0).size;retour{ w: i * n + a * o, h: i * o + a * n } } _getLabelCapacity(t){ const e = this.options.time, i = e.displayFormats, s = i[e.unit] || i.millisecond, n = this._tickFormatFunction(t, 0, Wo(this, [t], this._majorUnit), s), o = this._getLabelSize(n), a = Math.floor(this.isHorizontal() ? this.width / ow : this.height / oh) - 1;retour a > 0 ? a : 1 } getDataTimestamps(){soit t, e, i = this._cache.data || []; si(i.length)retourner i; const s = this.getMatchingVisibleMetas(); si(this._normalized && s.length)retourner this._cache.data = s[0].controller.getAllParsedValues(this); pour(t = 0, e = s.length; t < e; ++t) i = i.concat(s[t].controller.getAllParsedValues(this));retourner this._cache.data = this.normalize(i) } getLabelTimestamps(){ const t = this._cache.labels || [];soit e, i; si(t.length)retourner t; const s = this.getLabels(); for (e = 0, i = s.length; e < i; ++e)t.push(Fo(this, s[e]));retour this._cache.labels = this._normalized ? t : this.normalize(t) } normalize(t){retour lt(t.sort(zo)) }}fonction Ho(t, e, i){ let s, n, o, a, r = 0, l = t.length - 1; i ? (e >= t[r].pos && e <= t[l].pos && ({ lo: r, hi: l } = it(t, "pos", e)), ({ pos: s, time: o } = t[r]), ({ pos: n, time: a } = t[l])) : (e >= t[r].time && e <= t[l].time && ({ lo: r, hi: l } = it(t, "time", e)), ({ time: s, pos: o } = t[r]), ({ time: n, pos: a } = t[l])); const h = ns; return h ? o + (ao) * (es) / h : o } var jo = Object.freeze({ __proto__: null, CategoryScale: class extends Js { static id = "category"; static defaults = { ticks: { callback: po } }; constructeur(t) { super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [] } init(t) { const e = this._addedLabels; si(e.length){ const t = this.getLabels(); pour(const { index: i, label: s }de e)t[i]=== s && t.splice(i, 1); this._addedLabels = []}super.init(t)}parse(t, e){ si(s(t))retourne null; const i = this.getLabels(); return ((t, e) => null === t ? null : J(Math.round(t), 0, e))(e = isFinite(e) && i[e] === t ? e : go(i, t, l(e, t), this._addedLabels), i.length - 1) } determineDataLimits(){ const { minDefined: t, maxDefined: e } = this.getUserBounds(); let { min: i, max: s } = this.getMinMax(!0); "ticks" === this.options.bounds && (t || (i = 0), e || (s = this.getLabels().length - 1)), this.min = i, this.max = s } buildTicks(){ const t = this.min, e = this.max, i = this.options.offset, s = []; let n = this.getLabels(); n = 0 === t && e === n.length - 1 ? n : n.slice(t, e + 1), this._valueRange = Math.max(n.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? .5 : 0); for (let i = t; i <= e; i++)s.push({ value: i }); return s } getLabelForValue(t){ return po.call(this, t) } configure(){ super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels) } getPixelForValue(t){ return "number" != typeof t && (t = this.parse(t)), null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange) } getPixelForTick(t){ const e = this.ticks; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value) } getValueForPixel(t){ return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange) } getBasePixel(){ return this.bottom }}, LinearScale: xo, LogarithmicScale: ko, RadialLinearScale: Eo, TimeScale: Non, TimeSeriesScale: class extends Non { static id = "timeseries"; static defaults = No.defaults; constructor(t) { super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0 } initOffsets() { const t = this._getTimestampsForTable(), e = this._table = this.buildLookupTable(t); this._minPos = Ho(e, this.min), this._tableRange = Ho(e, this.max) - this._minPos, super.initOffsets(t) } buildLookupTable(t) { const { min: e, max: i } = this, s = [], n = []; let o, a, r, l, h; pour(o = 0, a = t.length; o < a; ++o) l = t[o], l >= e && l <= i && s.push(l); si(s.length < 2)retour[{ temps: e, pos: 0 }, { temps: i, pos: 1 }]; pour(o = 0, a = s.length; o < a; ++o) h = s[o + 1], r = s[o - 1], l = s[o], Math.round((h + r) / 2) !== l && n.push({ temps: l, pos: o / (a - 1) });retour n } _generate() { const t = this.min, e = this.max; let i = super.getDataTimestamps();retour i.includes(t) && i.length || i.splice(0, 0, t), i.includes(e) && 1 !== i.length || i.push(e), i.sort(((t, e) => te)) } _getTimestampsForTable() { let t = this._cache.all || []; if (t.length) return t; const e = this.getDataTimestamps(), i = this.getLabelTimestamps(); return t = e.length && i.length ? this.normalize(e.concat(i)) : e.length ? e : i, t = this._cache.all = t, t } getDecimalForValue(t) { return (Ho(this._table, t) - this._minPos) / this._tableRange } getValueForPixel(t) { const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end;retour Ho(this._table, i * this._tableRange + this._minPos, !0) } }}); const $o = ["rgb(54, 162, 235)", "rgb(255, 99, 132)", "rgb(255, 159, 64)", "rgb(255, 205, 86)", "rgb(75, 192, 192)", "rgb(153, 102, 255)", "rgb(201, 203, 207)"], Yo = $o.map((t => t.replace("rgb(", "rgba(").replace(")", ", 0.5)")));fonction Uo(t){retour $o[t % $o.length] }fonction Xo(t){retour Yo[t % Yo.length] }fonction qo(t){ let e = 0; retour(i, s)=> { const n = t.getDatasetMeta(s).controller; n instanceof jn ? e = function (t, e) {retour t.backgroundColor = t.data.map((() => Uo(e++))), e }(i, e) : n instanceof $n ? e = function (t, e) {retour t.backgroundColor = t.data.map((() => Xo(e++))), e }(i, e) : n && (e = function (t, e) {retour t.borderColor = Uo(e), t.backgroundColor = Xo(e), ++e }(i, e)) } }fonction Ko(t){ let e; for (e in t) if (t[e].borderColor || t[e].backgroundColor) retour!0; retour!1 } var Go = { id: "colors", defaults: { enabled: !0, forceOverride: !1 }, beforeLayout(t, e, i) { if (!i.enabled) return; const { data: { datasets: s }, options: n } = t.config, { elements: o } = n, a = Ko(s) || (r = n) && (r.borderColor || r.backgroundColor) || o && Ko(o) || "rgba(0,0,0,0.1)" !== ue.borderColor || "rgba(0,0,0,0.1)" !== ue.backgroundColor; var r; if (!i.forceOverride && a) return; const l = qo(t); s.forEach(l) } }; function Zo(t) { if (t._decimated) { const e = t._data; delete t._decimated, supprimer t._data, Object.defineProperty(t, "data", { configurable: !0, enumerable: !0, writable: !0, value: e }) } }fonction Jo(t){ t.data.datasets.forEach((t => { Zo(t) })) } var Qo = { id: "decimation", defaults: { algorithme: "min-max", activé: !1 }, beforeElementsUpdate: (t, e, i) => { si(!i.activé)retour void Jo(t); const n = t.width; t.data.datasets.forEach(((e, o) => { const { _data: a, indexAxis: r } = e, l = t.getDatasetMeta(o), h = a || e.data; si("y" === Pi([r, t.options.indexAxis]))retour; si(!l.controller.supportsDecimation)retour; const c = t.scales[l.xAxisID]; si("linear" !== c.type && "time" !== c.type)retour; si(t.options.parsing)retour; let { start: d, count: u } = function (t, e) { const i = e.length; let s, n = 0; const { iScale: o } = t, { min: a, max: r, minDefined: l, maxDefined: h } = o.getUserBounds();retour l && (n = J(it(e, o.axis, a).lo, 0, i - 1)), s = h ? J(it(e, o.axis, r).hi + 1, n, i) - n :in, { début: n, compte: s } }(l, h); si(u <= (i.threshold || 4 * n))retour void Zo(e); let f; switch (s(a) && (e._data = h, delete e.data, Object.defineProperty(e, "data", { configurable: !0, enumerable: !0, get: function () {retour ceci._décimé }, set: function (t) { this._data = t } })), i.algorithm) { case "lttb": f = function (t, e, i, s, n) { const o = n.samples || s; si(o >= i)retourne t.slice(e, e + i); const a = [], r = (i - 2) / (o - 2);soit l = 0; const h = e + i - 1;soit c, d, u, f, g, p = e; pour(a[l++] = t[p], c = 0; c < o - 2; c++){ soit s, n=0, o=0; const h = Math.floor((c + 1) * r) + 1 + e, m=Math.min(Math.floor((c + 2) * r) + 1, i) + e, b=mh; pour(s = h;s<m;s++)n += t[s].x, o += t[s].y; n /= b, o /= b; const x = Math.floor(c * r) + 1 + e, _ = Math.min(Math.floor((c + 1) * r) + 1, i) + e, { x: y, y: v } = t[p]; pour(u = f = -1, s = x; s < _; s++) f = .5 * Math.abs((yn) * (t[s].yv) - (yt[s].x) * (ov)), f > u && (u = f, d = t[s], g = s); a[l++] = d, p = g }retourner a[l++]= t[h], a }(h, d, u, n, i); pause;case "min-max": f = fonction(t, e, i, n){soit o, a, r, l, h, c, d, u, f, g, p = 0, m = 0; const b = [], x = e + i - 1, _ = t[e].x, y = t[x].x - _; pour(o = e; o < e + i; ++o) { a = t[o], r = (ax - _) / y * n, l = ay; const e = 0 | r; si(e === h)l < f ? (f = l, c = o) : l > g && (g = l, d = o), p = (m * p + ax) / ++m;sinon{ const i = o - 1; si(!s(c) && !s(d)){ const e = Math.min(c, d), s = Math.max(c, d); e !== u && e !== i && b.push({ ...t[e], x: p }), s !== u && s !== i && b.push({ ...t[s], x: p }) } o > 0 && i !== u && b.push(t[i]), b.push(a), h = e, m = 0, f = g = l, c = d = u = o } }retour b } (h, d, u, n); pause;par défaut: throw new Error(`Algorithme de décimation non pris en charge '${i.algorithm}'`)}e._decimated = f}))}, destroy(t){ Jo(t) }};fonction ta(t, e, i, s){ si(s)retour; let n = e[t], o = i[t];retour"angle" === t && (n = G(n), o = G(o)), { property: t, start: n, end: o } }fonction ea(t, e, i){ for (; e > t; e--) { const t = i[e]; if (!isNaN(tx) && !isNaN(ty)) break }retour e }fonction ia(t, e, i, s){retour t && e ? s(t[i], e[i]) : t ? t[i] : e ? e[i] : 0 }fonction sa(t, e){ let i = [], s = !1;retour n(t) ? (s = !0, i = t) : i = function (t, e) { const { x: i = null, y: s = null } = t || {}, n = e.points, o = [];retour e.segments.forEach((({ start: t, end: e }) => { e = ea(t, e, n); const a = n[t], r = n[e]; null !== s ? (o.push({ x: ax, y: s }), o.push({ x: rx, y: s })) : null !== i && (o.push({ x: i, y: ay }), o.push({ x: i, y: ry })) })), o }(t, e), i.length ? new no({ points: i, options: { tension: 0 }, _loop: s, _fullLoop: s }) : null }fonction na(t){retour t && !1 !== t.fill }fonction oa(t, e, i){ let s = t[e].fill; const n = [e]; let o; if (!i)retour s; for (; !1 !== s && -1 === n.indexOf(s);) { si(!a(s))retour s; si(o = t[s], !o)retour!1; si(o.visible)retour s; n.push(s), s = o.fill } retour!1 }fonction aa(t, e, i){ const s = function (t) { const e = t.options, i = e.fill; let s = l(i && i.target, i); void 0 === s && (s = !!e.backgroundColor); si(!1 === s || null === s)retour!1; si(!0 === s)retour"origine";retour s }(t); si(o(s))retour!isNaN(s.value) && s; let n = parseFloat(s);retour a(n) && Math.floor(n) === n ? function (t, e, i, s) { "-" !== t && "+" !== t || (i = e + i); si(i === e || i < 0 || i >= s)retour!1;retour i }(s[0], e, n, i) : ["origine", "début", "fin", "pile", "forme"].indexOf(s) >= 0 && s }fonction ra(t, e, i){ const s = []; pour(soit n = 0; n < i.length; n++) { const o = i[n], { premier: a, dernier: r, point: l } = la(o, e, "x"); si(!(!l || a && r))si(a)s.unshift(l);sinon si(t.push(l), !r)break } t.push(...s) }fonction la(t, e, i){ const s = t.interpolate(e, i); si(!s)retour{ }; const n = s[i], o = t.segments, a = t.points;soit r = !1, l = !1; pour(soit t = 0; t < o.length; t++) { const e = o[t], s = a[e.start][i], h = a[e.end][i]; si(tt(n, s, h)){ r = n === s, l = n === h; pause } }retour{ premier: r, dernier: l, point: s } }classe ha{ constructeur(t){ this.x = tx, this.y = ty, this.radius = t.radius } pathSegment(t, e, i){ const { x: s, y: n, radius: o } = this;retour e = e || { début: 0, fin: O }, t.arc(s, n, o, e.end, e.start, !0), !i.bounds } interpolate(t){ const { x: e, y: i, radius: s } = this, n = t.angle;retour{ x: e + Math.cos(n) * s, y: i + Math.sin(n) * s, angle: n } } }fonction ca(t){ const { graphique: e, remplissage: i, ligne: s } = t; si(a(i))retour fonction(t, e){ const i = t.getDatasetMeta(e), s = i && t.isDatasetVisible(e);retour s ? i.dataset : null } (e, i); si("stack" === i)retourner function(t) { const { scale: e, index: i, line: s } = t, n = [], o = s.segments, a = s.points, r = function (t, e) { const i = [], s = t.getMatchingVisibleMetas("line"); pour(soit t = 0; t < s.length; t++) { const n = s[t]; si(n.index === e)break; n.hidden || i.unshift(n.dataset) }retourner i }(e, i); r.push(sa({ x: null, y: e.bottom }, s)); pour(soit t = 0; t < o.length; t++) { const e = o[t]; pour(soit t = e.start; t <= e.end; t++) ra(n, a[t], r) }retourner nouveau no({ points: n, options: {} }) } (t); si("forme" === i)retour!0; const n = function (t) { const e = t.scale || {}; si(e.getPointPositionForValue)retour function(t) { const { scale: e, fill: i } = t, s = e.options, n = e.getLabels().length, a = s.reverse ? e.max : e.min, r = function (t, e, i) { let s;retour s = "start" === t ? i : "end" === t ? e.options.reverse ? e.min : e.max : o(t) ? t.value : e.getBaseValue(), s }(i, e, a), l = []; si(s.grid.circular){ const t = e.getPointPositionForValue(0, a);retour nouveau ha({ x: tx, y: ty, radius: e.getDistanceFromCenterForValue(r) }) } pour(soit t = 0; t < n; ++t) l.push(e.getPointPositionForValue(t, r));retour l } (t);retour function(t) { const { scale: e = {}, fill: i } = t, s = function (t, e) { let i = null;retour"start" === t ? i = e.bottom : "end" === t ? i = e.top : o(t) ? i = e.getPixelForValue(t.value) : e.getBasePixel && (i = e.getBasePixel()), i }(i, e); si(a(s)){ const t = e.isHorizontal();retour{ x: t ? s : null, y: t ? null : s } }retour null } (t) }(t);retourne n instanceof ha ? n : sa(n, s) } function da(t, e, i) { const s = ca(e), { line: n, scale: o, axis: a } = e, r = n.options, l = r.fill, h = r.backgroundColor, { above: c = h, below: d = h } = l || {}; s && n.points.length && (Ie(t, i), function (t, e) { const { line: i, target: s, above: n, below: o, area: a, scale: r } = e, l = i._loop ? "angle" : e.axis; t.save(), "x" === l && o! == n && (ua(t, s, a.top), fa(t, { ligne: i, cible: s, couleur: n, échelle: r, propriété: l }), t.restore(), t.save(), ua(t, s, a.bottom)); fa(t, { ligne: i, cible: s, couleur: o, échelle: r, propriété: l }), t.restore() }(t, { ligne: n, cible: s, au- dessus: c, en - dessous: d, aire: i, échelle: o, axe: a}), ze(t))}fonction ua(t, e, i){ const { segments: s, points: n } = e;soit o = !0, a = !1; t.beginPath(); for (const r de s) { const{ début: s, fin: l } = r, h = n[s], c = n[ea(s, l, n)]; o ? (t.moveTo(hx, hy), o = !1) : (t.lineTo(hx, i), t.lineTo(hx, hy)), a = !!e.pathSegment(t, r, { déplacer: a }), a ? t.closePath() : t.lineTo(cx, i)} t.lineTo(e.first().x, i), t.closePath(), t.clip()}fonction fa(t, e){ const { ligne: i, cible: s, propriété: n, couleur: o, échelle: a } = e, r = fonction(t, e, i){ const s = t.segments, n = t.points, o = e.points, a = []; pour(const t de s) { let{ start: s, end: r } = t; r = ea(s, r, n); const l = ta(i, n[s], n[r], t.loop); si(!e.segments){ a.push({ source: t, cible: l, début: n[s], fin: n[r] }); continuer } const h = Ii(e, l); pour(const e de h) { const s = ta(i, o[e.start], o[e.end], e.loop), r = Ri(t, n, s); pour(const t de r) a.push({ source: t, target: e, start: { [i]: ia(l, s, "start", Math.max) }, end: { [i]: ia(l, s, "end", Math.min) } }) }}retourner a}(i, s, n); pour(const { source: e, target: l, start: h, end: c }de r) { const{ style: { backgroundColor: r = o } = {} } = e, d = !0 !== s; t.save(), t.fillStyle = r, ga(t, a, d && ta(n, h, c)), t.beginPath(); const u = !!i.pathSegment(t, e); let f; si(d){ u ? t.closePath() : pa(t, s, c, n); const e = !!s.pathSegment(t, l, { move: u, reverse: !0 }); f = u && e, f || pa(t, s, h, n) } t.closePath(), t.fill(f ? "evenodd" : "non nul"), t.restore()}}fonction ga(t, e, i){ const { haut: s, bas: n } = e.chart.chartArea, { propriété: o, début: a, fin: r } = i || {}; "x" === o && (t.beginPath(), t.rect(a, s, ra, ns), t.clip()) }fonction pa(t, e, i, s){ const n = e.interpolate(i, s); n && t.lineTo(nx, ny) } var ma = { id: "filler", afterDatasetsUpdate(t, e, i) { const s = (t.data.datasets || []).length, n = []; let o, a, r, l; for (a = 0; a < s; ++a)o = t.getDatasetMeta(a), r = o.dataset, l = null, r && r.options && r instanceof no && (l = { visible: t.isDatasetVisible(a), index: a, fill: aa(r, a, s), chart: t, axis: o.controller.options.indexAxis, scale: o.vScale, line: r }), o.$filler = l, n.push(l); for (a = 0; a < s; ++a)l = n[a], l && !1 !== l.fill && (l.fill = oa(n, a, i.propagate)) }, beforeDraw(t, e, i) { const s = "avantDraw" === i.drawTime, n = t.getSortedVisibleDatasetMetas(), o = t.chartArea; pour(soit e = n.length - 1; e >= 0; --e) { const i = n[e].$ filler; i & & (i.line.updateControlPoints(o, i.axis), s & & i.fill & & da(t.ctx, i, o)) } }, avantDatasetsDraw(t, e, i) { si("avantDatasetsDraw"! == i.drawTime) retour; const s = t.getSortedVisibleDatasetMetas(); pour(soit e = s.length - 1; e >= 0; --e) { const i = s[e].$filler; na(i) && da(t.ctx, i, t.chartArea) } }, beforeDatasetDraw(t, e, i) { const s = e.meta.$filler; na(s) && "beforeDatasetDraw" === i.drawTime && da(t.ctx, s, t.chartArea) }, defaults: { propagate: !0, drawTime: "beforeDatasetDraw" } }; const ba = (t, e) => { let { boxHeight: i = e, boxWidth: s = e } = t; return t.usePointStyle && (i = Math.min(i, e), s = t.pointStyleWidth || Math.min(s, e)), { boxWidth: s, boxHeight: i, itemHeight: Math.max(e, i) } };classe xa étend Hs{ constructor(t){ super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(t, e, i){ this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit() } setDimensions(){ this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height) } buildLabels(){ const t = this.options.labels || {}; let e = d(t.generateLabels, [this.chart], this) || []; t.filter && (e = e.filter((e => t.filter(e, this.chart.data)))), t.sort && (e = e.sort(((e, i) => t.sort(e, i, this.chart.data)))), this.options.reverse && e.reverse(), this.legendItems = e } fit(){ const { options: t, ctx: e } = this; if (!t.display) return void (this.width = this.height = 0); const i = t.labels, s = Si(i.font), n = s.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: r } = ba(i, n);soit l, h; e.font = s.string, this.isHorizontal() ? (l = this.maxWidth, h = this._fitRows(o, n, a, r) + 10) : (h = this.maxHeight, l = this._fitCols(o, s, a, r) + 10), this.width = Math.min(l, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight) } _fitRows(t, e, i, s){ const { ctx: n, maxWidth: o, options: { labels: { padding: a } } } = this, r = this.legendHitBoxes = [], l = this.lineWidths = [0], h = s + a;soit c = t; n.textAlign = "gauche", n.textBaseline = "milieu"; let d = -1, u = -h;retourne this.legendItems.forEach(((t, f) => { const g = i + e / 2 + n.measureText(t.text).width; (0 === f || l[l.length - 1] + g + 2 * a > o) && (c += h, l[l.length - (f > 0 ? 0 : 1)] = 0, u += h, d++), r[f] = { gauche: 0, haut: u, ligne: d, largeur: g, hauteur: s }, l[l.length - 1] += g + a })), c } _fitCols(t, e, i, s){ const { ctx: n, maxHeight: o, options: { étiquettes: { rembourrage: a } } } = this, r = this.legendHitBoxes = [], l = this.columnSizes = [], h = ot;soit c = a, d = 0, u = 0, f = 0, g = 0;retour this.legendItems.forEach(((t, o) => { const { itemWidth: p, itemHeight: m } = function (t, e, i, s, n) { const o = function (t, e, i, s) { let n = t.text; n && "string" != typeof n && (n = n.reduce(((t, e) => t.length > e.length ? t : e)));retour e + i.size / 2 + s.measureText(n).width }(s, t, e, i), a = function (t, e, i) { let s = t; "string" != typeof e.text && (s = _a(e, i));retour s }(n, s, e.lineHeight);retour{largeur de l'élément :o, hauteur de l'élément: a } }(i, e, n, t, s); o > 0 && u + m + 2 * a > h && (c += d + a, l.push({ largeur: d, hauteur: u }), f += d + a, g++, d = u = 0), r[o] = { gauche: f, haut: u, col: g, largeur: p, hauteur: m }, d = Math.max(d, p), u += m + a })), c += d, l.push({ largeur: d, hauteur: u }), c } adjustHitBoxes(){ if (!this.options.display) retour; const t = this._computeTitleHeight(), { legendHitBoxes: e, options: { align: i, labels: { padding: s }, rtl: n } } = this, o = Oi(n, this.left, this.width); si(this.isHorizontal()){ let n = 0, a = ft(i, this.left + s, this.right - this.lineWidths[n]); pour(const r de e) n!== r.row && (n = r.row, a = ft(i, this.left + s, this.right - this.lineWidths[n])), r.top += this.top + t + s, r.left = o.leftForLtr(ox(a), r.width), a += r.width + s }sinon{ let n = 0, a = ft(i, this.top + t + s, this.bottom - this.columnSizes[n].height); for (const r de e) r.col!== n && (n = r.col, a = ft(i, this.top + t + s, this.bottom - this.columnSizes[n].height)), r.top = a, r.left += this.left + s, r.left = o.leftForLtr(ox(r.left), r.width), a += r.height + s} } estHorizontal(){ return "top" === this.options.position || "bottom" === this.options.position } draw(){ if (this.options.display) { const t = ceci.ctx; Ie(t, ceci), ceci._draw(), ze(t) } } _draw(){ const { options: t, columnSizes: e, lineWidths: i, ctx: s } = ceci, { align: n, labels: o } = t, a = ue.color, r = Oi(t.rtl, this.left, this.width), h = Si(o.font), { padding: c } = o, d = h.size, u = d / 2; let f; this.drawTitle(), s.textAlign = r.textAlign("gauche"), s.textBaseline = "milieu", s.lineWidth = .5, s.font = h.string; const { boxWidth: g, boxHeight: p, itemHeight: m } = ba(o, d), b = this.isHorizontal(), x = this._computeTitleHeight(); f = b ? { x: ft(n, this.left + c, this.right - i[0]), y: this.top + c + x, line: 0 } : { x: this.left + c, y: ft(n, this.top + x + c, this.bottom - e[0].height), line: 0 }, Ai(this.ctx, t.textDirection); const _ = m + c; this.legendItems.forEach(((y, v) => { s.strokeStyle = y.fontColor, s.fillStyle = y.fontColor; const M = s.measureText(y.text).width, w = r.textAlign(y.textAlign || (y.textAlign = o.textAlign)), k = g + u + M; let S = fx, P = fy; r.setWidth(this.width), b ? v > 0 && S + k + c > this.right && (P = f.y += _, f.line++, S = fx = ft(n, this.left + c, this.right - i[f.line])) : v > 0 && P + _ > this.bottom && (S = fx = S + e[f.line].width + c, f.line++, P = fy = ft(n, this.top + x + c, this.bottom - e[f.line].height)); si(fonction(t, e, i){ si(isNaN(g) || g <= 0 || isNaN(p) || p < 0)retour; s.save(); const n = l(i.lineWidth, 1); si(s.fillStyle = l(i.fillStyle, a), s.lineCap = l(i.lineCap, "butt"), s.lineDashOffset = l(i.lineDashOffset, 0), s.lineJoin = l(i.lineJoin, "mitre"), s.lineWidth = n, s.strokeStyle = l(i.strokeStyle, a), s.setLineDash(l(i.lineDash, [])), o.usePointStyle){ const a = { rayon: p * Math.SQRT2 / 2, pointStyle: i.pointStyle, rotation: i.rotation, borderWidth: n }, l = r.xPlus(t, g / 2); Ee(s, a, l, e + u, o.pointStyleWidth && g) }sinon{ const o = e + Math.max((dp) / 2, 0), a = r.leftForLtr(t, g), l = wi(i.borderRadius); s.beginPath(), Object.values(l).some((t => 0 !== t)) ? He(s, { x: a, y: o, w: g, h: p, radius: l }) : s.rect(a, o, g, p), s.fill(), 0 !== n && s.stroke() } s.restore() }(rx(S), P, y), S = gt(w, S + g + u, b ? S + k : this.right, t.rtl), function (t, e, i) { Ne(s, i.text, t, e + m / 2, h, { strikethrough: i.hidden, textAlign: r.textAlign(i.textAlign) }) }(rx(S), P, y), b)f.x += k + c;else si("string" != typeof y.text){ const t = h.lineHeight; f.y += _a(y, t) + c }sinon f.y += _ })), Ti(this.ctx, t.textDirection) } drawTitle(){ const t = this.options, e = t.title, i = Si(e.font), s = ki(e.padding); si(!e.display)retour; const n = Oi(t.rtl, this.left, this.width), o = this.ctx, a = e.position, r = i.size / 2, l = s.top + r;soit h, c = this.left, d = this.width; si(this.isHorizontal())d = Math.max(...this.lineWidths), h = this.top + l, c = ft(t.align, c, this.right - d);sinon{ const e = this.columnSizes.reduce(((t, e) => Math.max(t, e.height)), 0); h = l + ft(t.align, this.top, this.bottom - et.labels.padding - this._computeTitleHeight()) } const u = ft(a, c, c + d); o.textAlign = n.textAlign(ut(a)), o.textBaseline = "middle", o.strokeStyle = e.color, o.fillStyle = e.color, o.font = i.string, Ne(o, e.text, u, h, i) } _computeTitleHeight(){ const t = this.options.title, e = Si(t.font), i = ki(t.padding); return t.display ? e.lineHeight + i.height : 0 } _getLegendItemAt(t, e){ let i, s, n; si(tt(t, ceci.gauche, ceci.droite) && tt(e, ceci.haut, ceci.bas)) pour(n = ceci.légende HitBoxes, i = 0; i < n.longueur; ++i) si(s = n[i], tt(t, s.gauche, s.gauche + s.largeur) && tt(e, s.haut, s.haut + s.hauteur)) renvoie ceci.légendeItems[i]; renvoie null } handleEvent(t) { const e = ceci.options; si(!fonction(t, e) { si(("mousemove" === t || "mouseout" === t) && (e.onHover || e.onLeave)) renvoie! 0; si(e.onClick && ("click" === t || "mouseup" === t)) renvoie! 0; renvoie! 1 } (t.type, e)) renvoie; const i = this._getLegendItemAt(tx, ty); si("mousemove" === t.type || "mouseout" === t.type){ const o = this._hoveredItem, a = (n = i, null !== (s = o) && null !== n && s.datasetIndex === n.datasetIndex && s.index === n.index); o && !a && d(e.onLeave, [t, o, this], this), this._hoveredItem = i, i && !a && d(e.onHover, [t, i, this], this) }else i && d(e.onClick, [t, i, this], this); var s, n}}function _a(t, e) { return e * (t.text ? t.text.length : 0) } var ya = { id: "légende", _element: xa, start(t, e, i) { const s = t.legend = nouveau xa({ ctx: t.ctx, options: i, graphique: t }); as.configure(t, s, i), as.addBox(t, s) }, stop(t) { as.removeBox(t, t.legend), supprimer t.legend }, beforeUpdate(t, e, i) { const s = t.legend; as.configure(t, s, i), s.options = i }, afterUpdate(t) { const e = t.legend; e.buildLabels(), e.adjustHitBoxes() }, afterEvent(t, e) { e.replay || t.legend.handleEvent(e.event) }, defaults: { display: !0, position: "top", align: "center", fullSize: !0, reverse: !1, weight: 1e3, onClick(t, e, i) { const s = e.datasetIndex, n = i.chart; n.isDatasetVisible(s) ? (n.hide(s), e.hidden = !0) : (n.show(s), e.hidden = !1) }, onHover: null, onLeave: null, étiquettes: { couleur: t => t.chart.options.color, boxWidth: 40, padding: 10, generateLabels(t) { const e = t.data.datasets, { étiquettes: { usePointStyle: i, pointStyle: s, textAlign: n, couleur: o, useBorderRadius: a, borderRadius: r } } = t.legend.options;retour t._getSortedDatasetMetas().map((t => { const l = t.controller.getStyle(i ? 0 : void 0), h = ki(l.borderWidth); return { texte: e[t.index].label, fillStyle: l.backgroundColor, fontColor: o, hidden: !t.visible, lineCap: l.borderCapStyle, lineDash: l.borderDash, lineDashOffset: l.borderDashOffset, lineJoin: l.borderJoinStyle, lineWidth: (h.width + h.height) / 4, strokeStyle: l.borderColor, pointStyle: s || l.pointStyle, rotatio n: l.rotation, textAlign: n || l.textAlign, borderRadius: a && (r || l.borderRadius), datasetIndex: t.index } }), this) } }, title: { color: t => t.chart.options.color, display: !1, position: "center", text: "" } }, descriptors: { _scriptable: t => !t.startsWith("on"), labels: { _scriptable: t => !["generateLabels", "filter", "sort"].includes(t) } } }; class va étend Hs{ constructeur(t){ super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(t, e){ const i = this.options; si(this.left = 0, this.top = 0, !i.display)retour void (this.width = this.height = this.right = this.bottom = 0); this.width = this.right = t, this.height = this.bottom = e; const s = n(i.text) ? i.text.length : 1; this._padding = ki(i.padding); const o = s * Si(i.font).lineHeight + this._padding.height; this.isHorizontal() ? this.height = o : this.width = o } isHorizontal(){ const t = this.options.position;retour"haut" === t || "bas" === t } _drawArgs(t){ const { haut: e, gauche: i, bas: s, droite: n, options: o } = this, a = o.align; let r, l, h, c = 0;retour ceci.estHorizontal() ? (l = ft(a, i, n), h = e + t, r = ni) : ("gauche" === o.position ? (l = i + t, h = ft(a, s, e), c = -.5 * C) : (l = nt, h = ft(a, e, s), c = .5 * C), r = se), { titreX: l, titreY: h, largeurmax: r, rotation: c } } dessiner(){ const t = ceci.ctx, e = ceci.options; si(!e.affichage)retour; const i = Si(e.font), s = i.lineHeight / 2 + ceci._padding.top, { titreX: n, titreY: o, largeurmax: a, rotation: r } = ceci._drawArgs(s); Ne(t, e.texte, 0, 0, i, { couleur: e.color, maxWidth: a, rotation: r, textAlign: ut(e.align), textBaseline: "middle", traduction: [n, o] }) } } var Ma = { id: "title", _element: va, start(t, e, i) { !function (t, e) { const i = nouveau va({ ctx: t.ctx, options: e, chart: t }); as.configure(t, i, e), as.addBox(t, i), t.titleBlock = i }(t, i) }, stop(t) { const e = t.titleBlock; as.removeBox(t, e), supprimer t.titleBlock }, beforeUpdate(t, e, i) { const s = t.titleBlock; as.configure(t, s, i), s.options = i }, valeurs par défaut: { align: "center", display: !1, police: { weight: "bold" }, fullSize: !0, padding: 10, position: "top", text: "", weight: 2e3 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const wa = new WeakMap; var ka = { id: "subtitle", start(t, e, i) { const s = new va({ ctx: t.ctx, options: i, chart: t }); as.configure(t, s, i), as.addBox(t, s), wa.set(t, s) }, stop(t) { as.removeBox(t, wa.get(t)), wa.delete(t) }, beforeUpdate(t, e, i) { const s = wa.get(t); as.configure(t, s, i), s.options = i }, defaults: { align: "center", display: !1, police: { weight: "normal" }, fullSize: !0, padding: 0, position: "top", text: "", weight: 1500 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const Sa = { average(t) { if (!t.length) return !1; let e, i, s = new Ensemble, n = 0, o = 0; pour(e = 0, i = t.length; e < i; ++e) { const i = t[e].élément; si(i & & i.a une valeur()) { const t = i.tooltip Position (); s.add(tx), n + = ty, ++o } } si(0 = o | | 0 = s.size) renvoie! 1; renvoie { x: [...s].réduire(((t, e) = > t + e)) / s.size, y: n / o } }, plus proche(t, e) { si(!t.length) renvoie! 1; soit i, s, n, o = ex, a = ey, r = Nombre.INFINITÉ_POSITIF; pour(i = 0, s = t.length; i < s; ++i) { const s = t[i].élément; si(s & & s.a une valeur()) { const t = q(e, s.getCenterPoint()); t < r && (r = t, n = s) } } si(n){ const t = n.tooltipPosition(); o = tx, a = ty }retour{ x: o, y: a } } };fonction Pa(t, e){retour e && (n(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t }fonction Da(t){ retour("string" == typeof t || t instanceof String) && t.indexOf("\n") > -1 ? t.split("\n") : t }fonction Ca(t, e){ const { élément: i, datasetIndex: s, index: n } = e, o = t.getDatasetMeta(s).controller, { étiquette: a, valeur: r } = o.getLabelAndValue(n);retour{ graphique: t, étiquette: a, analysé: o.getParsed(n), raw: t.data.datasets[s].data[n], formattedValue: r, dataset: o.getDataset(), dataIndex: n, datasetIndex: s, élément: i } }fonction Oa(t, e){ const i = t.chart.ctx, { body: s, footer: n, title: o } = t, { boxWidth: a, boxHeight: r } = e, l = Si(e.bodyFont), h = Si(e.titleFont), c = Si(e.footerFont), d = o.length, f = n.length, g = s.length, p = ki(e.padding);soit m = p.height, b = 0, x = s.reduce(((t, e) => t + e.before.length + e.lines.length + e.after.length), 0); si(x += t.beforeBody.length + t.afterBody.length, d && (m += d * h.lineHeight + (d - 1) * e.titleSpacing + e.titleMarginBottom), x){ m += g * (e.displayColors ? Math.max(r, l.lineHeight) : l.lineHeight) + (xg) * l.lineHeight + (x - 1) * e.bodySpacing } f && (m += e.footerMarginTop + f * c.lineHeight + (f - 1) * e.footerSpacing);soit _ = 0; const y = function (t) { b = Math.max(b, i.measureText(t).width + _) };retour i.save(), i.font = h.string, u(t.title, y), i.font = l.string, u(t.beforeBody.concat(t.afterBody), y), _ = e.displayColors ? a + 2 + e.boxPadding : 0, u(s, (t => { u(t.before, y), u(t.lines, y), u(t.after, y) })), _ = 0, i.font = c.string, u(t.footer, y), i.restore(), b += p.width, { largeur: b, hauteur: m } }fonction Aa(t, e, i, s){ const { x: n, largeur: o } = i, { largeur: a, chartArea: { gauche: r, droite: l } } = t; let h = "centre";retour"centre" === s ? h = n <= (r + l) / 2 ? "gauche" : "droite" : n <= o / 2 ? h = "gauche" : n >= ao / 2 && (h = "droite"), fonction(t, e, i, s){ const { x: n, largeur: o } = s, a = i.caretSize + i.caretPadding;retour"gauche" === t && n + o + a > e.largeur || "droite" === t && n - oa < 0 || void 0 } (h, t, e, i) && (h = "centre"), h }fonction Ta(t, e, i){ const s = i.yAlign || e.yAlign || fonction(t, e){ const{ y: i, hauteur: s } = e;retour i < s / 2 ? "top" : i > t.height - s / 2 ? "bottom" : "centre" } (t, i);retour{ xAlign: i.xAlign || e.xAlign || Aa(t, e, i, s), yAlign: s }}fonction La(t, e, i, s){ const { caretSize: n, caretPadding: o, cornerRadius: a } = t, { xAlign: r, yAlign: l } = i, h = n + o, { topLeft: c, topRight: d, bottomLeft: u, bottomRight: f } = wi(a);soit g = fonction(t, e){soit{ x: i, width: s }=t;retour"droite" === e ? i -= s : "centre" === e && (i -= s / 2), i } (e, r); const p = function (t, e, i) { let { y: s, height: n } = t; return "top" === e ? s += i : s -= "bottom" === e ? n + i : n / 2, s }(e, l, h); return "center" === l ? "left" === r ? g += h : "right" === r && (g -= h) : "left" === r ? g -= Math.max(c, u) + n : "right" === r && (g += Math.max(d, f) + n), { x: J(g, 0, s.width - e.width), y: J(p, 0, s.height - e.height) } } function Ea(t, e, i) { const s = ki(i.padding);retour"centre" === e ? t.x + t.width / 2 : "droite" === e ? t.x + t.width - s.droite : t.x + s.gauche }fonction Ra(t){retour Pa([], Da(t)) }fonction Ia(t, e){ const i = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;retour i ? t.override(i) : t } const za = { avantTitre: e, titre(t) { si(t.length > 0){ const e = t[0], i = e.chart.data.labels, s = i ? i.length : 0; si(ceci && ceci.options && "dataset" === ceci.options.mode)retour e.dataset.label || ""; si(e.label)retour e.label; si(s > 0 && e.dataIndex < s)retourne i[e.dataIndex] }retourne"" }, afterTitle: e, beforeBody: e, beforeLabel: e, label(t) { si(this && this.options && "dataset" === this.options.mode)retourne t.label + ": " + t.formattedValue || t.formattedValue;soit e = t.dataset.label || ""; e && (e += ": "); const i = t.formattedValue;retourne s(i) || (e += i), e }, labelColor(t) { const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);retour{ borderColor: e.borderColor, backgroundColor: e.backgroundColor, borderWidth: e.borderWidth, borderDash: e.borderDash, borderDashOffset: e.borderDashOffset, borderRadius: 0 } }, labelTextColor() {retour this.options.bodyColor }, labelPointStyle(t) { const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);retour{ pointStyle: e.pointStyle, rotation: e.rotation } }, afterLabel: e, afterBody: e, beforeFooter: e, footer: e, afterFooter: e };fonction Fa(t, e, i, s){ const n = t[e].call(i, s);retour void 0 === n ? za[e].call(i, s) : n }classe Va étend Hs{positionneurs statiques = Sa; constructeur(t){ super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0 } initialize(t){ this.options = t, this._cachedAnimations = void 0, this.$context = void 0 } _resolveAnimations(){ const t = this._cachedAnimations; if (t) return t; const e = this.chart, i = this.options.setContext(this.getContext()), s = i.enabled && e.options.animation && i.animations, n = new Os(this.chart, s);retour s._cacheable && (this._cachedAnimations = Object.freeze(n)), n } getContext(){retour this.$context || (this.$context = (t = this.chart.getCont; a < r; ++a) l.push(Ca(this.chart, e[a]));retour t.filter && (l = l.filter(((e, s, n) => t.filter(e, s, n, i)))), t.itemSort && (l = l.sort(((e, s) => t.itemSort(e, s, i)))), u(l, (e => { const i = Ia(t.callbacks, e); s.push(Fa(i, "labelColor", this, e)), n.push(Fa(i, "labelPointStyle", this, e)), o.push(Fa(i, "labelTextColor", this, e)) })), this.labelColors = s, this.labelPointStyles = n, this.labelTextColors = o, this.dataPoints = l, l } update(t, e){ const i = this.options.setContext(this.getContext()), s = this._active; let n, o = []; if (s.length) { const t = Sa[i.position].call(this, s, this._eventPosition); o = this._createItems(i), this.title = this.getTitle(o, i), this.beforeBody = this.getBeforeBody(o, i), this.body = this.getBody(o, i), this.afterBody = this.getAfterBody(o, i), this.footer = this.getFooter(o, i); const e = this._size = Oa(this, i), a = Object.assign({}, t, e), r = Ta(this.chart, i, a), l = La(i, a, r, this.chart); this.xAlign = r.xAlign, this.yAlign = r.yAlign, n = { opacité: 1, x: lx, y: ly, largeur: e.width, hauteur: e.height, caretX: tx, caretY: ty } } else 0 !== this.opacity && (n = { opacité: 0 }); this._tooltipItems = o, this.$context = void 0, n && this._resolveAnimations().update(this, n), t && i.external && i.external.call(this, { chart: this.chart, tooltip: this, replay: e }) } drawCaret(t, e, i, s){ const n = this.getCaretPosition(t, i, s); e.lineTo(n.x1, n.y1), e.lineTo(n.x2, n.y2), e.lineTo(n.x3, n.y3) } getCaretPosition(t, e, i){ const { xAlign: s, yAlign: n } = this, { caretSize: o, cornerRadius: a } = i, { topLeft: r, topRight: l, bottomLeft: h, bottomRight: c } = wi(a), { x: d, y: u } = t, { width: f, height: g } = e; let p, m, b, x, _, y; retour "centre" === n ? (_ = u + g / 2, "gauche" === s ? (p = d, m = po, x = _ + o, y = _ - o) : (p = d + f, m = p + o, x = _ - o, y = _ + o), b = p) : (m = "gauche" === s ? d + Math.max(r, h) + o : "droite" === s ? d + f - Math.max(l, c) - o : this.caret X, "haut" === n ? (x = u, _ = xo, p = mo, b = m + o) : (x = u + g, _ = x + o, p = m + o, b = mo), y = x), { x1: p, x2: m, x3: b, y1: x, y2: _, y3: y } } drawTitle(t, e, i) { const s = this.titre, n = s.longueur; let o, a, r; si(n){ const l = Oi(i.rtl, this.x, this.width); pour(tx = Ea(this, i.titleAlign, i), e.textAlign = l.textAlign(i.titleAlign), e.textBaseline = "milieu", o = Si(i.titleFont), a = i.titleSpacing, e.fillStyle = i.titleColor, e.font = o.string, r = 0; r < n; ++r) e.fillText(s[r], lx(tx), t.y + o.lineHeight / 2), t.y += o.lineHeight + a, r + 1 === n && (t.y += i.titleMarginBottom - a) } } _drawColorBox(t, e, i, s, n){ const a = this.labelColors[i], r = this.labelPointStyles[i], { boxHeight: l, boxWidth: h } = n, c = Si(n.bodyFont), d = Ea(this, "gauche", n), u = sx(d), f = l < c.lineHeight ? (c.lineHeight - l) / 2 : 0, g = e.y + f; if (n.usePointStyle) { const e = { rayon: Math.min(h, l) / 2, pointStyle: r.pointStyle, rotation: r.rotation, borderWidth: 1 }, i = s.leftForLtr(u, h) + h / 2, o = g + l / 2; t.strokeStyle = n.multiKeyBackground, t.fillStyle = n.multiKeyBackground, Le(t, e, i, o), t.strokeStyle = a.borderColor, t.fillStyle = a.backgroundColor, Le(t, e, i, o) } else { t.lineWidth = o(a.borderWidth) ? Math.max(...Object.values(a.borderWidth)) : a.borderWidth || 1, t.strokeStyle = a.borderColor, t.setLineDash(a.borderDash || []), t.lineDashOffset = a.borderDashOffset || 0; const e = s.gauchePourLtr(u, h), i = s.leftForLtr(s.xPlus(u, 1), h - 2), r = wi(a.borderRadius); Object.values(r).some((t => 0 !== t)) ? (t.beginPath(), t.fillStyle = n.multiKeyBackground, He(t, { x: e, y: g, w: h, h: l, rayon: r }), t.fill(), t.stroke(), t.fillStyle = a.backgroundColor, t.beginPath(), He(t, { x: i, y: g + 1, w: h - 2, h: l - 2, rayon: r }), t.fill()) : (t.fillStyle = n.multiKeyBackground, t.fillRect(e, g, h, l), t.strokeRect(e, g, h, l), t.fillStyle = a.backgroundColor, t.fillRect(i, g + 1, h - 2, l - 2)) } t.fillStyle = this.labelTextColors[i] } drawBody(t, e, i){ const { body: s } = this, { bodySpacing: n, bodyAlign: o, displayColors: a, boxHeight: r, boxWidth: l, boxPadding: h } = i, c = Si(i.bodyFont); let d = c.lineHeight, f = 0; const g = Oi(i.rtl, this.x, this.width), p = function (i) { e.fillText(i, gx(t.x + f), t.y + d / 2), t.y += d + n }, m = g.textAlign(o); let b, x, _, y, v, M, w; pour(e.textAlign = o, e.textBaseline = "milieu", e.font = c.string, tx = Ea(this, m, i), e.fillStyle = i.bodyColor, u(this.avant le corps, p), f = a && "droite"! == m ? "centre" === o ? l / 2 + h : l + 2 + h : 0, y = 0, M = s.longueur; y < M; ++y) { pour(b = s[y], x = this.labelTextColors[y], e.fillStyle = x, u(b.avant, p), _ = b.lignes, a && _.longueur && (this._drawColorBox(e, t, y, g, i), d = Math.max(c.lineHeight, r)), v = 0, w = _.longueur; v < w; ++v) p(_[v]), d = c.lineHeight; u(b.après, p) } f = 0, d = c.lineHeight, u(this.aprèsBody, p), ty -= n } drawFooter(t, e, i){ const s = this.pieddepage, n = s.longueur; let o, a; si(n){ const r = Oi(i.rtl, this.x, this.width); for (tx = Ea(this, i.footerAlign, i), t.y += i.footerMarginTop, e.textAlign = r.textAlign(i.footerAlign), e.textBaseline = "middle", o = Si(i.footerFont), e.fillStyle = i.footerColor, e.font = o.string, a = 0; a < n; ++a)e.fillText(s[a], rx(tx), t.y + o.lineHei ght / 2), t.y += o.lineHeight + i.footerSpacing } } drawBackground(t, e, i, s){ const { xAlign: n, yAlign: o } = this, { x: a, y: r } = t, { largeur: l, hauteur: h } = i, { hautgauche: c, hautdroite: d, basgauche: u, basdroite: f } = wi(s.cornerRadius); e.fillStyle = s.backgroundColor, e.strokeStyle = s.borderColor, e.lineWidth = s.borderWidth, e.beginPath(), e.moveTo(a + c, r), "top" === o && this.drawCaret(t, e, i, s), e.lineTo(a + ld, r), e.quadraticCurveTo(a + l, r, a + l, r + d), "center" === o && "right" === n && this.drawCaret(t, e, i, s), e.lineTo(a + l, r + hf), e.quadraticCurveTo(a + l, r + h, a + lf, r + h), "bottom" = == o && this.drawCaret(t, e, i, s), e.lineTo(a + u, r + h), e.quadraticCurveTo(a, r + h, a, r + hu), "centre" === o && "gauche" === n && this.drawCaret(t, e, i, s), e.lineTo(a, r + c), e.quadraticCurveTo(a, r, a + c, r), e.closePath(), e.fill(), s.borderWidth > 0 && e.stroke() } _updateAnimationTarget(t){ const e = this.chart, i = this.$animations, s = i && i.x, n = i && i.y; if (s || n) { const i = Sa[t.position].call(this, this._active, this._eventPosition); if (!i) return; const o = this._size = Oa(this, t), a = Object.assign({}, i, this._size), r = Ta(e, t, a), l = La(t, a, r, e); s._to === lx && n._to === ly || (this.xAlign = r.xAlign, this.yAlign = r.yAlign, this.width = o.width, this.height = o.height, this.caretX = ix, this.caretY = iy, this._resolveAnimations().update(this, l)) } } _willRender(){ return !!this.opacity } draw(t){ const e = this.options.setContext(this.getContext()); let i = this.opacity; if (!i) return; this._updateAnimationTarget(e); const s = { largeur: this.width, hauteur: this.height }, n = { x: this.x, y: this.y }; i = Math.abs(i) < .001 ? 0 : i; const o = ki(e.padding), a = cet.titre.longueur || cet.avant.longueur.corps || cet.après.longueur.corps || cet.pied.longueur.; e.activé && a && (t.save(), t.globalAlpha = i, cet.drawBackground(n, t, s, e), Ai(t, e.textDirection), n.y += o.top, cet.drawTitle(n, t, e), cet.drawBody(n, t, e), cet.drawFooter(n, t, e), Ti(t, e.textDirection), t.restore()) } getActiveElements(){retourne this._active || [] } setActiveElements(t, e){ const i = cet._active, s = t.map((({ datasetIndex: t, index: e }) => { const i = this.chart.getDatasetMeta(t); if (!i) throw new Error("Impossible de trouver un ensemble de données à l'index " + t); return { datasetIndex: t, element: i.data[e], index: e } })), n = !f(i, s), o = this._positionChanged(s, e); (n || o) && (this._active = s, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0)) } handleEvent(t, e, i = !0){ if (e && this._ignoreReplayEvents) return !1; this._ignoreReplayEvents = !1; const s = this.options, n = this._active || [], o = this._getActiveElements(t, n, e, i), a = this._positionChanged(o, t), r = e || !f(o, n) || a;retour r && (this._active = o, (s.enabled || s.external) && (this._eventPosition = { x: tx, y: ty }, this.update(!0, e))), r } _getActiveElements(t, e, i, s){ const n = this.options; si("mouseout" === t.type)retour[]; si(!s)retour e.filter((t => this.chart.data.datasets[t.datasetIndex] && void 0 !== this.chart.getDatasetMeta(t.datasetIndex).controller.getParsed(t.index))); const o = this.chart.getElementsAtEventForMode(t, n.mode, n, i);retour n.reverse && o.reverse(), o } _positionChanged(t, e){ const { caretX: i, caretY: s, options: n } = this, o = Sa[n.position].call(this, t, e); retour!1 !== o && (i !== ox || s !== oy) } } var Ba = { id: "tooltip", _element: Va, positioners: Sa, afterInit(t, e, i) { i && (t.tooltip = new Va({ chart: t, options: i })) }, beforeUpdate(t, e, i) { t.tooltip && t.tooltip.initialize(i) }, reset(t, e, i) { t.tooltip && t.tooltip.initialize(i) }, afterDraw(t) { const e = t.tooltip; if (e && e._willRender()) { const i = { tooltip: e }; if (!1 === t.notifyPlugins("beforeTooltipDraw", { ...i, cancelable: !0 })) return; e.draw(t.ctx), t.notifyPlugins("afterTooltipDraw", i) } }, afterEvent(t, e) { if (t.tooltip) { const i = e.replay; t.tooltip.handleEvent(e.event, i, e.inChartArea) && (e.changed = !0) } }, defaults: { enabled: !0, external: null, position: "average", backgroundColor: "rgba(0,0,0,0.8)", titleColor: "#fff", titleFont: { weight: "bold" }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: "left", bodyColor: "#fff", bodySpacing: 2, bod yFont: {}, bodyAlign: « gauche », footerColor: « #fff », footerSpacing: 2, footerMarginTop: 6, footerFont: { weight: « bold » }, footerAlign: « gauche », padding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, boxHeight: (t, e) => e.bodyFont.size, boxWidth: (t, e) => e.bodyFont.size, multiKeyBackground: « #fff », displayColors: !0, boxPadding: 0, borderColor: « rgba(0,0,0,0) », borderWidth: 0, animation: { durée: 400, easing: « easeOutQuart » }, animations: { nombres: { type: « nombre », propriétés: [« x », « y », « largeur », « hauteur », « caretX », « caretY »] }, opacité: { easing: « linéaire », durée: 200 } }, rappels: za }, defaultRoutes: { bodyFont: « police », f ooterFont: "police", titleFont: "police" }, descripteurs: { _scriptable: t => "filtre" !== t && "itemSort" !== t && "externe" !== t, _indexable: !1, rappels: { _scriptable: !1, _indexable: !1 }, animation: { _fallback: !1 }, animations: { _fallback: "animation" } }, additionalOptionScopes: ["interaction"] };retour An.register(Yn, jo, fo, t), An.helpers = { ...Wi }, An._adapters = Rn, An.Animation = Cs, An.Animations = Os, An.animator = xt, An.controllers = en.controllers.items, An.DatasetController = Ns, An.Element = Hs, An.elements = fo, An.Interaction = Xi, An.layouts = as, An.platforms = Ss, An.Scale = Js, An.Ticks = ae, Object.assign(An, Yn, jo, fo, t, Ss), An.Chart = An, "undefined" != typeof window && (window.Chart = An), An}));
//# sourceMappingURL=chart.umd.js.map